# 程序猿的今日头条面试历险记

本萌妹纸一枚，前端自学一年，在毕业旅行之际接到预约今日头条面试电话，为了不错过面试，也不错过风景，恳求协商面试时间为晚上八点半开始。你们能想象在云南花语牧场临时抱佛脚的我有多二嘛。。。。一面面试官小哥哥人超级 nice，问的问题偏基础，都是常见的前端面试题，由于本人技术栈为 Angular 以及 Vue，因此面试题不涉及 React。最最重要的是，大概小哥哥赶着下班，我最最最薄弱的编程环节，出的题目算很简单很良心惹，在此记录分享一下。

## HTTP1、HTTP2 以及 HTTPs 的区别

HTTP2 使用的是二进制传送，HTTP1.X 是文本（字符串）传送。
HTTP1.X 使用的是明文的文本传送，而 HTTP2 使用的是二进制传送，二进制传送的单位是帧和流。帧组成了流，同时流还有流 ID 标示，通过流 ID 就牵扯出了第二个区别

HTTP2 支持多路复用。
因为有流 ID，所以通过同一个 HTTP 请求实现多个 HTTP 请求传输变成了可能，可以通过流 ID 来标示究竟是哪个流从而定位到是哪个 HTTP 请求

HTTP2 头部压缩。
HTTP2 通过 gzip 和 compress 压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引 Id 就行，通过索引 ID 就可以知道表头的值了

HTTP2 支持服务器推送

HTTPs 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用。

HTTP 是超文本传输协议，信息是明文传输，HTTPs 则是具有安全性的 SSL 加密传输协议。

HTTP 和 HTTPs 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。

HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

## HTTPs 是不是都用了对称加密算法，哪些涉及到非对称加密算法

HTTPS 要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。

## Service Worker 的原理

之前有 PWA 开发经验，所以问了这个问题。

Service Worker 是运行在浏览器背后的独立线程，可以实现缓存技术。使用 Service Worker，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

注册：首先要在 JS 中进行注册

安装：注册完成之后，会触发 install，在安装的过程中，如果所有需要离线缓存的静态资源都已经成功缓存，那么 Service Worker 就安装完成进入激活步骤，如果有文件下载失败或缓存失败，Service Worker 就无法完成安装过程。

激活：Service Worker 对它作用域内的所有页面进行控制，fetch 用于拦截用户请求并响应，返回 Promise 对象,成功安装 Service Worker 后，当用户下次再进入页面，返回已返回的文件。

## 可视化相关

由于项目涉及数据可视化，问了 echarts 基于什么实现，canvas 和 SVG 的区别了解吗，有没有自己用 canvas 实现一些动画等等。

SVG 是和图像分辨率无关的矢量图形格式，如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。而 Canvas 通过 JS 来绘制 2D 图形，如果其位置发生变化，那么整个场景也需要重新绘制，依赖分辨率。

然后自己并没有用 canvas 实现过动画，只直接调用 echarts。

## H5 新加了哪些新特性，它为什么要加这些语义化的标签 H5

新特性就略过叭。。。至于第二个问题是为了让网页结构更清晰，方便维护，而且能让浏览器更好的解析。

## 对 SEO 了解吗，平时项目中考虑过 SEO 吗

项目没有考虑过 seo，但是知道代码中要考虑 meta、title、description、alt 等标签优化。

## Promise 和 Rxjs 里面的 observe 有什么区别

当异步完成或者失败时，Promise 处理单个事件，observe 可以处理一个或者多个事件。

Promise 不可被取消，observe 可以被取消

observable 可以 retry，或者多次调用。对于 Promise，不论在后面怎么调用 then，实际上的异步操作只会被执行一次，多次调用没有效果；但是对于 observable，多次调用 forEach 或者使用 retry 方法，能够触发多次异步操作。

observable 还提供 map、filter、reduce 等类似的操作符。

## 代码编写：对于封装好的 API，如何截获参数，比如 xml 对象的 open 方法会传入 url，method，headers 参数，现在需要截获 headers 添加一些自定义的属性，怎么做

```js
var _open = xmlHttpRequest.prototype.open;
xmlHttpRequest.prototype.open = function(url, method, headers) {
  headers = {};
  _open.call(this, url, method, headers);
};
```

## JQuery 的 \$ 怎么实现的

```js
(function(w) {
  //工厂
  function jQuery(selector, context) {
    return new jQuery.fn.init(selector, context);
  }
  //给原型提供一个简写方式
  jQuery.fn = jQuery.prototype = {};
  //init才是jQuery中真正的构造函数
  var init = (jQuery.fn.init = function(selector, context) {});
  //把构造函数的原型，替换为jQuery工厂的原型
  init.prototype = jQuery.fn;
  w.jQuery = w.$ = jQuery;
})(window);
```

## JS 中一般怎么实现继承的

```js
//父类
function Super() {
  this.flag = true;
}
//方法绑定在父类原型属性上
Super.prototype.getFlag = function() {
  return this.flag;
};
//子类
function Sub() {
  this.subFlag = false;
}
```

为了规避原型链继承和构造函数继承的缺点，一般采用组合继承通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。

```js
function Super() {
  this.flag = true;
}
Super.prototype.getFlag = function() {
  return this.flag; //继承方法
};
function Sub() {
  this.subFlag = flase;
  Super.call(this); //继承属性
}
Sub.prototype = new Super();
Sub.prototype.constructor = Sub; //修复构造函数指向
Super.prototype.getSubFlag = function() {
  return this.flag;
};
```

写完之后又问了我原型链继承和构造函数继承的缺点

## ES6 中怎么实现继承，原理是啥

ES6 封装了 class，extends 关键字来实现继承，内部其实也是 ES5 组合继承的方式，通过 call 借用构造函数，在 A 类构造函数中调用相关属性，再用原型链的连接实现方法的继承

JS 实现一个单例模式

```js
const getSingle = function(fn) {
  let result;
  return function() {
    return result || (result = fn.apply(this, arguments));
  };
};
```

CSS 画一个等腰梯形

其实有点蒙也很紧张，因为我只会画三角形，我就说两个三角形加一个正方形实现。实现三角形的代码如下

```css
.box {
  height: 0;
  width: 0;
  border-left: 50px solid transparent;
  border-right: 50px solid transparent;
  border-top: 100px solid red;
}
```

然后面试官说那你得实现梯形呀，我说移动位置拼接成等腰梯形，用 transform 实现，让我写出来。。。

## 用栈实现一个队列

```js
function Quene() {
  var stack1 = [],
    stack2 = [];
  this.push = function(node) {
    stack1.push(node);
  };

  this.pop = function() {
    if (stack2.length == 0) {
      if (stack1.length == 0) {
        return null;
      } else {
        var len = stack1.length;
        for (var i = 0; i < len; i++) {
          stack2.push(stack1.pop());
        }
        return stack2.pop();
      }
    } else {
      return stack2.pop();
    }
  };
}
```
