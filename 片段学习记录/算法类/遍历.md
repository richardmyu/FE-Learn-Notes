# 遍历

### 1.介绍下深度优先遍历和广度优先遍历，如何实现？

**深度优先遍历（DFS）**

深度优先遍历（Depth-First-Search），是搜索算法的一种，它沿着树的深度遍历树的节点，尽可能深地搜索树的分支。

简单的说，DFS 就是从图中的一个节点开始追溯，直到最后一个节点，然后回溯，继续追溯下一条路径，直到到达所有的节点，如此往复，直到没有路径为止。一般用栈数据结构来辅助实现 DFS 算法。

```js
DFS = (node, nodeList = []) => {
  if (node) {
    let stack = [];
    stack.push(node);

    while (stack.length) {
      let item = stack.pop();
      let children = item.children;
      nodeList.push(item);

      if(children && children.length){
        for (let i = children.length - 1; i >= 0; i--){
          stack.push(children[i]);
        }
      }
    }
  }

  return nodeList;
}
```

**广度优先遍历（BFS）**

广度优先遍历（Breadth-First-Search）是从根节点开始，沿着图的宽度遍历节点，如果所有节点均被访问过，则算法终止，BFS 同样属于盲目搜索，一般用队列数据结构来辅助实现 BFS。

BFS 从一个节点开始，尝试访问尽可能靠近它的目标节点。本质上这种遍历在图上是逐层移动的，首先检查最靠近第一个节点的层，再逐渐向下移动到离起始节点最远的层

```js
BFS = (node, nodeList = []) => {
  if (node) {
    let queue = [];
    queue.push(node);

    while (queue.length) {
      let item = queue.shift();
      let children = item.children;
      nodeList.push(item);

      if (children && children.length) {
        for (let i = 0; i < children.length; i++) {
          queue.push(children[i])
        }
      }
    }
  }

  return nodeList;
}
```

> [source](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/9)

### 2.请分别用深度优先思想和广度优先思想实现一个拷贝函数？

> [source](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/10)
