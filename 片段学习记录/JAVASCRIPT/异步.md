# 异步

### 1.setTimeout、Promise、Async/Await 的区别

microtask & macrotask

> [第 8 题：setTimeout、Promise、Async/Await 的区别 #33](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/33)

### 2.Async/Await 如何通过同步的方式实现异步

async 函数是什么？一句话，它就是 Generator 函数的语法糖。

> [第 9 题：Async/Await 如何通过同步的方式实现异步 #156](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/156)

### 3.常见异步笔试题，请写出代码的运行结果

```js
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}
async function async2() {
  console.log('async2');
}

console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0)

async1();

new Promise(function(resolve) {
  console.log('promise1');
  resolve();
}).then(function() {
  console.log('promise2');
});
console.log('script end');

// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

> [第 10 题：常见异步笔试题，请写出代码的运行结果 #7](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7)

### 4.JS 异步解决方案的发展历程以及优缺点

回调函数

- 简单、容易理解和部署
- 不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。

事件监听

- 较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以"去耦合"（Decoupling），有利于实现模块化。
- 缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。

发布/订阅

- 这种方法的性质与"事件监听"类似，但是明显优于后者。因为我们可以通过查看"消息中心"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

Promises对象

- 回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。
- 缺点就是编写和理解，都相对比较难。

generator

async/await

> [第 12 题：JS 异步解决方案的发展历程以及优缺点。 #11](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/11)

### 5.Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？

promise 构造函数是同步执行的，then 方法是异步执行的

> [第 13 题：Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？ #19](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/19)

### 6.实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度实现

> [第 42 题：实现一个 sleep 函数，比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度实现 #63](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/63)

### 7.第 64 题：模拟实现一个 Promise.finally #109

> [第 64 题：模拟实现一个 Promise.finally #109](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/109)

### 8.第 80 题：介绍下 Promise.all 使用、原理实现及错误处理 #130

> [source](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/130)

### 9.第 89 题：设计并实现 Promise.race() #140

> [source](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/140)
