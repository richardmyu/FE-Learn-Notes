
### 4.Font

#### 4.1.font

设置所有字体属性

- `font-style` 规定字体样式
- `font-variant` 规定字体异体
- `font-weight` 规定字体粗细
- `font-size/line-height` 规定字体尺寸/行高
- `font-family` 规定字体系列
- `caption` 定义被标题控件（比如按钮、下拉列表等）使用的字体
- `icon` 定义被图标标记使用的字体
- `menu` 定义被下拉列表使用的字体
- `message-box` 定义被对话框使用的字体
- `small-caption caption` 字体的小型版本
- `status-bar` 定义被窗口状态栏使用的字体

> 说明:这个简写属性用于一次设置元素字体的两个或更多方面。使用 `icon` 等关键字可以适当地设置元素的字体，使之与用户计算机环境中的某个方面一致。注意，如果没有使用这些关键词，至少要指定字体大小和字体系列。
> 可以按顺序设置如下属性: `font-style、font-variant、font-weight、font-size/line-height、font-family`

#### 4.2.font-family

规定元素的字体系列

- `family-name/generic-family` 用于某个元素的字体族名称或/及类族名称的一个优先表。默认值：取决于浏览器。
- `inherit` 规定应该从父元素继承字体系列

`font-family` 可以把多个字体名称作为一个"回退"系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。也就是说，`font-family` 属性的值是用于某个元素的字体族名称或/及类族名称的一个优先表。浏览器会使用它可识别的第一个值。

有两种类型的字体系列名称：

- 指定的系列名称：具体字体的名称，比如："times"、"courier"、"arial"。
- 通常字体系列名称：比如："serif"、"sans-serif"、"cursive"、"fantasy"、"monospace"

> 提示：使用逗号分割每个值，并始终提供一个类族名称作为最后的选择。
> 注意：使用某种特定的字体系列（Geneva）完全取决于用户机器上该字体系列是否可用；这个属性没有指示任何字体下载。因此，强烈推荐使用一个通用字体系列名作为后路。

#### 4.3.font-size

设置字体的尺寸

- `xx-small/x-small/small/medium/large/x-large/xx-large` 把字体的尺寸设置为不同的尺寸，从 `xx-small` 到 `xx-large`。默认值：`medium`
- `smaller` 把 `font-size` 设置为比父元素更小的尺寸。
- `larger` 把 `font-size` 设置为比父元素更大的尺寸。
- `length` 把 `font-size` 设置为一个固定的值。
- `%` 把 `font-size` 设置为基于父元素的一个百分比值。
- `inherit` 规定应该从父元素继承字体尺寸。

> 该属性设置元素的字体大小。注意，实际上它设置的是字体中字符框的高度；实际的字符字形可能比这些框高或矮（通常会矮）。
> 各关键字对应的字体必须比一个最小关键字相应字体要高，并且要小于下一个最大关键字对应的字体。

#### 4.4.font-size-adjust

为某个元素规定一个 `aspect` 值，这样就可以保持首选字体的 `x-height`。

- `none` 默认。如果此字体不可用，则不保持此字体的 `x-height`。
- `number` 定义字体的 `aspect` 值比率。

可使用的公式：
`首选字体的字体尺寸 * （font-size-adjust 值 / 可用字体的 aspect 值）= 可应用到可用字体的字体尺寸`

> Internet Explorer 不支持 `font-size-adjust` 属性。
> 字体的小写字母 "x" 的高度与 "`font-size`" 高度之间的比率被称为一个字体的 `aspect` 值。当字体拥有高的 `aspect` 值时，那么当此字体被设置为很小的尺寸时会更易阅读。举例：Verdana 的 `aspect` 值是 0.58（意味着当字体尺寸为 100px 时，它的 `x-height` 是 58px ）。Times New Roman 的 `aspect` 值是 0.46。这就意味着 Verdana 在小尺寸时比 Times New Roman 更易阅读。

#### 4.5.font-stretch

对当前的 `font-family` 进行伸缩变形

- `normal` 默认值。把缩放比例设置为标准。
- `wider` 把伸展比例设置为更进一步的伸展值
- `narrower` 把收缩比例设置为更进一步的收缩值
- `ultra-condensed/extra-condensed/condensed/semi-condensed/semi-expanded/expanded/extra-expanded/ultra-expanded` 设置 `font-family` 的缩放比例。"`ultra-condensed`" 是最宽的值，而 "`ultra-expanded`" 是最窄的值

> 所有主流浏览器都不支持 `font-stretch` 属性。

#### 4.6.font-style

定义字体的风格

- `normal` 默认值。浏览器显示一个标准的字体样式
- `italic` 浏览器会显示一个斜体的字体样式
- `oblique` 浏览器会显示一个倾斜的字体样式
- `inherit` 规定应该从父元素继承字体样式

> 该属性设置使用斜体、倾斜或正常字体。斜体字体通常定义为字体系列中的一个单独的字体。理论上讲，用户代理可以根据正常字体计算一个斜体字体。

#### 4.7.font-variant

设置小型大写字母的字体显示文本

- `normal` 默认值。浏览器会显示一个标准的字体
- `small-caps` 浏览器会显示小型大写字母的字体
- `inherit` 规定应该从父元素继承 `font-variant` 属性的值

> `font-variant` 属性设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。
> 该属性主要用于定义小型大写字母文本。理论上，用户代理可以根据正常字体计算出小型大写字母字体。

#### 4.8.font-weight

设置文本的粗细

- `normal` 默认值。定义标准的字符
- `bold` 定义粗体字符
- `bolder` 定义更粗的字符
- `lighter` 定义更细的字符
- `100-900` 定义由粗到细的字符。400 等同于 `normal`，而 700 等同于 `bold`
- `inherit` 规定应该从父元素继承字体的粗细

> 该属性用于设置显示元素的文本中所用的字体加粗。每个数字值对应的字体加粗必须至少与下一个最小数字一样细，而且至少与下一个最大数字一样粗。

### 5.List

#### 5.1.list-style

设置所有的列表属性

- `list-style-type` 设置列表项标记的类型
- `list-style-position` 设置在何处放置列表项标记
- `list-style-image` 使用图像来替换列表项的标记
- `inherit` 规定应该从父元素继承

> 该属性是一个简写属性，涵盖了所有其他列表样式属性。由于它应用到所有 `display` 为 `list-item` 的元素，所以在普通的 HTML 和 XHTML 中只能用于 li 元素，不过实际上它可以应用到任何元素，并由 `list-item` 元素继承。
> 可以按顺序设置如下属性：`list-style-type、list-style-position、list-style-image`

#### 5.2.list-style-image

- `URL` 图像的路径
- `none` 默认。无图形被显示
- `inherit` 规定应该从父元素继承

> 这个属性指定作为一个有序或无序列表项标志的图像。图像相对于列表项内容的放置位置通常使用 `list-style-position` 属性控制。
> 注释：请始终规定一个 "`list-style-type`" 属性以防图像不可用。

#### 5.3.list-style-position

- `inside` 列表项目标记放置在文本以内，且环绕文本根据标记对齐
- `outside` 默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐
- `inherit` 规定应该从父元素继承

> 该属性用于声明列表标志相对于列表项内容的位置。外部 (`outside`) 标志会放在离列表项边框边界一定距离处，不过这距离在 CSS 中未定义。内部 (`inside`) 标志处理为好像它们是插入在列表项内容最前面的行内元素一样。

#### 5.4.list-style-type

- `none` 无标记
- `disc` 默认。标记是实心圆
- `circle` 标记是空心圆
- `square` 标记是实心方块
- `decimal` 标记是数字
- `decimal-leading-zero` 0 开头的数字标记。(01， 02， 03， 等。)

### 6.Margin

#### 6.1.margin

设置所有外边距属性。该属性可以有 1 到 4 个值

- `auto` 浏览器计算外边距
- `length` 规定以具体单位计的外边距值，比如像素、厘米等。默认值是 0px
- `%` 规定基于父元素的宽度的百分比的外边距
- `inherit` 规定应该从父元素继承外边距

#### 6.2.margin-top/right/botom/left

设置元素的 `上/右/下/左` 外边距(这个属性对于不可替换的 `inline` 元素没有效果，比如 `<tt>` 或者 `<span>`)

- `auto` 浏览器设置的上/右/下/左外边距。
- `length` 定义固定的上/右/下/左外边距。默认值是 0。
- `%` 定义基于父对象总宽度的百分比上/右/下/左外边距。
- `inherit` 规定应该从父元素继承上/右/下/左外边距。

> 这个简写属性设置一个元素所有外边距的宽度，或者设置各边上外边距的宽度。
> 块级元素的垂直相邻外边距会合并，而行内元素实际上不占上下外边距。行内元素的的左右外边距不会合并。同样地，浮动元素的外边距也不会合并。允许指定负的外边距值，不过使用时要小心。
> 注释：允许使用负值。

**margin-top 的一个小 bug:**

当父级没有设置 `margin-top` 或 `border` 时，子级会把自身的 `margin-top` 值传递给父级元素

> 1.给父级元素设置 `border`；（缺点：影响盒子大小） 2.把子级的 `margin-top` 换成 `padding-top`；（缺点：影响盒子大小） 3.对父级用 `overflow:hidden/auto`； 4.对父级用 `display:inline-block`；（有时候可能会影响布局）

### 7.Padding

#### 7.1.padding

设置所有内边距属性

- `auto` 浏览器计算内边距。
- `length` 规定以具体单位计的内边距值，比如像素、厘米等。默认值是 0px。
- `%` 规定基于父元素的宽度的百分比的内边距。
- `inherit` 规定应该从父元素继承内边距。

#### 7.2.padding-top/right/botom/left

[关于 margin/padding 的百分比是基于父级的宽度问题](https://www.zhihu.com/question/20983035/answer/16801491)

`margin/padding` 的百分比之所以按照 width 计算，其实理由很简单，就是要匹配主要的 `use cases`。那就是——要构建在纵横两个方向上相同的 `margin/padding`。如果两个百分比的相对方式不同，那用百分比就无法得到垂直和水平一致的留白。

有人也许会问，为什么不是垂直方向上的 height 而是水平方向的 width？这其实容易理解。因为 CSS 的基本模型是着重于"排版"的需求，因此水平和垂直方向其实并不是同等权重的，更精确的说，是文字书写方向决定的。

常见的横排文字时，我们排版的出发点是水平宽度一定，而垂直方向上是可以无限延展的。竖排文字则相反。所以在竖排文字时，`margin/padding-*` 其实就都按照 height 而不是 width 计算了。

类似的且大家更熟悉的是 `margin-top/bottom` 在垂直方向上的 `collapse`（或者当竖排文字时是 `margin-left/right` 水平方向上的 `collapse`）。为什么只有垂直方向 `collapse` 而水平就不呢？

因为在典型的排版中，段落间的空白进行 `collapse` 是常见和方便的。而反过来水平方向上就几乎没有那样的需求（只有表格在两个方向上有对称的 `border collapse` 的需求）。

同样的，在排版中，横向百分比控制是常见的需求，但是纵向其实很少这样的需求。有这样需求的其实是 GUI 界面布局，布局和排版的区别在这个答案（在 CSS 布局中，用 float 好还是用 position 好？分别有什么优势？）我也提到过。

至于说死循环问题，其实这不是根本原因。大家可以想想 width 为什么就不存在死循环了呢？

BTW，在现代 web 应用中，其实我们有更多的纵向横向布局分割需求，这是传统的百分比不能很好满足的，所以 CSS3 实际上加入了 `vw` 和 `vh` 单位（相对于 viewport 的宽度和长度百分比），这比较好的解决了传统 CSS 中`margin/padding`的百分比所不能满足的那些需求。

`writing-mode`改成`vertical`其实`margin-top`就会按高的百分比了。

### 8.box-sizing

`box-sizing` 属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持 CSS 盒子模型规范的浏览器的行为。

```css
/* 关键字 值 */
box-sizing: content-box;
box-sizing: border-box;

/* 全局 值 */
box-sizing: inherit;
box-sizing: initial;
box-sizing: unset;
```

在 CSS 中，你设置一个元素的 `width` 与 `height` 只会应用到这个元素的内容区。如果这个元素有任何的 `border` 或 `padding` ，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。

`box-sizing` 属性可以被用来调整这些表现:

---

- `content-box` 是默认值，标准盒子模型。如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。

---

- `border-box` 告诉浏览器去理解你设置的边框 `border` 和内边距 `padding` 的值是包含在 `width` 内的。也就是说，如果你将一个元素的 `width` 设为 100px，那么这 100px 会包含其它的 `border` 和 `padding`，内容区的实际宽度会是 `width` 减去 `border` + `padding` 的计算值。大多数情况下这使得我们更容易的去设定一个元素的宽高。内容框不能为负，并且被分配到 0，使得不可能使用 `border-box` 使元素消失。

---

> 常用在移动端(设置宽时) `box-sizing:border-box`

### 9.display

`display` 指定了元素渲染盒子的类型（_type of rendering box_）

元素默认的 `display` 值的情况如下

- block(块级元素)

`<div>、<p> <ul> <ol> <form> ……`

- inline（内联元素）

`<span> <a> <img> <input> <select> <label> ……`

- list-item（项目列表）

`<li>`

- none(不显示)

`<head>（头部元素都是）<title> <br> <thead> <tbody> <tfoot>`

常用的取值：

- `none`: 隐藏元素
- `inline`：行内元素，顾名思义，用于把一个元素放在行的内部
- `block`：块元素，用于显示占用一行的块
- `inline-block`：以 `block` 的方式渲染，以 `inline` 的方式放置
- `table-cell`：以表格元素的方式显示

#### 9.1.隐藏元素

`none` 是最容易理解的取值。当一个元素的 `display` 属性被设为 `none` 时，该元素不会被渲染，也不会占位，就像不存在一样。

一些特殊元素的默认 `display` 值是它，例如 `script` 。 `display: none;` 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。

它和 `visibility` 属性不一样。把 `display` 设置成 `none` 元素不会占据它本来应该显示的空间，但是设置成 `visibility: hidden;` 还会占据空间。

#### 9.2.行内元素

行内（`inline`）元素不会打断文本流。它们的出现不会使得后续元素另起一行。行内元素可以设置 `margin` 与 `padding`，但 `margin` 只在水平方向上起作用。另外，对 `inline` 元素设置 `width` 与 `height` 是不起作用的。

#### 9.3.块元素

块（`block`）元素会中断当前的文本流，另起一行，并在父元素中尽可能地占据最大宽度。通常块元素不可包含在行内元素内部。

#### 9.4.行内块

行内块（`inline-block`）将会产生一个块元素，并以行内元素的方式放置。该元素的样式是以块元素的方式来渲染的，例如可以设置宽和高，然后以行内元素的方式放置在其上下文中，就像在行内元素的位置上替换成这个块元素一样。

行内块还会遇到一个问题，行内块中间没有设置内外边距，但是会自动形成一个小小的白色间隙。这是因为 html 中的换行或空格被浏览器显示了出来。

这个间距这个问题可以通过三种方式解决。

第一种：把 Html 文档写成一行。但是这显然是不现实也不好看的。

第二种：借助 HTML 注释。

```html
<div>box1</div>
<!-- 我是注释
 -->
<div>box2</div>
```

第三种：使用 `letter-spacing: -xpx;`，问题是不好控制间距；

第四种：使用 `font-size: 0;` 基本上可以解决大部分浏览器下 `inline-block` 元素之间的间距(IE7 等浏览器有时候会有 1 像素的间距)。而且 HTML 代码也好看了一些。注意在这种情况下子元素也会继承 `font-size:0` 的属性。所以不要忘记单独给盒子里的文字设置一遍字体属性。

> `inline-block` 与 `inline` 的不同在于：垂直方向上的 `margin` 也会起作用，并且可以设置 `width` 和 `height`。`inline-block` 是非常常用的样式设置。

#### 9.5.表格元素

`display` 设为 `table-cell` 的元素与 `<td>` 标签的行为一致，即：可设置 `padding`，不接受 `margin`，可伸缩的 `width`。利用 `table-cell` 属性可以在不写 `<table>` 标签的情况下完成表格布局。

### 10.overflow

指定当内容溢出其块级容器时，是否剪辑内容，显示滚动条或显示溢出的内容。

```css
/* 默认值。内容不会被修剪，会呈现在元素框之外 */
overflow: visible;

/* 内容会被修剪，并且其余内容不可见 */
overflow: hidden;

/* 内容会被修剪，浏览器会显示滚动条以便查看其余内容 */
overflow: scroll;

/* 由浏览器定夺，如果内容被修剪，就会显示滚动条 */
overflow: auto;

/* 规定从父元素继承overflow属性的值 */
overflow: inherit;
```

使用 `overflow` 默认值（`visible`）以外的值将创建一个新的 块级格式化上下文。这在技术层面上是必须的——如果一个浮动元素和滚动条相交，它会强制（重新）包围内容元素。这种行为（重新包围内容元素）会在每一次移动滚动条之后发生，会使得滚动体验变差（慢）。

为使 `overflow` 有效果，块级容器必须有一个指定的高度（`height` 或者 `max-height`）或者将 `white-space` 设置为 `nowrap`。

> 注意: 当相关 HTML 元素被设置为 `scrollTop` 时，即使 `overflow` 值为 `hidden`，这个元素依旧会滚动`。

### 11.float

[浮动出现的意义其实只是用来让文字环绕图片而已，仅此而已。](http://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%B8%80/)

指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动中移除，尽管仍然保持部分的流动性（与绝对定位相反）。

#### 11.1. 浮动的"包裹性"

先说句您应该没有见过的结论：撇开浮动的"破坏性"，浮动就是个带有方位的 `display:inline-block` 属性。

`display:inline-block` 某种意义上的作用就是包裹(wrap)，而浮动也有类似的效果。举个常见例子，或许您有实现宽度自适应按钮的经验，实现宽度自适应的关键就是要让按钮的大小自适应于文字的个数，这就需要按钮要自动包裹在文字的外面。我们用什么方法实现呢？一就是 `display:inline-block`；二就是 `float`。

然而，`float` 无法等同于 `display:inline-block`，其中原因之一就是浮动的方向性，`display:inline-block` 仅仅一个水平排列方向，就是从左往右，而 `float` 可以从右往左排列，这就是两者的差异。

#### 11.2. 浮动的"破坏性"

浮动可以说是所有 CSS 属性中的"破坏之王"。要理解浮动的破坏性，我们要从浮动最原始的意义入手。

所以，只要您弄明白了为什么文字会环绕含浮动属性的图片，您就会知道我所说的浮动的"破坏性"是什么意思了。

先说结论：文字之所以会环绕含有 `float` 属性的图片，是因为浮动破坏了正常的 `line boxes`。

**`line boxes` 模型**: `inline boxes` 不会让内容成块显示，而是排成一行，如果外部含 `inline` 属性的标签(`<span>， <a>， <cite>` 等)，则属于 `inline boxes`，如果是个光秃秃的文字，则属于匿名 `inline boxes`。`line boxes` 的高度是由其内部最高的 `inline boxes` 的高度决定的

`content area` 是一种围绕文字看不见的 box。`content area` 的大小与 `font-size` 大小相关。

默认情况下，图片与文字基线对齐，图片与文字在同一行上；一张图片只能与一行文字对齐。而要想让一张图片要与多行文字对齐，您唯一能做的就是破坏正常的 `line boxes` 模型。

正常情况下，图片自身就是个 `inline boxes`，与两侧的文字 `inline boxes` 共同组成了 `line boxes`，但是，一旦图片加入了浮动，情况就完全变了。我认为是浮动彻底破坏了 `img` 图片的 `inline boxes` 特性，至少有一点我可以肯定，图片的 `inline boxes` 不存在了。一旦图片失去了 `inline boxes` 特性就无法与 `inline boxes` 的文字排在一行了，其会从 `line boxes` 上脱离出来，跟随自身的方位属性，靠边排列。

这个从 `line boxes` 上脱离的浮动元素其实就是一个躯体，一个空壳子，表象。因为其没有 `inline boxes`。有人可能会问，没有 `inline boxes` 就没有呗，有什么大不了的？非也非也！这个 `inline boxes` 很个很重要的概念。

在目前的 CSS 的世界中，所有的高度都是有两个 CSS 模型产生的，一个是 **box 盒状模型**，对应 CSS 为 "`height + padding + margin`"，另外一个是**line box 模型**，对应样式为 "`line-height`"。

前者的 `height` 属性分为明显的 `height` 值和隐藏的 `height` 值，所谓隐藏的 `height` 值是指图片的高度，一旦载入一张图片，其内在的 `height` 值就会起作用，即使您看不到 `"height"` 这个词。

而后者针对于文字等这类 `inline boxes` 的元素（图片也属于 `inline boxes`，但其 `height` 比 `line-height` 作用更凶猛，故其 `inline boxes` 高度等于其自身高度，对 `line-height` 无反应），`inline boxes` 的高度直接受 `line-height` 控制（改变`line-height` 文字拉开或重叠就是这个原因），而真正的高度表现则是由每行众多的 `inline boxes` 组成的 `line boxes`（等于内部最高的 `inline box` 的高度），而这些 `line boxes` 的高度垂直堆叠形成了 `containing box` 的高度，也就是我们见到的 `<div>` 或是 `<p>` 标签之类的高度了。

所以，对于 `line box` 模型的元素而言，没有 `inline boxes`，就没有高度了，而浮动却恰恰做了这么龌龊的事情，其直接将元素的 `inline boxes` 也破坏了，于是这些元素也就没有了高度。

浮动破坏了图片的 `inline box`，产生了两个结果：一是图片无法与文字同行显示，脱离了其原来所在的 `line box` 链；二是没有了高度（无 `inline box` -> 无 `line box` -> 无高度）。而这些结果恰恰是文字环绕图片显示所必须的。

我们可以拿浮动元素与绝对定位元素做对比或许可以帮助理解。与浮动元素一样，绝对定位元素也具有"包裹性"，此"包裹性"适用于任何元素。那么，浮动元素与绝对定位元素的差别在哪里呢？我觉得最主要的差别在于：绝对定位的元素脱离了文档流，而浮动元素依旧在文档流中；而这造成的显示上的差异就是：同处于文档流中的文字实体不会与浮动元素重叠，而会与绝对定位元素重叠。这就是文字环绕显示的重要原因之一：虽然图片实际占据的高度为 0，但是由于其宽度实体存在（包裹性），同样是 `content area` 实体的文字不会与之重叠（外部的容器盒子 `containing box`(`<p>， <div>， <li>`)会重叠），这就好比篮球场上站了个植物人，虽然其几乎不可能得分，运球之类，但是他的实体在那里，它可以阻挡同一水平空间上的同一类型的个体（即人）直接穿过去，要通过，得绕道。但是其无法阻挡整个球队的向前推进。

`display:inline-block` 将对象呈递为内联对象，但是对象的内容作为块对象呈递。所谓对象呈递为内联对象就是元素呈递为 `inline box`，所以浮动"包裹性"所产生的结果就是使得元素转为了 `line box` 模型中的 `inline box` 元素。浮动的"包裹性"让元素变成类似于 `inline box` 的元素，而浮动的"破坏性"正是破坏 `inline box` 元素的。对于 `block` 水平的这类块状元素需要先让其变成类似效果的内联元素，然后再破坏之。

> 注意：
> IE 浏览器：`obj.style.styleFloat = "left";`
> 其他浏览器：`obj.style.cssFloat = "left";`

#### 11.3.浮动的原理

浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（"**高度塌陷**"现象）。

```css
/* Keyword values */
float: left;
float: right;
float: none;

/* Global values */
float: inherit;
float: initial;
float: unset;
```

> 由于 `float` 意味着使用块布局，它在某些情况下修改 `display` 值的计算值。

- 特点：
  - 脱离文档流(父级元素找不到子级元素)，相当于来到了第二层级，平行于基本的文档流
  - 所有元素可以设置这个属性
  - 将元素的 `display` 属性由 `inline` 或 `inline-block` 改为 `block`
  - 浮动元素不设置宽高时，宽高是由内容决定的
  - 行内元素、行内块级元素和文字会围绕着浮动元素排布

#### 11.4.清除浮动(clearfix hack)

- 1.给父级元素设置高度

  - 这个元素内是否有内容，高度都一定

- 2.给父级元素设置 `overflow: hidden;` 属性(IE6 中还需要 `zoom:1;`)

> 此方法不存在结构化和语义问题并且代码量也少，但是内容增多时不会自动换行导致内容被隐藏，无法显示需要溢出的元素；要是里面的元素要是想来个 `margin` 负值定位或是负的绝对定位，直接被裁掉了。

- 3.父元素设置 `overflow:auto;` (IE6 需要触发 hasLayout)

> 但是多个嵌套后，firefox 某些情况会造成内容全选；IE 中 `mouseover` 造成宽度改变时会出现最外层模块有滚动条等，firefox 早期版本会无故产生 `focus` 等；
> 如果有隐藏 box，会因为将隐藏 box 的高度加入，使得总体高度增加，影响布局（2017.08.09，）

- 4.给最后一个浮动元素之后加(从语义化的角度来看是不合理的)

`<div style="clear:both"></div>`

> 增加浏览器渲染负担。

然而这个方法只是在同一块级格式化上下文（`block formatting context`）中没有其他元素的时候才是有效的。

如果不能使用清除浮动，另一种做法是浮动容器的限制块级格式化上下文。即将其中一个非浮动元素的 `overflow` 属性值变成 `hidden` 或者 `auto`，因为这样可以让容器元素伸展到能够包含浮动元素，而不是让他们超出块元素的底部。？？？

> 设置 `overflow` 为 `scroll` 也可以让块元素撑大来包含所有的浮动子元素，但是这样不论内容有多少都会显示出一个滚动条。即使 `height` 默认值为 `auto`，我们还是设置了，是为了表明容器应该增大高度以便包裹住里面的内容。

- 5.`clear:both;` 清除浮动

  - 使用这个属性的元素必须是块级元素
  - 使用这个属性的元素必须放在最后一个浮动元素之后
  - 使用这个属性的元素不能带有 `float` 属性

- 6.父元素设置 `display:table`

结构语义化完全正确，代码量极少但是盒模型属性已经改变，由此造成的一系列问题，得不偿失，不推荐使用

> 注意：`display:table` 本身无法触发 BFC，但是它会产生匿名框(anonymous boxes)，而匿名框中的 `display:table-cell` 可以触发 BFC，简单说就是，触发块级格式化上下文的是匿名框，而不是 `display:table`。所以通过 `display:table` 和 `display:table-cell` 创建的 BFC 效果是不一样的。

- 7.使用伪元素

```css
.clearfix:after{
  display: block;
  content: "";
  clear: both;
}
.clearfix{
  *zoom:1; 兼容低版本浏览器
  css hack
}
```

### 12.position

#### 12.1.static

`static` 是默认值。任意 `position:static;` 的元素不会被特殊的定位。一个 `static` 元素表示它不会被"`positioned`"，一个 `position` 属性被设置为其他值的元素表示它会被 "`positioned`"。

#### 12.2.relative

---

- 不脱离文档流
- 发生位置改变的时候，原来的位置还占用
- 层级大于文档流其他元素(会盖在其他元素之上)
- 参照物是本身
- 给绝对定位当参照物 ---**常用**
- `position: relative;` 相对定位，同时设置 `top` 和 `bottom` 的值，`top` 生效。同时设置 `right` 和 `left` 的值，`left` 生效

---

> 当盒子本身发生改变时，不影响其他元素，这时候我们用相对定位

#### 12.3.absolute

---

- 脱离文档流，但不在同一个平面上，因此不会相互识别，反而会相互覆盖；
- 所有元素默认都会去找参照物的起点位置（参照物的左上角）
- 不设置参照物时，参照物是 ICB（inital container block， 初始包含块）([`body` 这种说法不严谨](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position))
- 人为设置参照物
  - 只能是这个绝对定位元素的父级（或以上）元素
  - 参照物必须带有定位属性的元素(相对、绝对、固定)
- 绝对定位元素有宽高的时候，`top` 和 `bottom` 的值同时设置，`top` 生效。`left` 和 `right` 的值同时设置，`left` 生效
- 在不设置宽高时，宽度和高度是由本身内容决定的
- 绝对定位元素，如果不设置四个方向的值，并且同级之前有其他内容(元素)，它会默认排到这个内容(元素)之后（绝对定位的元素脱离文档流以后，只会影响后面的元素，而不会影响前面的元素，所以当没有设定绝对定位元素的定位值时，绝对定位元素会默认从前面元素之后的左上角开始排布；）
- 绝对定位元素设置宽高为 100%，继承参照物的宽高

---

> 父级（或以上）元素都有定位属性，绝对定位的参照物是离它最近的那个父级元素

#### 12.4.fixed

---

- 脱离文档流
- 参照物是浏览器的可视窗口
- 在不设置宽高时，宽高是由内容决定
- 多用在页面中的辅助导航、回到顶部等位置
- 可以作为绝对定位的参照物；

---

#### 12.5.float 和 position 的区别

> 作者：贺师俊
> 链接：`https://www.zhihu.com/question/19588854/answer/13243044`
> 来源：知乎

在绝大多数 Web 开发者的语境中，"布局"这个术语和"排版"是有差异的。"布局"偏向于指宏观的 GUI 区域划分，比如双栏布局或三栏布局等。从这一点出发，`float` 其实本不是一项用于"布局"的属性。

`float` 对应的其实是传统印刷排版中图文混排中的环绕。这其实可以理解，因为 CSS 的模型和术语脱胎于传统排版，故而与计算机 GUI 技术通常基于组件的模型相差甚远。除了 `float` 之外，另一个例子是 CSS 中上下 `margin` 的 `collapse`，显然这是为了满足段落排版的需求。所以像 `float、margin collapse` 等，在典型的 GUI 技术中是没有的。还有，CSS box model 中，`width/height` 不算入 `padding` 和 `border`，许多开发者对这点很不适应，这实际上是 GUI 的控件思维与 CSS 排版思维的冲突。这个冲突在浏览器技术实现上的遗迹就是 IE 臭名昭著的 "`hasLayout`"。

元素 "`has layout`" 的真实意思是这样的元素直接对应一个控件。也正是由于 IE 很 naive 的在实现中直接结合了这两种矛盾的模型，从而导致了无数的布局 bug。

言归正传，CSS1 时代的网页还很简陋，但是随着万维网的迅猛发展，Web 界面也迅速进化，当初简单的如同书页般的通栏式网页迅速绝迹，`frameset` 由于天生存在的一堆问题也很快退出主流，这时 CSS 在 GUI 布局方面就显出了缺陷，开发者被迫使用各种 `trick`。比如历史悠久的 `table` 布局。后来 `table` 布局被鄙视，开发者逐渐转向了 `float` 布局。

要说 `float` 布局之所以流行，IE "功"不可没。在 IE 中，`has layout` 的元素是不会环绕 `float` 元素的（因为 `has layout` 的元素自己是一个控件，所以总是保持一个矩形区域）。这本来是一个 bug，但是其效果却正好符合常见的双栏布局的需要。另外 IE 下 `float` 元素会自动撑开其父级 `container` 元素（当然前提是 `container` 元素也是 `has layout` 的），这其实也是 bug，但是也恰好符合模块布局的需求。后来所谓`inline-block` 布局其实正是这些 bug 的合理化。

站在今天回望过去十多年的 CSS 实践，我们可以发现，无论 `float` 布局还是后来的 `inline-block` 布局，其实都是 `trick`。所谓 **`trick`**，就是将一些特性挪作他用，以很曲折的方式实现出想要的效果。

CSS 作为样式语言，其可维护性的最终来源，就是代码能清晰的表达出设计意图。而 CSS trick 当然不能很好的满足这一点。那么如何才能真正用 CSS 来表达布局？这有赖于 "CSS3 的进化"。如 `multiple column`、`flex box`、`grid layout` 等。其中直接对应目前 `float` 布局/`inline-block` 布局所要达到效果的，是 `flex box`。当然，考虑到兼容性问题（IE9 仍不支持 flex box 模块，IE10 才支持），我们可能很长时间内还是会继续使用 `float` 布局，不过必须始终牢记这是 `trick`，是 `workaround`。如有可能，最好引入 SCSS/LESS 之类的 CS S 框架来对此种布局 `trick` 做进一步抽象和解耦。

再说 `position` 布局。`position` 其实比 `float` 要更接近"布局"属性。但是 `position` 的问题是，所谓布局是设定各区域（元素）的关联和约束，而定位只是设定单一元素的位置大小。要实现一个布局，要对多个定位元素中手动设定相关的参数（如左栏 `width:200px`，右栏 `left:200px`），相当于人为的把大小和位置参数计算出来。这违背了 DRY 原则，也无法真正实现关联约束。（如左栏设了 `max/min-width` 之后，最终实际 `width` 未必是 200px，此时右栏怎么设 `left` 值？又如一个水平固定 `width`、垂直自适应 `height` 的绝对定位元素，我们如何从它的底部继续排下一个元素？）除非我们引入 JavaScript 脚本来进行计算。因此运用 `position` 布局的限制条件相当多，通常只适合那些相对孤立的部件（如页头页脚）或较为简单且各区域大小位置固定的布局。至于说以 JavaScript 实现的布局管理器，是将 `position` 作为实现布局的底层技术，已经算不得 CSS 了（因为你也不写 CSS）。

## 六.CSS 布局（layout）

- 固定布局：宽高写死； `float+position` — 最常用在 PC 上
- 流式布局(百分比布局) + 媒体查询 + px 单位 —最常用在 PC 端和移动端公用一套页面结构
- 流式布局(百分比布局) + 媒体查询 + rem 单位 最常用移动端上 h5 页面上
- flexbox 弹性盒模型

### 1.百分比布局

百分比布局，也叫流式布局，因为宽度是百分比，但是高度是按 px 来写的。

百分比是一种相对于包含块的计量单位，它对图片很有用，甚至还能同时使用 `min-width` 和 `max-width` 来限制图片的最大或最小宽度！

当布局很窄时， 固定定位的导航栏就会被挤扁。更糟糕的是，你不能在 `nav` 上使用 `min-width` 来修复这个问题，因为右边的那列是不会遵守它的。

适用页面特点：左侧固定 + 右侧自适应/左右固定宽度 + 中间自适应

开发思路：
自适应意味着百分比（0% - 100%) -> 思考：如何确定是不是自适应？

- 多列等分 -> 百分比等分

---

- 左侧固定宽度 + 右侧自适应宽度
  - 思路一 -> 左侧左浮动+右侧利用 BFC 特性在右侧
  - 思路二 -> 父级给`padding-left`，预留出来左侧区域的宽度，左侧用绝对定位上去，右侧用百分百宽度

---

- 左侧自适应 + 右侧固定宽度
  - 思路一 -> 左侧用百分百宽度，右侧用绝对定位上去

---

- 左右固定宽度 + 中间自适应
  - 思路一 -> 左侧左浮动 + 中间百分之百（中间部分再分为左侧百分之百+右侧右浮动）
  - 思路二 -> 左侧左浮动 + 中间百分之百 + 右侧右浮动（负 `margin` 法减掉左右侧）
  - 思路三 -> 左右绝对定位 + 中间百分之百（父元素 `padding-left`，`padding-right` 预留左右侧的位置）

---

- 左中右全自适应 -> 全部用百分比

- `font-size、padding，margin，height` 直接量像素

- 小的地方可以用 `display:inline-block;` 让几个容器放在一排

- 小图标之类的，可以考虑用 `::before，::after` 来实现

### 2.媒体查询

"响应式设计（Responsive Design)" 是一种让网站针对不同的浏览器和设备"呈现"不同显示效果的策略，这样可以让网站在任何情况下显示的很棒！

媒体查询是做此事所需的最强大的工具。使用 `meta viewport` 之后可以让你的布局在移动浏览器上显示的更好。

```css
@media (min-width: 375px) {
  .box {
    width: 200px;
    height: 200px;
    background: #000;
    border: 10px solid #73cf17;
  }
}
```

x < 375 `max-width` 最大宽度 375 小于等于 375
x > 375 `min-width` 最小宽度 375 大于等于 375

> 注意点:单词之间空格隔开

1.`@media` 媒体 媒介

2.媒体类型
all 所有类型
screen 设备类型
print 打印类型

3.连接符
`and` 和

4.判断条件 `()`

5.`{ css 样式代码 }`

### 3.rem 布局分析

`rem = root element` 根元素
rem(font size of root element) 根元素(html)的字体大小
`1rem = 16px` （谷歌 html 默认的字体大小是 16px）。

```css
html{
  font-size:100px;
  /!*设置100px 原因:1.减少和设计稿的偏差 2.方便计算*!/
  /!*1rem:100px;*!/
}

/*
设计稿的尺寸   分辨率          1rem = 100px
  640         320            100px
              375            117.1875px
              414            129.375px
              640            200px
*/

media screen and (min-width: 320px){
  /*320分辨率 以iphone5参考 做的设计稿*/
  html{
    font-size:100px;
  }
}
```

### 4.inline-block 布局

使用 `inline-block` 来布局。有一些事情需要你牢记：

- `vertical-align` 属性会影响到 `inline-block` 元素，你可能会把它的值设置为 `top` 。
- 你需要设置每一列的宽度
- 如果 HTML 源代码中元素之间有空格，那么列与列之间会产生空隙

### 5.colum

可以帮助你很轻松的实现文字的多列布局。CSS columns 是很新的标准，所以你需要使用前缀，并且它不被 IE9 及以下和 Opera Mini 支持。

```css
.three-column {
  padding: 1em;
  -moz-column-count: 3;
  -moz-column-gap: 1em;
  -webkit-column-count: 3;
  -webkit-column-gap: 1em;
  column-count: 3;
  column-gap: 1em;
}
```

### 6.Flex 布局

> If you are looking at a blog post (or whatever) about Flexbox and you see `display: box;` or a property that is box-{_}， you are looking at the old 2009 version of Flexbox.
> If you are looking at a blog post (or whatever) about Flexbox and you see `display: flexbox;` or the flex() function， you are looking at an awkward tweener phase in 2011.
> If you are looking at a blog post (or whatever) about Flexbox and you see `display: flex;` and flex-{_} properties， you are looking at the current (as of this writing) specification.

网页布局是 CSS 的一个重点应用。布局的传统解决方案，基于盒状模型，依赖 `display` 属性 + `position` 属性 + `float` 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。

2009 年，W3C 提出了一种新的方案 ---- Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。

