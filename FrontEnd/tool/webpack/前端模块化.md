# 前端模块化

## 1.'module?'

最早我们这么写代码：

```js
function foo() {
  // ...
}
function bar() {
  // ...
}
```

Global 被污染，很容易命名冲突。

简单封装：**Namespace 模式**

```js
var MYAPP = {
  foo: function() {},
  bar: function() {}
}

MYAPP.foo()
```

- 优缺点：
  >
  - 减少 Global 上的变量数目
    >
  - 本质是对象，一点都不安全

匿名闭包 ：**IIFE 模式**

```js
var Module = (function() {
  var _private = 'safe now'
  var foo = function() {
    console.log(_private)
  }

  return {
    foo: foo
  }
})()

Module.foo()
Module._private // undefined
```

再增强一点 ：引入依赖

```js
var Module = (function($) {
  var _$body = $('body') // we can use jQuery now!
  var foo = function() {
    console.log(_$body) // 特权方法
  }

  // Revelation Pattern
  return {
    foo: foo
  }
})(jQuery)

Module.foo()
```

> 这就是模块模式，也是现代模块实现的基石

## 2.script loader

只有封装性可不够，我们还需要加载

你以为是这样的：

```shell
body
  script((src = 'jquery.js'))
  script((src = 'app.js')) # do some $ things...
```

但现实是这样的：

```shell
body
    script(src="zepto.js")
    script(src="jhash.js")
    script(src="fastClick.js")
    script(src="iScroll.js")
    script(src="underscore.js")
    script(src="handlebar.js")
    script(src="datacenter.js")
    script(src="deferred.js")
    script(src="util/wxbridge.js")
    script(src="util/login.js")
    script(src="util/base.js")
    script(src="util/city.js")
    script(src="util/date.js")
    script(src="util/cookie.js")
    script(src="app.js")
```

- 难以维护 Very difficult to maintain!
  >
- 依赖模糊 Unclear Dependencies
  >
- 请求过多 Too much HTTP calls

**LABjs - Script Loader**(2009)

> Using LABjs will replace all that ugly "script tag soup"

`script(src="LAB.js" async)`

```shell
$LAB.script("framework.js").wait()
    .script("plugin.framework.js")
    .script("myplugin.framework.js").wait()
    .script("init.js");
```

Executed in parallel? First-come, First-served (when execution order is not important)

Sugar(语法糖)

```shell
$LAB
.script( [ "script1.js", "script2.js", "script3.js"] )
.wait(function(){ // wait for all scripts to execute first
    script1Func();
    script2Func();
    script3Func();
});
```

> 基于文件的依赖管理

## 3.module loader

模块化架构的工业革命

**YUI3 Loader - Module Loader**(2009)

> YUI's lightweight core and modular architecture make it scalable, fast, and robust.

```js
// YUI - 编写模块
YUI.add('dom', function(Y) {
  Y.DOM = { ... }
})

// YUI - 使用模块
YUI().use('dom', function(Y) {
  Y.DOM.doSomeThing();
  // use some methods DOM attach to Y
})
```

Creating Custom Modules:

```js
// hello.js
YUI.add(
  'hello',
  function(Y) {
    Y.sayHello = function(msg) {
      Y.DOM.set(el, 'innerHTML', 'Hello!')
    }
  },
  '3.0.0',
  {
    requires: ['dom']
  }
)

// main.js
YUI().use('hello', function(Y) {
  Y.sayHello('hey yui loader')
})
```

> 基于模块的依赖管理

Let's Go A Little Deeper：

```js
// Sandbox Implementation
function Sandbox() {
  // ...
  // initialize the required modules
  for (i = 0; i < modules.length; i += 1) {
    Sandbox.modules[modules[i]](this)
  }
  // ...
}
```

Y 其实是一个强沙箱，所有依赖模块通过 attach 的方式被注入沙盒；attach：在当前 YUI 实例上执行模块的初始化代码，使得模块在当前实例上可用。

Still "Script Tag Soup"?

```shell
script(src="/path/to/yui-min.js")       # YUI seed
script(src="/path/to/my/module1.js")    # add('module1')
script(src="/path/to/my/module2.js")    # add('module2')
script(src="/path/to/my/module3.js")    # add('module3')
```

```js
YUI().use('module1', 'module2', 'module3', function(Y) {
  // you can use all this module now
})
```

- you don't have to include script tags in a set order
  >
- separation of loading from execution
  >
- Too much HTTP calls

**YUI Combo**

Serves multiple files in a single request

```shell
script(src="http://yui.yahooapis.com/3.0.0/build/yui/yui-min.js")
script(src="http://yui.yahooapis.com/3.0.0/build/dom/dom-min.js")

# magic combo
script(src="http://yui.yahooapis.com/combo?
    3.0.0/build/yui/yui-min.js&
    3.0.0/build/dom/dom-min.js")
```

## 4.commonjs

**CommonJS - API Standard**(2009.08)

> javascript: not just for browsers any more!

MODULES/1.0

```js
// math.js
exports.add = function(a, b) {
  return a + b
}

// main.js
var math = require('math') // ./math in node
console.log(math.add(1, 2)) // 3
```

NodeJS : Simple HTTP Server:

```js
// server.js
var http = require('http'),
  PORT = 8000

http
  .createServer(function(req, res) {
    res.end('Hello World')
  })
  .listen(PORT)

console.log('listenning to ' + PORT)
```

同步/阻塞式加载:

```js
// timeout.js
var EXE_TIME = 2

;(function(second) {
  var start = +new Date()
  while (start + second * 1000 > new Date()) {}
})(EXE_TIME)

console.log('2000ms executed')
```

```js
// main.js
require('./timeout') // sync load
console.log('done!')
```

同步加载对服务器/本地环境并不是问题，浏览器环境才是问题！

## 5.AMD/CMD

浏览器环境模块化方案

- **AMD**(Async Module Definition)
  >
  - RequireJS 对模块定义的规范化产出
    >
- **CMD**(Common Module Definition)
  >
  - SeaJS 对模块定义的规范化产出

**RequireJS - AMD Implementation**(2011)

> JavaScript file and module loader.It is optimized for in-browser use.

If require() is async?

```js
//CommonJS Syntax
var Employee = require('types/Employee')

function Programmer() {
  //do something
}

Programmer.prototype = new Employee()

//如果 require call 是异步的，那么肯定 error
//因为在执行这句前 Employee 模块根本来不及加载进来
```

Function Wrapping:

```js
//AMD Wrapper
define(['types/Employee'], function(Employee) {
  //依赖
  //这个回调会在所有依赖都被加载后才执行
  function Programmer() {
    //do something
  }

  Programmer.prototype = new Employee()
  return Programmer //return Constructor
})
```

Sugar - simplified CommonJS wrapping

```js
define(function(require) {
  var dependency1 = require('dependency1'),
    dependency2 = require('dependency2')

  return function() {}
})
```

```js
// parse out require...
define(['require', 'dependency1', 'dependency2'], function(require) {
  var dependency1 = require('dependency1'),
    dependency2 = require('dependency2')

  return function() {}
})
```

**AMD vs CommonJS**

- 书写风格

```js
// Module/1.0
var a = require('./a') // 依赖就近
a.doSomething()

var b = require('./b')
b.doSomething()

// AMD recommended style
define(['a', 'b'], function(a, b) {
  // 依赖前置
  a.doSomething()
  b.doSomething()
})
```

- 执行时机

```js
// Module/1.0
var a = require('./a') // 执行到此时，a.js 同步下载并执行

// AMD with CommonJS sugar
define(['require'], function(require) {
  // 在这里， a.js 已经下载并且执行好了
  var a = require('./a')
})
```

> Early Download, Early Executing

**SeaJS - CMD Implementation**(2011)

> Extremely simple experience of modular development

```js
define(function(require, exports) {
  var a = require('./a')
  a.doSomething()

  exports.foo = 'bar'
  exports.doSomething = function() {}
})
```

```js
// RequireJS 兼容风格
define('hello', ['jquery'], function(require, exports, module) {
  return {
    foo: 'bar',
    doSomething: function() {}
  }
})
```

**AMD vs CMD**

- Still Execution Time

```js
// AMD recommended
define(['a', 'b'], function(a, b) {
  a.doSomething() // 依赖前置，提前执行
  b.doSomething()
})

// CMD recommanded
define(function(require, exports, module) {
  var a = require('a')
  a.doSomething()
  var b = require('b')
  b.doSomething() // 依赖就近，延迟执行
})
```

## 6.browserify/webpack

**npm**

> Browsers don't have the require method defined, but Node.js does.

### 6.1.Browserify - CommonJS In Browser(2011 / 2014 stable)

> require('modules') in the browser by bundling up all of your dependencies

install:

`$ npm install -g browserify`

Actually You Need Do Nothing But Write CommonJS Code!

```shell
# magic just happened!
$ browserify main.js -o bundle.js
```

Browserify parses the AST for require() calls to traverse the entire dependency graph of your project.

**Watchify**

auto-recompile.

`$ npm install -g watchify`

```shell
# WATCH!
$ watchify app.js -o bundle.js -v
```

Build 后要如何 Debug

**Source Map**

```shell
# debug mode
$ browserify main.js -o bundle.js --debug
```

Npm Run

```json
// package.json
{
  //....
  "scripts": {
    "build": "browserify app.js -o bundle.js",
    "watch": "watchify app.js -o bundle.js -v"
  }
}
```

### 6.2.Webpack - Module Bundler(2014)

> transforming, bundling, or packaging just about any resource or asset

Webpack For Browserify Users

```shell
# These are equivalent:
$ browserify main.js > bundle.js
$ webpack main.js bundle.js
```

```js
// better with a webpack.config.js
module.exports = {
    entry: "./main.js",
    output: {
        filename: "bundle.js"
    }
}
```

Simple CLI

```shell
# make sure your directory contains webpack.config.js

# Development: debug + devtool + source-map + pathinfo
webpack main.js bundle.js -d

# Production: minimize + occurence-order
webpack main.js bundle.js -p

# Watch Mode
webpack main.js bundle.js --watch
```

**Browserify vs Webpack**

小而美 VS 大而全

[Browserify VS Webpack - JS Drama](http://blog.namangoel.com/browserify-vs-webpack-js-drama)

[browserify for webpack users](https://gist.github.com/substack/68f8d502be42d5cd4942)

## 7.ES6 module

**Babel - JavaScript Compiler**(2015)

> Use next generation JavaScript, today.

Single Default Module

```js
// math.js
export default math = {
    PI: 3.14,
    foo: function(){}
}
```

```js
// app.js
import math from "./math";
math.PI
```

```shell
# babel magic!
$ babel-node app.js
```

Named Exports

```js
// export Declaration
export function foo(){
    console.log('I am not bar.');
}

// export VariableStatement;
export var PI = 3.14;
export var bar = foo;   // function expression

// export { ExportsList }
var PI = 3.14;
var foo = function(){};

export { PI, foo };
```

Importing Named Exports

```js
// import { ImportsList } from "module-name"
import { PI } from "./math";
import { PI, foo } from "module-name";

// import IdentifierName as ImportedBinding
import { foo as bar } from "./math";
bar();  // use alias bar

// import NameSpaceImport
import * as math from "./math";
math.PI
math.foo()
```

babel + browserify = babelify
babel + webpack = babel-loader

参考：

1.[JavaScript Modularization Journey](http://huangxuan.me/js-module-7day/#/)

2.[前端模块化开发那点历史](https://github.com/seajs/seajs/issues/588)

3.[浅谈前端模块化](https://imweb.io/topic/55994b358555272639cb031b)
