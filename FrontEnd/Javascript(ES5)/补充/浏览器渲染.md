# 图解浏览器渲染过程

原文：[图解浏览器渲染过程 - 基于 Webkit/Blink 内核 Chrome 浏览器](https://github.com/abcrun/abcrun.github.com/issues/17)

Chrome 基于 Webkit 内核进行封装，采用了多进程/线程模型。当用户访问网页时，大致的流程是这样的：

打开浏览器，Browser 进程启动，首先由 UI 线程来处理界面基本信息(如创建 tab 页等)；

当用户输入 URL 后，UI 线程将任务交给 IO 线程来处理，然后将结果传递给 Render 进程；

Render 进程的 IO 线程经过简单分析后，将解释后的结果交给渲染线程；

渲染线程接受请求加载网页并渲染网页；

在加载和渲染过程中，可能会需要 Browser 进程获取相关的资源(如果 CSS 文件，图片，音频视频等)和 GPU 进程帮助渲染，这时 Render 进程会通过 IO 线程通知 Browser 进程或者 GPU 进程进行相关的任务。

## 1.Chrome 浏览器多进程/线程模型

Chrome 浏览器包含多个进程，其中 Browser 进程是主进程，管理着各个 Tab 页，UI 操作，资源请求等；Render 进程主要用于渲染网页，Render 进程可以包含多个；GPU 进程用于处理渲染硬件加速；而 NPAPI 和 Pepper 进程与浏览器插件相关。

#### 2.资源请求与加载过程

当用户访问某一地址时，可以分为两种情况：

- 1.根据是否有本地缓存(本地缓存是否需要更新)来请求网络资源
- 2.当点击前进/后退按钮时，从浏览器缓存池里面判断是否有缓存资源，如果没有则需要网络请求

页面资源有好多种，每种资源都有对应的资源加载器，如图片资源加载器 imageLoader，在解析过程中当需要加载资源时，render 进程会通知 Browser 进程加载资源，然后将加载后的资源通知给 render 进程。关于渲染过程见下图。

#### 3.渲染过程

由于渲染的内容比较多，图片也比较大，为了便于阅读，我将图片分成三部分展示，最后也会附上渲染过程的全图。

##### 3.1 HTMLParser -> DOM

首先是 HTMLParser 创建 DOM 树的过程，Render 进程会创建一个 html 解释线程用于分析经过浏览器转码后的字符串，经过词法分析，安全处理等；

然后调用主进程构建 DOM 树。当解释后是 Script 脚本时将会阻塞渲染线程,调用 Javascript 线程执行脚本代码，当然此时 chrome 为防止阻塞影响到后面可能存在的资源加载，会与扫描后面的代码是否有需要加载资源的，

- 如果有则交个 Browser 进程去加载资源，然后才执行 Script 代码；
- 如果遇到 CSS 样式代码时，将会对 CSS 样式规则进行解析保存到 DocumentRuleSets 对象中备用，便于创建 Node 节点时构建 RenderObject 和 RenderLayer 使用。

##### 3.2 RenderObject

上面谈到的保存的样式规则对象(DocumentRuleSets)，在创建 DOM 树 Node 节点元素后，Element 会依次调用 attach 函数检测是否需要创建 RenderObject 对象，RenderObject 对象从 DocumentRuleSets 里查找当前元素匹配的所有样式规则并排序，计算出当前节点的位置等最终的样式信息保存在 RenderObject 对象中。

##### 3.3 RenderLayer 与渲染绘制

网页本身包含框结构和层次结构，框结构主要是指 iframe，而层次结构就是这里说的 renderLayer 了，网页分成不同的层次主要是出于渲染考虑的，图中有详细说明。

### 浏览器渲染原理及流程

#### 1.浏览器主要组件结构

---

1.用户界面：包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。

2.浏览器引擎：在用户界面和呈现引擎之间传送指令。

3.呈现/(渲染)引擎：负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。

4.网络：用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。

5.用户界面后端：用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。

6.JavaScript 解释器：用于解析和执行 JavaScript 代码。

7.数据存储：这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。

---

#### 2.渲染主流程

渲染引擎首先通过网络获得所请求文档的内容，通常以 8K 分块的方式完成。下面是渲染引擎在取得内容之后的基本流程：

> 需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。

上图是 Chrome/webkit 的渲染过程。

上图是 Firefox/Gecko 的渲染过程。

Gecko 里把格式化好的可视元素称做“帧树”（Frame tree）。每个元素就是一个帧（frame）。 webkit 则使用”渲染树”这个术语，渲染树由”渲染对象”组成。

webkit 里使用 ”layout” 表示元素的布局，Gecko 则称为 ”reflow”。Webkit 使用 ”Attachment” 来连接 DOM 节点与可视化信息以构建渲染树。

一个非语义上的小差别是 Gecko 在 HTML 与 DOM 树之间有一个附加的层 ，称作”content sink”，是创建 DOM 对象的工厂。

尽管 Webkit 与 Gecko 使用略微不同的术语，这个过程还是基本相同的，如下：

---

1).浏览器会将 HTML 解析成一个 DOM 树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。

2).将 CSS 解析成 CSS Rule Tree 。

3).根据 DOM 树和 CSSOM 来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 `display:none` 的东西就没必要放在渲染树中了。

4).有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系。下一步操作称之为 layout，顾名思义就是计算出每个节点在屏幕中的位置。

5).再下一步就是绘制，即遍历 render 树，并使用 UI 后端层绘制每个节点。

---

> 注意：上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

##### 2.1 关键渲染路径

关键渲染路径是指浏览器从最初接收请求来的 HTML、CSS、javascript 等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。

所以浏览器的渲染过程主要包括以下几步：

---

1.解析 HTML 生成 DOM 树，解析 CSS 生成 CSSOM 规则树。 2.将 DOM 树与 CSSOM 规则树合并在一起生成渲染树。 3.遍历渲染树开始布局，计算每个节点的位置大小信息。 4.将渲染树每个节点绘制到屏幕。

---

##### 2.2 构建 DOM 树

当浏览器接收到服务器响应来的 HTML 文档后，会遍历文档节点，生成 DOM 树。

```html
<html>
  <head>
    <title>Web page parsing</title>
  </head>
  <body>
    <div>
      <h1>Web page parsing</h1>
      <p>This is an example Web page.</p>
    </div>
  </body>
</html>
```

> 需要注意的是，DOM 树的生成过程中可能会被 CSS 和 JS 的加载执行阻塞。

##### 2.3 构建 CSSOM 规则树

浏览器解析 CSS 文件并生成 CSS 规则树，每个 CSS 文件都被分析成一个 StyleSheet 对象，每个对象都包含 CSS 规则。CSS 规则对象包含对应于 CSS 语法的选择器和声明对象以及其他对象。

##### 2.4 渲染阻塞

当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建 DOM。每次去执行 JavaScript 脚本都会严重地阻塞 DOM 树的构建，如果 JavaScript 脚本还操作了 CSSOM，而正好这个 CSSOM 还没有下载和构建，浏览器甚至会延迟脚本执行和构建 DOM，直至完成其 CSSOM 的下载和构建。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在 script 标签上增加属性 `defer` 或者 `async`。

所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：

---

CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。
JS 置后：我们通常把 JS 代码放到页面底部，且 JavaScript 应尽量少影响 DOM 的构建。

---

当解析 html 的时候，会把新来的元素插入 dom 树里面，同时去查找 css，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。

例如： `div p {font-size: 16px}`，会先寻找所有 p 标签并判断它的父标签是否为 div 之后才会决定要不要采用这个样式进行渲染）。

所以，我们平时写 CSS 时，尽量用 id 和 class，千万不要过渡层叠。

##### 2.5 构建渲染树

通过 DOM 树和 CSS 规则树我们便可以构建渲染树。浏览器会先从 DOM 树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的 CSS 样式规则并应用。

渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式。这也是渲染树与 DOM 树的最大区别所在。渲染树是用于显示，那些不可见的元素当然就不会在这棵树中出现了。

##### 2.6 渲染树布局

布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。

而有些时候我们会在文档布局完成后对 DOM 进行修改，这时候可能需要重新进行布局，也可称其为**回流(reflow)**，（本质上还是一个布局的过程）。reflow 会从 `<html>` 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。

> HTML 使用的是 flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫 reflow。

reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。

对渲染树的回流可以分为全局和局部的，全局即对整个渲染树进行重新布局，如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部回流可以是对渲染树的某部分或某一个渲染对象进行重新布局。

大多数 web 应用对 DOM 的操作都是比较频繁，这意味着经常需要对 DOM 进行回流，而如果仅仅是一些小改变，就触发整个渲染树的回流，这显然是不好的，为了避免这种情况，浏览器使用了**脏位系统**，只有一个渲染对象改变了或者某渲染对象及其子渲染对象脏位值为 ”dirty” 时，说明需要回流。

表示需要布局的脏位值有两种：

- “dirty” – 自身改变，需要回流
- “children are dirty” – 子节点改变，需要回流

布局是一个从上到下，从外到内进行的递归过程，从根渲染对象，即对应着 HTML 文档根元素，然后下一级渲染对象，如对应着元素，如此层层递归，依次计算每一个渲染对象的几何信息（位置和尺寸）。

每一个渲染对象的布局流程基本如：

---

1.计算此渲染对象的宽度（width）；

2.遍历此渲染对象的所有子级，依次：

- 2.1 设置子级渲染对象的坐标

- 2.2 判断是否需要触发子渲染对象的布局或回流方法，计算子渲染对象的高度（height）

  3.设置此渲染对象的高度：根据子渲染对象的累积高，margin 和 padding 的高度设置其高度；

  4.设置此渲染对象脏位值为 false。

---

##### 2.7 渲染树绘制

在绘制阶段，遍历渲染树，调用渲染器的 `paint` 方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的 UI 后端组件完成的。

CSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：

---

1.背景颜色 2.背景图片 3.边框 4.子代 5.轮廓

---

改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变，这称为**重绘(repaint)**。

和布局一样，绘制也分为全局（绘制整个呈现树）和局部两种。在局部绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块 “dirty 区域”，并生成 “paint” 事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。

Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。 所以，下面这些动作有很大可能会是成本比较高的。

---

- 增加、删除、修改 DOM 结点时，会导致 Reflow 或 Repaint
- 移动 DOM 的位置，或是搞个动画的时候。
- 修改 CSS 样式的时候。
- Resize 窗口的时候（移动端没有这个问题），或是滚动的时候。
- 修改网页的默认字体时。

---

基本上来说，reflow 有如下的几个原因：

---

- Initial 网页初始化的时候。
- Incremental 一些 Javascript 在操作 DOM Tree 时。
- Resize 其些元件的尺寸变了。
- StyleChange 如果 CSS 的属性发生变化了。
- Dirty 几个 Incremental 的 reflow 发生在同一个 frame 的子树上。

---

> 注意：(1)`display:none` 的节点不会被加入 Render Tree，而 `visibility: hidden` 则会，所以，如果某个节点最开始是不显示的，设为 `display:none` 是更优的。

> (2)`display:none` 会触发 reflow，而 `visibility:hidden` 只会触发 repaint，因为没有发现位置变化。

有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫**异步 reflow** 或**增量异步** reflow。但是在有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。

但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些 DOM 值：

```javascript
// offset Top/Left/Width/Height
// scroll Top/Left/Width/Height
// client Top/Left/Width/Height
// IE中的 getComputedStyle 或 currentStyle
```

因为，如果我们的程序需要这些值，那么浏览器需要返回最新的值，而这样一样会 flush 出去一些样式的改变，从而造成频繁的 reflow/repaint。

##### 2.8 减少 reflow/repaint

下面是一些 Best Practices：

---

1）**将多次改变样式属性的操作合并成一次操作**(尽量不要把读操作和写操作，放在一个语句里面)。例如，

DOM style 操作 to CSS class 操作

```javascript
var changeDiv = document.getElementById("changeDiv");
changeDiv.style.color = "#093";
changeDiv.style.background = "#eee";
changeDiv.style.height = "200px";
```

可以合并为：

```css
div.changeDiv {
  background: #eee;
  color: #093;
  height: 200px;
}
```

```js
document.getElementById("changeDiv").className = "changeDiv";
```

---

2）在需要经常取那些引起浏览器重排的属性值时，要缓存到变量

---

3）由于 `display` 属性为 `none` 的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。

如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发 2 次重排。

---

4）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。在内存中多次操作节点，完成后再添加到文档中去。

---

5）尽可能的修改层级比较低的 DOM。当然，改变层级比较底的 DOM 有可能会造成大面积的 reflow，但是也可能影响范围很小。

---

6）尽量使用离线 DOM，而不是真实的网面 DOM，来改变元素样式。比如，操作 Document Fragment 对象，完成后再把这个对象加入 DOM。再比如，使用 `cloneNode()` 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。

---

7）将需要多次重排(布局)的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。

---

8）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。

---

9）使用 `window.requestAnimationFrame`、`window.requestIdleCallback` 这两个方法调节重新渲染

---

#### 3.刷新率

很多时候，密集的重新渲染是无法避免的，比如 scroll 事件的回调函数和网页动画。

网页动画的每一帧（frame）都是一次重新渲染。每秒低于 24 帧的动画，人眼就能感受到停顿。一般的网页动画，需要达到每秒 30 帧到 60 帧的频率，才能比较流畅。如果能达到每秒 70 帧甚至 80 帧，就会极其流畅。

大多数显示器的刷新频率是 60Hz，为了与系统一致，以及节省电力，浏览器会自动按照这个频率，刷新动画（如果可以做到的话）。

所以，如果网页动画能够做到每秒 60 帧，就会跟显示器同步刷新，达到最佳的视觉效果。这意味着，一秒之内进行 60 次重新渲染，每次重新渲染的时间不能超过 16.66 毫秒。

一秒之间能够完成多少次重新渲染，这个指标就被称为"**刷新率**"，英文为 FPS（frame per second）。60 次重新渲染，就是 60FPS。

如果想达到 60 帧的刷新率，就意味着 JavaScript 线程每个任务的耗时，必须少于 16 毫秒。一个解决办法是使用 Web Worker，主线程只用于 UI 渲染，然后跟 UI 渲染不相干的任务，都放在 Worker 线程。

#### 5.window.requestAnimationFrame

有一些 JavaScript 方法可以调节重新渲染，大幅提高网页性能。

其中最重要的，就是 `window.requestAnimationFrame` 方法。它可以将某些代码放到下一次重新渲染时执行。

```javascript
function doubleHeight(element) {
  var currentHeight = element.clientHeight;
  element.style.height = currentHeight * 2 + "px";
}
elements.forEach(doubleHeight);
```

上面的代码使用循环操作，将每个元素的高度都增加一倍。可是，每次循环都是，读操作后面跟着一个写操作。这会在短时间内触发大量的重新渲染，显然对于网页性能很不利。

我们可以使用 `window.requestAnimationFrame`，让读操作和写操作分离，把所有的写操作放到下一次重新渲染。

```javascript
function doubleHeight(element) {
  var currentHeight = element.clientHeight;
  window.requestAnimationFrame(function() {
    element.style.height = currentHeight * 2 + "px";
  });
}
elements.forEach(doubleHeight);
```

页面滚动事件（scroll）的监听函数，就很适合用 `window.requestAnimationFrame` ，推迟到下一次重新渲染。

```javascript
$(window).on("scroll", function() {
  window.requestAnimationFrame(scrollHandler);
});
```

当然，最适用的场合还是网页动画。下面是一个旋转动画的例子，元素每一帧旋转 1 度。

```javascript
var rAF = window.requestAnimationFrame;

var degrees = 0;
function update() {
  div.style.transform = "rotate(" + degrees + "deg)";
  console.log("updated to degrees " + degrees);
  degrees = degrees + 1;
  rAF(update);
}
rAF(update);
```

#### 5.window.requestIdleCallback

还有一个函数 `window.requestIdleCallback`，也可以用来调节重新渲染。

它指定只有当一帧的末尾有空闲时间，才会执行回调函数。

`requestIdleCallback(fn);`

上面代码中，只有当前帧的运行时间小于 16.66ms 时，函数 fn 才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。

它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数 fn 将会强制执行。

`requestIdleCallback(fn, 5000);`

上面的代码表示，函数 fn 最迟会在 5000 毫秒之后执行。

函数 fn 可以接受一个 deadline 对象作为参数。

```javascript
requestIdleCallback(function someHeavyComputation(deadline) {
  while (deadline.timeRemaining() > 0) {
    doWorkIfNeeded();
  }

  if (thereIsMoreWorkToDo) {
    requestIdleCallback(someHeavyComputation);
  }
});
```

上面代码中，回调函数 someHeavyComputation 的参数是一个 deadline 对象。

deadline 对象有一个方法和一个属性：`timeRemaining` 和 `didTimeout`。

##### 5.1 timeRemaining 方法

`timeRemaining` 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于 0，就把任务分配到下一轮 requestIdleCallback。

前面的示例代码之中，只要当前帧还有空闲时间，就不断调用 doWorkIfNeeded 方法。一旦没有空闲时间，但是任务还没有全执行，就分配到下一轮 requestIdleCallback。

##### 5.2 didTimeout 属性

deadline 对象的 didTimeout 属性会返回一个布尔值，表示指定的时间是否过期。这意味着，如果回调函数由于指定时间过期而触发，那么你会得到两个结果。

- timeRemaining 方法返回 0
- didTimeout 属性等于 true

因此，如果回调函数执行了，无非是两种原因：当前帧有空闲时间，或者指定时间到了。

```javascript
function myNonEssentialWork(deadline) {
  while (
    (deadline.timeRemaining() > 0 || deadline.didTimeout) &&
    tasks.length > 0
  )
    doWorkIfNeeded();

  if (tasks.length > 0) requestIdleCallback(myNonEssentialWork);
}

requestIdleCallback(myNonEssentialWork, 5000);
```

上面代码确保了，doWorkIfNeeded 函数一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行。

requestIdleCallback 是一个很新的函数，刚刚引入标准，目前只有 Chrome 支持，不过其他浏览器可以用垫片库。

#### 4.页面渲染优化

---

1.HTML 文档结构层次尽量少，最好不深于六层；

2.脚本尽量后放，放在前即可；

3.少量首屏样式内联放在标签内；

4.样式结构层次尽量简单；

5.在脚本中尽量减少 DOM 操作，尽量缓存访问 DOM 的样式信息，避免过度触发回流；

6.减少通过 JavaScript 代码修改元素样式，尽量使用修改 class 名方式操作样式或动画；

7.动画尽量使用在绝对定位或固定定位的元素上；

8.隐藏在屏幕外，或在页面滚动时，尽量停止动画；

9.尽量缓存 DOM 查找，查找器尽量简洁；

10.涉及多域名的网站，可以开启域名预解析

---

#### 参考：

0.[浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)

1.[浏览器渲染原理及流程](https://www.cnblogs.com/slly/p/6640761.html)

2.[十分钟读懂浏览器渲染流程](https://blog.csdn.net/chanzhi2016/article/details/79345565)

3.[浏览器渲染页面过程与页面优化](https://segmentfault.com/a/1190000010298038)

4.[浏览器渲染流程 详细分析](https://juejin.im/entry/59f010fdf265da4315231caa)

5.[浏览器的渲染：过程与原理](https://zhuanlan.zhihu.com/p/29418126)

6.[浏览器加载、解析、渲染的过程](https://blog.csdn.net/xiaozhuxmen/article/details/52014901)

7.[浏览器的渲染原理简介](https://www.cnblogs.com/ranzige/p/4097453.html)

8.[优化 CSS 重排重绘与浏览器性能](http://caibaojian.com/css-reflow-repaint.html)

9.[网页性能管理详解](http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html)

10.[浏览器的渲染原理简介](https://coolshell.cn/articles/9666.html)

11.[浏览器 渲染,绘制流程及性能优化](https://zhuanlan.zhihu.com/p/25279069)

### 浏览器输入 URL 后发生了什么

---

- 1.DNS 域名解析；
- 2.建立 TCP 连接；
- 3.发送 HTTP 请求；
- 4.服务器处理请求；
- 5.返回响应结果；
- 6.关闭 TCP 连接；
- 7.浏览器解析 HTML；
- 8.浏览器布局渲染；

---

#### 输入的是 URL 还是搜索的关键字？

当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL 会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。

#### 检查 HSTS 列表

浏览器检查自带的“预加载 HSTS（HTTP 严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用 HTTPS 进行连接的网站

如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用 HTTP 协议发送

注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。

#### 1.DNS 域名解析

我们在浏览器输入网址，其实就是要向服务器请求我们想要的页面内容，所有浏览器首先要确认的是域名所对应的服务器在哪里。将域名解析成对应的服务器 IP 地址这项工作，是由 DNS 服务器来完成的。

---

- 浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。

- 如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。

- gethostbyname 函数在试图进行 DNS 解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 不同的操作系统有所不同

- 如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。

- 查询本地 DNS 服务器

- 如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP 查询

- 如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询

---

DNS 服务器层次结构

#### ARP 过程

要想发送 **ARP（地址解析协议）**广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。

- 首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC

如果缓存没有命中：

---

- 查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。
- 查询选择的网络接口的 MAC 地址
- 我们发送一个二层（ OSI 模型 中的数据链路层）ARP 请求：

```javascript
ARP Request:

Sender MAC: interface:mac:address:here
Sender IP: interface.ip.goes.here
Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)
Target IP: target.ip.goes.here
```

根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：

1).直连：

- 如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。

  2).集线器：

- 如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。

  3).交换机：

- 如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。
- 如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求
- 如果路由器也“连接”在其中，它会返回一个 ARP Reply

```javascript
ARP Reply:

Sender MAC: target:mac:address:here
Sender IP: target.ip.goes.here
Target MAC: interface:mac:address:here
Target IP: interface.ip.goes.here
```

现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：

- 使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议
- 如果本地 /ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回

#### 使用套接字

当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 `socket` ，请求一个 TCP 流套接字，对应的参数是 `AF_INET/AF_INET6` 和 `SOCK_STREAM` 。

---

这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux 下是 `ip_local_port_range`)

---

TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的 IP 地址以及本机的 IP 地址，把它封装成一个 IP packet。

---

这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的 MAC 地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。

---

到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：

- 以太网
- WiFi
- 蜂窝数据网络

对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 网络节点 处理。节点的目标地址和源地址将在后面讨论。

大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 网络节点 进行处理。

最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域(autonomous system, 缩写 AS)的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从 IP 数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP 数据报头部 time to live (TTL) 域的值每经过一个路由器就减 1，如果封包的 TTL 变为 0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。

上面的发送和接受过程在 TCP 连接期间会发生很多次：

---

- 客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号

---

- 服务器端接收到 SYN 包，如果它可以建立连接：

  - 服务器端选择它自己的初始序列号
  - 服务器端设置 SYN 位，表明自己选择了一个初始序列号
  - 服务器端把 (客户端 ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包

---

- 客户端通过发送下面一个封包来确认这次连接：
  - 自己的序列号+1
  - 接收端 ACK+1
  - 设置 ACK 位

---

- 数据通过下面的方式传输：
  - 当一方发送了 N 个 Bytes 的数据之后，将自己的 SEQ 序列号也增加 N
  - 另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号

---

- 关闭连接时：
  - 要关闭连接的一方发送一个 FIN 包
  - 另一方确认这个 FIN 包，并且发送自己的 FIN 包
    要关闭的一方使用 ACK 包来确认接收到了 FIN

---

从客户端到本地服务器属于**递归查询**，而 DNS 服务器之间的交互属于**迭代查询**。

> 正常情况下，本地 DNS 服务器的缓存中已有 comDNS 服务器的地址，因此请求根域名服务器这一步不是必需的。

#### 2.建立 TCP 链接

费了一顿周折终于拿到服务器 IP 了，下一步自然就是链接到该服务器。对于客户端与服务器的 TCP 链接，必然要说的就是『三次握手』。

客户端发送一个带有 SYN 标志的数据包给服务端，服务端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息，最后客户端再回传一个带 ACK 标志的数据包，代表握手结束，连接成功。

#### TLS 握手

---

客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。

---

服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的 TLS 版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥

---

客户端根据自己的信任 CA 列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥

---

服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥

---

客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值

---

服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密

---

从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容

---

#### HTTP 协议

如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。

如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求:

```javascript
GET / HTTP / 1.1;
Host: google.com;
Connection: close[其他头部];
```

“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合 HTTP 协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反 HTTP 协议标准的 bug，同时假设浏览器使用 HTTP/1.1 协议，不然的话头部可能不包含 Host 字段，同时 GET 请求中的版本号会变成 HTTP/1.0 或者 HTTP/0.9 。）

HTTP/1.1 定义了“关闭连接”的选项 "close"，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：

`Connection:close`

不支持持久连接的 HTTP/1.1 应用必须在每条消息中都包含 "close" 选项。

在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。

服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:

```javascript
200 OK
[响应头部]
```

然后是一个换行，接下来有效载荷(payload)，也就是 www.google.com 的 HTML 内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。

如果浏览器发送的 HTTP 头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:

```javascript
304 Not Modified
[响应头部]
```

这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。

在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到 HTML 页面引入的所有资源（图片，CSS，favicon.ico 等等）全部都获取完毕，区别只是头部的 `GET / HTTP/1.1` 会变成 `GET /$(相对 www.google.com 的 URL) HTTP/1.1`。

如果 HTML 引入了 www.google.com 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。

#### 4.发送 HTTP 请求

与服务器建立了连接后，就可以向服务器发起请求了。这里我们先看下请求报文的结构（如下图）：

在浏览器中查看报文首部（以 google 浏览器为例）：

请求行包括请求方法、URI、HTTP 版本。首部字段传递重要信息，包括请求首部字段、通用首部字段和实体首部字段。我们可以从报文中看到发出的请求的具体信息。具体每个首部字段的作用，这里不做过多阐述。

#### 4.服务器处理请求

服务器端收到请求后的由 web 服务器（准确说应该是 http 服务器）处理请求，诸如 Apache、Ngnix、IIS 等。web 服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过 web 服务器返回给浏览器客户端。

HTTPD(HTTP Daemon) 在服务器端处理请求/响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。

---

- HTTPD 接收请求

---

- 服务器把请求拆分为以下几个参数：

  - HTTP 请求方法(GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE)。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法
  - 域名：google.com
  - 请求路径/页面：/ (我们没有请求 google.com 下的指定的页面，因此 / 是默认的路径)

---

- 服务器验证其上已经配置了 google.com 的虚拟主机
- 服务器验证 google.com 接受 GET 方法
- 服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)

---

- 如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求

---

- 服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 "/" ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。

---

- 服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者

---

#### 5.返回响应结果

在 HTTP 里，有请求就会有响应，哪怕是错误信息。这里我们同样看下响应报文的组成结构：

在响应结果中都会有个一个 HTTP 状态码，比如我们熟知的 200、301、404、500 等。通过这个状态码我们可以知道服务器端的处理是否正常，并能了解具体的错误。

状态码由 3 位数字和原因短语组成。根据首位数字，状态码可以分为五类：

#### 6.关闭 TCP 连接

为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建 TCP 连接的 3 次握手类似，关闭 TCP 连接，需要 4 次握手。

#### 7.浏览器解析资源

准确地说，浏览器需要加载解析的不仅仅是 HTML，还包括 CSS、JS。以及还要加载图片、视频等其他媒体资源。

浏览器通过解析 HTML，生成 DOM 树，解析 CSS，生成 CSS 规则树，然后通过 DOM 树和 CSS 规则树生成渲染树。渲染树与 DOM 树不同，渲染树中并没有 head、display 为 none 等不必显示的节点。

要注意的是，浏览器的解析过程并非是串连进行的，比如在解析 CSS 的同时，可以继续加载解析 HTML，但在解析执行 JS 脚本时，会停止解析后续 HTML，这就会出现阻塞问题，关于 JS 阻塞相关问题，这里不过多阐述,后面会单独开篇讲解。

#### 8.浏览器布局渲染

根据渲染树布局，计算 CSS 样式，即每个节点在页面中的大小和位置等几何信息。HTML 默认是流式布局的，CSS 和 js 会打破这种布局，改变 DOM 的外观样式以及大小和位置。最后浏览器绘制各个节点，将页面展示给用户。

#### 参考：

1.[当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？](https://github.com/skyline75489/what-happens-when-zh_CN#id9)

2.[从输入 URL 到页面加载完成的过程中都发生了什么事情？](http://fex.baidu.com/blog/2014/05/what-happen/)

3.[在浏览器地址栏输入一个 URL 后回车，背后会进行哪些技术步骤？](https://www.zhihu.com/question/34873227)

4.[”天龙八步“细说浏览器输入 URL 后发生了什么](http://www.xuecaijie.com/it/157.html#1Q64dG0mJ2gKFF)

### DNS 解析

#### 1.为什么需要 DNS 解析域名为 IP 地址？

网络通讯大部分是基于 TCP/IP 的，而 TCP/IP 是基于 IP 地址的，所以计算机在网络上进行通讯时只能识别如 “202.96.134.133” 之类的 IP 地址，而不能认识域名。我们无法记住 10 个以上 IP 地址的网站，所以我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫 “DNS 服务器” 的计算机自动把我们的域名“翻译”成了相应的 IP 地址，然后调出 IP 地址所对应的网页。

#### 2.具体什么是 DNS？

DNS( Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于 TCP/IP 网络，它所提供的服务是用来将主机名和域名转换为 IP 地址的工作。

#### 3.DNS 的过程？

关于 DNS 的获取流程：DNS 是应用层协议，事实上他是为其他应用层协议工作的，包括不限于 HTTP 和 SMTP 以及 FTP，用于将用户提供的主机名解析为 ip 地址。

具体过程如下：

---

- 1).用户主机上运行着 DNS 的客户端，就是我们的 PC 机或者手机客户端运行着 DNS 客户端了

- 2).浏览器将接收到的 url 中抽取出域名字段，就是访问的主机名，比如 `http://www.baidu.com/`, 并将这个主机名传送给 DNS 应用的客户端

- 3).DNS 客户机端向 DNS 服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式 DNS 集群的工作）

- 4).该 DNS 客户机最终会收到一份回答报文，其中包含有该主机名对应的 IP 地址

- 5).一旦该浏览器收到来自 DNS 的 IP 地址，就可以向该 IP 地址定位的 HTTP 服务器发起 TCP 连接

---

#### 4.DNS 服务的体系架构是怎样的？

DNS domain name system 主要作用就是将主机域名转换为 ip 地址。

假设运行在用户主机上的某些应用程序（如 Webl 浏览器或者邮件阅读器）需要将主机名转换为 IP 地址。这些应用程序将调用 DNS 的客户机端，并指明需要被转换的主机名。

用户主机的 DNS 客户端接收到后，向网络中发送一个 DNS 查询报文。所有 DNS 请求和回答报文使用的 UDP 数据报经过端口 53 发送经过若干 ms 到若干 s 的延时后，用户主机上的 DNS 客户端接收到一个提供所希望映射的 DNS 回答报文。

这个查询结果则被传递到调用 DNS 的应用程序。因此，从用户主机上调用应用程序的角度看，DNS 是一个提供简单、直接的转换服务的黑盒子。但事实上，实现这个服务的黑盒子非常复杂，它由分布于全球的大量 DNS 服务器以及定义了 DNS 服务器与查询主机通信方式的应用层协议组成。

DNS 为什么不采用单点的集中式的设计方式，而是使用分布式集群的工作方式？

DNS 的一种简单的设计模式就是在因特网上只使用一个 DNS 服务器，该服务器包含所有的映射，在这种集中式的设计中，客户机直接将所有查询请求发往单一的 DNS 服务器，同时该 DNS 服务器直接对所有查询客户机做出响应，尽管这种设计方式非常诱人，但他不适用当前的互联网，因为当今的因特网有着数量巨大并且在持续增长的主机，这种集中式设计会有单点故障（嗝屁一个，全球着急），通信容量（上亿台主机发送的查询 DNS 报文请求，包括但不限于所有的 HTTP 请求，电子邮件报文服务器，TCP 长连接服务），远距离的时间延迟（澳大利亚到纽约的举例），维护开销大（因为所有的主机名 - ip 映射都要在一个服务站点更新）等问题。

DNS 服务器一般分三种，根 DNS 服务器，顶级 DNS 服务器，权威 DNS 服务器。

使用分布式的层次数据库模式以及缓存方法来解决单点集中式的问题。

##### 4.1 DNS 域名称

域名系统作为一个层次结构和分布式数据库，包含各种类型的数据，包括主机名和域名。DNS 数据库中的名称形成一个分层树状结构称为域命名空间。域名包含单个标签分隔点，例如：`im.qq.com`

完全限定的域名 (FQDN) 唯一地标识在 DNS 分层树中的主机的位置，通过指定的路径中点分隔从根引用的主机的名称列表。 下图显示与主机称为 im 内 `qq.com`

DNS 树的示例。 主机的 FQDN 是 `im.qq.com`

##### 4.2 DNS 域的名称层次结构

##### 4.3 DNS 域名称空间的组织方式

按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例。例如：`www.uestc.edu.cn`

##### 4.4 DNS 和 Internet 域

互联网域名系统由名称注册机构负责维护分配由组织和国家/地区的顶级域在 Internet 上进行管理。 这些域名按照国际标准 3166。 一些很多现有缩写，保留以供组织中，以及两个字母和三个字母的国家/地区使用的缩写使用下表所示。一些常见的 DNS 域名称如下图：

##### 4.5 资源记录

DNS 数据库中包含的资源记录 (RR)。 每个 RR 标识数据库中的特定资源。我们在建立 DNS 服务器时，经常会用到 SOA,NS,A 之类的记录，在维护 DNS 服务器时，会用到 MX，CNAME 记录。 常见的 RR 见下图：

##### 4.6 Dns 服务的工作过程当

DNS 客户机需要查询程序中使用的名称时，它会查询本地 DNS 服务器来解析该名称。客户机发送的每条查询消息都包括 3 条信息，以指定服务器应回答的问题。

---

- 指定的 DNS 域名，表示为完全合格的域名 (FQDN) 。
- 指定的查询类型，它可根据类型指定资源记录，或作为查询操作的专门类型。
- DNS 域名的指定类别。

---

对于 DNS 服务器，它始终应指定为 Internet 类别。例如，指定的名称可以是计算机的完全合格的域名，如 `im.qq.com`，并且指定的查询类型用于通过该名称搜索地址资源记录。

DNS 查询以各种不同的方式进行解析。客户机有时也可通过使用从以前查询获得的缓存信息就地应答查询。DNS 服务器可使用其自身的资源记录信息缓存来应答查询，也可代表请求客户机来查询或联系其他 DNS 服务器，以完全解析该名称，并随后将应答返回至客户机。这个过程称为递归。

另外，客户机自己也可尝试联系其他的 DNS 服务器来解析名称。如果客户机这么做，它会使用基于服务器应答的独立和附加的查询，该过程称作迭代，即 DNS 服务器之间的交互查询就是迭代查询。

DNS 查询的过程如下图所示。

---

1、在浏览器中输入 `www.qq.com` 域名，操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。

---

2、如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。

---

3、如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/ip 参数中设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。

---

4、如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。

---

5、如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 13 台根 DNS，根 DNS 服务器收到请求后会判断这个域名(`.com`)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责 `.com` 域的这台服务器。这台负责 `.com` 域的服务器收到请求后，如果自己无法解析，它就会找一个管理 `.com域 ` 的下一级 DNS 服务器地址(`http://qq.com`)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 `http://qq.com` 域服务器，重复上面的动作，进行查询，直至找到 `www.qq.com` 主机。

---

6、如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户机。

---

从客户端到本地 DNS 服务器是属于递归查询，而 DNS 服务器之间就是的交互查询就是迭代查询。

#### 参考：

1.[DNS 原理及其解析过程【精彩剖析】](http://blog.51cto.com/369369/812889)
