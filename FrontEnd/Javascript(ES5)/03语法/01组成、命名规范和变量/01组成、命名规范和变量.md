# 三 语法

## 1 组成

1).**ECMAScript**：定义了 js 里面的命名规范、变量、数据类型、基本语法、操作语句等最核心的东西；

2).**DOM**（document object modle）文档对象模型 ：DOM 结构中提供了很多用来操作 DOM 元素的方法和属性（`api`）；

3).**BOM**（brower object modle）浏览器对象模型 ：提供一系列的方法（`api`）来操作浏览器；

## 2 命名规范

1).严格区分大小写；

2).使用小驼峰命名法：

---

- a.首字母小写，其余每个有意义的单词首字母大写；
- b.可以使用数字（但不能作为首位）、字母、下划线、`$`；
- c.不能使用关键字（在 js 中有特殊意义的字）和保留字（未来可能成为关键字的词）；

---

- 规范如下：

  1.变量：匈牙利命名法

  2.函数：Camel (第一个单词首字母小写，其他单词首字母大写)

  3.属性：Camel

| 类型     | 前缀 | 实例      |
| -------- | :--: | --------- |
| Array    |  a   | aNameList |
| Boolean  |  b   | bVisible  |
| Float    |  f   | fMoney    |
| Function |  fn  | fnMethod  |
| Int      |  i   | iAge      |
| Object   |  o   | oType     |
| Regexp   |  re  | rePattern |
| String   |  s   | sName     |

## 3 JavaScript 中的变量

### 3.1 var

1).用来声明一个变量（对于未经初始化的变量，会保存一个特殊的值: `undefined` ），可以重复声明；

2).使用 var 声明的变量会自动添加到最接近的环境中，若初始化变量没有使用 var 声明，则会默认添加到全局环境；

3).用 `var` 操作符定义的变量将成为定义该变量的作用域中的局部变量，在该作用域之外无法访问该变量。也就是说，如果在函数中使用 `var` 定义一个变量，那么这个变量在函数退出后就会被销毁；

4).可以用一条语句定义多个变量，用逗号隔开(因为 ECMAScript 的变量是松散类型的，所以不同类型初始化变量的操作可以放在一条语句中来完成)。

5).严格地说，`var a = 1` 与 `a = 1`，这两条语句的效果不完全一样，主要体现在 `delete` 命令无法删除前者（因为使用 var 声明变量，创建的属性是不可配置的）。不过，绝大多数情况下，这种差异是可以忽略的。

```javascript
// demo1
var a;
console.log(a); //undefined

// demo2
var b = 6;
c = 7;
console.log(window.b); //6
console.log(window.c); //7

// demo3
function fn() {
  var d = 12;
}
// console.log(d);
//Uncaught ReferenceError: d is not defined

// demo4
var str = "我是字符串呀",
  ary = ["数组哥哥", "数组弟弟0_0"],
  obj = {
    name: "没有对象 o(╥﹏╥)o"
  };
console.log(str, ary, obj);
// 我是字符串呀 ["数组哥哥", "数组弟弟0_0"] {name: "没有对象 o(╥﹏╥)o"}

// demo5
var e = 123;
console.log(delete e); //false
console.log(e); //123
f = 123;
console.log(delete f); //true
console.log(f);
//Uncaught ReferenceError: f is not defined

var aaa = 12;
console.log(delete aaa); //false

// 没有使用严格模式，给一个未声明的变量赋值，会自动创建一个全局变量，且是正常的可配置属性
bbb = 12;
console.log(delete bbb); //true

window.ccc = 12;
console.log(delete ccc); //true
```

> 严格模式下，不能定义 `eval` 或 `arguments` 的变量，否则导致语法错误。见 <a href="./demo/var.html">var.html</a>

虽然省略 `var` 操作符可以定义全局变量，但我们不推荐这种做法。因为在局部作用域中定义的全局变量很难维护，而且如果有意的忽略 `var` 操作符，也会由于相应的变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下会导致抛出 `ReferenceRrror` 错误。

全局变量是全局对象的属性，是 ECMAScript 规范强制规定的，而对于局部变量则没有如此规定。可以想象，局部变量当做跟函数调用相关的某个对象的属性。ECMAScript 3 规范称该对象为 “调用对象”（call object），ECMAScript 5 规范称为“声明上下文对象”（declarative enviroment record）。js 允许使用 this 关键字来引用全局对象，去没有方法可以引用局部变量存放的对象。这种存放局部变量的对象的特有性质，是一种对我们不可见的内部实现。

### 3.2 变量提升

JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做**变量提升（hoisting）**。

> 变量提升是在 js 引擎的“预编译”时进行，是在代码开始运行之前。

变量提升是一种机制，在作用域形成后，代码执行之前，把关键词 `var` 和 `function` 提前声明或定义；`var` 只会声明，`function` 定义；

> JS 的变量提升是以段为处理单元的。

对引用数据类型变量提升，会把内容放在堆内存，任意类型数据都会记录（变量也会存放），若是表达式（函数也是表达式）则将结果存放；待代码执行时，才将对应的变量赋值；

变量提升注意事项：

---

1).`if` 或 `while` 判断语句中：不管条件判断是否成立，判断体中的内容都要进行变量提升，注意函数只有声明没有赋值

```javascript
// 条件不成立
console.log(b); //undefined
console.log(bb); //undefined
while (false) {
  var b = 6;
  function bb() {
    return "bb";
  }
}

//条件成立
console.log(a); //undefined
console.log(aa); //undefined
if (true) {
  console.log(a); //undefined
  console.log(aa); //Fn aa(){}
  var a = 6;

  function aa() {
    return "aa";
  }
}
```

---

2).变量提升的时候只对 "`=`" 等号左边的变量进行变量提升，右边代表的都是值，是不进行变量提升的；

```javascript
console.log(a); //undefined
console.log(b); //b is not defined

var a = b + 1;
```

---

3).函数表达式不会进行提升

```js
console.log(FF); // f FF(){}
console.log(de); // de is not defined
function FF() {
  console.log(de); // de is not defined
  (function de() {
    console.log("444");
  })();
}
FF();
```

---

4).函数声明当做参数的时候不进行变量提升；

```js
console.log(def); //def is not defined
(function(def) {
  def("123");
})(function def(str) {
  console.log(str); //123
});
```

---

5).虽然函数体中 `return` 下面的代码是不执行的，但是需要进行私有作用域下的变量提升；而 `return` 的代码会执行，但是不进行变量提升的；

```javascript
function a() {
  console.log(b); //b is not defined
  console.log(c); //ƒ c() {}

  return function b() {};
  function c() {}
}
a();
```

---

6).在变量提升的时候，如果发现名字冲突了，重新声明会被忽略，但不会忽略赋值；

```javascript
console.log(v1); //undefined
var v1 = 6;
var v1 = 7;
console.log(v1); //7
```

---

7).对于函数定义式，会将函数定义提前。而函数表达式，会在执行过程中才计算。

```javascript
console.log(fn); //f fn(){...}
console.log(f); //undefined

function fn() {
  return "小黄人";
}
var f = function() {
  console.log(fn); //f fn(){...}
  console.log(f); //f(){...}
  return "大黄蜂";
};
f();
```

---

> 变量提声时，先声明的拥有声明权，后声明的会被忽略；但是不会忽略赋值行为；

### 3.3 变量赋值

变量进行连续赋值时，只有最左边才会被声明，中间变量不会被声明（但有赋值）；

```javascript
console.log(m); //undefined
console.log(n); //n is not defined
var m = (n = 2);
console.log(m); //2
console.log(n); //2
```

### 3.4 执行环境

**执行环境/执行上下文**（execution context）定义变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的**变量对象**（variable object），环境中定义的所有变量和函数都保持在这个对象中。

根据 ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。在 web 浏览器中，全局执行环境被认为是 window 对象，因此所有的全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中所有的代码执行完毕后，该环境被销毁，保存其中的所有变量和函数定义也随之销毁。

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行以后，栈将其环境弹出，把控制权返回给之前的执行环境。

### 3.5 作用域

一个变量的**作用域**（scope）是程序源代码中定义这个变量的区域。在函数内部定义的变量，则是局部变量，作用域是局部的。函数参数也是局部变量，只在函数体内有定义。

在函数体内，局部变量的优先级高于同名的全局变量。如果在函数体内声明的一个局部变量或者函数参数与全局变量重名，那么全局变量就会被局部变量所遮盖。

> ES6 正式引入块级作用域（block scope）。

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么几乎使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作会导致 LHS 查询。`=` 操作符或函数调用时传入参数的操作都会导致关联作用域的赋值操作。

### 3.6 作用域链

js 是基于词法作用域的语言：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。全局变量在程序中始终有定义，而局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的。

当代码在一个环境中执行的时候，会创建变量对象的一个**作用域链**（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象（在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含环境，而再下一个变量对象则来自于下一个包含环境。这样，一直延伸到全局执行环境。全局执行环境的变量对象始终是作用域链中的最后一个对象。

在私有作用域中变量调用时，先检查私有作用域是否有变量声明，若没有则往上一级查找，直至 `window`，若还找不到则报错，这个过程称为作用域链；

> 私有作用域之间没有关联；

在 js 的最顶层代码中（不包含任何函数定义的代码），作用域链是由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链至少有三个对象。

当定义一个函数时，实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。

对于嵌套函数来讲，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别--在每次外部函数调用时，内部函数的代码是相同的，但是关联这段代码的作用域链却不同。

### 3.7 作用域销毁机制

堆内存销毁需要手动销毁，否则待全局作用域退出才销毁 （即赋值 `null`）;

---

栈内存：

- 全局：关闭浏览器；

- 私有：
  - 销毁：一个函数没有返回值，或者返回值的内容没有被外界占用（返回值为引用数据类型，且被外界变量接受）；
  - 不销毁：一个函数返回值（通常是函数）被外界占用；

---

### 3.8 垃圾回收

JavaScript 具有自动垃圾收集机制，即执行环境会负责管理代码执行过程中使用的内存。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这样操作。

局部变量值在函数执行的过程中存在，而这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便储存它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。

#### 3.8.1 标记清除

JavaScript 中最常用的垃圾手机方式是**标记清除**（mark-and-sweep）。当变量进入环境时，将将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放金 UR 环境的变量所占用的内存。因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

可以使用任何方式来标记变量。如何标记变量其实并不重要，关键在于采取什么策略。

垃圾收集器在运行的时候会给储存在内存中的所有变量加上标记，然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些那些带标记的值并回收它们所占用的内存空间。

#### 3.8.2 引用计数

另一个不太常见的垃圾收集策略叫做**引用计数**（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给了另一个变量，则该值的引用次数加 1.相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1.当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占用的空间。

计数引用有一个很严重的问题：循环引用。循环引用指定是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。它们的引用次数永远不会是 0 ，而且多次调用，还会导致大量内存得不到回收。未来避免这样的问题，最好是在不使用时切断它们的联系。将变量设置为 `null` 就可以切断变量与它此前引用的值之间的链接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。

#### 3.8.3 性能问题

垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也会是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。

> IE 的垃圾收集器是根据内存分配量运行的，具体一点，就是 256 个变量、4096 个对象（或数组）字面量和数组元素（slot）或者 64 KB 的字符串。达到上述任一一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本包含那么多变量，那么该脚本很可能就会在其生命周期中一直保存有那么多变量，而这样一来，垃圾收集器就不得不频繁地运行，结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。

#### 3.8.4 管理内存

使用具备垃圾收集机制的语言编写程序，开发人员一般不用操心内存管理的问题。但是，JavaScript 在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web 浏览器的可用内存数量通常比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，还会影响调用栈以及在一个线程中能够同时执行的语句数量。

因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 `null` 来释放其引用————这个做法叫做**解除引用**（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。

不过解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。
