## 5 操作符

ESMAScript 操作符与众不同之处在于，它们能够适用于很多值。在应用于对象时，相应的操作符通常都会调用对象的 `valueOf()` 和 `toString()`（或）方法，以便取得可以操作的值。

### 5.1 一元操作符

只能操作一个值的操作符就做一元操作符。

#### 5.1.1 递增和递减操作符

直接借鉴自 C，各有两个版本：前置型和后置型。

```javascript
//前置型
var age = 18;
console.log(++age); //19
console.log(age); //19
//语句求值之前，变量已变

//后置型
var year = 2018;
console.log(year--); //2018
console.log(year); //2017
//语句求值之后，变量才变
```

执行前置递增或递减时，变量的值都是在语句被求值以前改变的（在计算机科学领域，这种情况通常被称作**副效应**），即会先进行自增/自减操作，再返回变量操作后的值；

而后置型递增或递减，是在包含它们的语句被求值之后才执行的，即先返回变量操作前的值，再进行自增/自减操作。

这四个操作符对任何值都适用。遵循规则：

---

- 1).包含有效数字字符的字符串：先转换为数值，在执行增减操作；

- 2).不包含有效数字字符的字符串：`NaN`；

- 3).`true/false`：先转换为数值，在执行增减操作；

- 4).浮点数值：直接执行增减操作；

- 5).对象：先调用对象的 `valueOf()` 方法，以获取一个可以操作的数值，然后遵循以上规则；若得到 `NaN`，则再调用 `toString()` 方法后再应用上述规则。

---

> `++` 是数值运算，不完全同于 `+=` ；后者可以进行字符串的拼接；

#### 5.1.2 一元加减操作符

`"+"` 放在数值前面，对数值不产生任何影响；但是在非数值变量前面，会像 `Number()` 转型函数一样对这个值执行转换。

`"-"` 主要用于表示负数。应用于非数值变量时，遵循 `"+"` 相同的操作，再将得到的数值转为负数。

### 5.2 位操作符

位操作符用于最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 60 位的值；而是将 64 位值转换为 32 位的整数，然后执行操作，最后转换为 64 位值。

对于有符号的整数，32 位的前 31 位用于表示整数的值，第 32 位表示数值的符号：0 表示正数，1 表示负数，这个表示符号的位叫做**符号位**。符号位决定其他为数值的格式。

其中正数以纯二进制格式表示，31 位中的每一位都表示 2 的幂。没用到的位以 0 填充。负数同样以二进制码存储，但用的是**二进制补码**。

二进制补码：

1).先求这个数的绝对值的二进制码；

2).再求二进制码的反码（0/1 替换 1/0）；

3).将得到的二进制反码加 1；

> 在处理有符号整数时，是不能访问位 31 的。???

以上 64 位转换 32 位的过程，会导致一个严重的副效应：在对特殊的 `NaN` 和 `Infinity` 值应用位操作时，这两个值都会被当做 0 来处理。如果对非数值应用位操作，会先使用 `Number()` 函数将该值转换为一个数值（自动），然后再进行位操作，得到一个数值。

#### 5.2.1 按位非 NOT（`~`）

运算符（`~`）将每个二进制位都变为相反值（0 变为 1，1 变为 0）。

考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于 -1。

所有的位运算都只对整数有效。按位非遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次按位非，能达到取整效果，是所有取整方法中最快的一种。

> 按位非是 ECMAScript 操作符中少数几个与二进制计算有关的操作符之一。
> 按位非是在数值表示的最底层执行操作，因此速度很快。

#### 5.2.2 按位与 AND（`&`）

本质：将两个数值的每一位对齐
有两个操作符数

二进制与运算符（`&`）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为 0，就返回 0，否则返回 1。

`0 & 3 // 0`

上面代码中，0（二进制 00）和 3（二进制 11）进行二进制与运算会得到 00（即 0）。

底层实现

```javascript
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
```

#### 5.2.3 按位或 OR（`|`）

二进制或运算符（`|`）逐位比较两个运算子，两个二进制位之中只要有一个为 1，就返回 1，否则返回 0。

`0 | 3 // 3`

上面代码中，0 和 3 的二进制形式分别是 00 和 11，所以进行二进制或运算会得到 11（即 3）。

位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与 0 进行二进制或运算，等同于对该数去除小数部分，即取整数位。

> 需要注意的是，这种取整方法不适用超过 32 位整数最大值 2 147 483 647 的数。

#### 5.2.4 按位异或 XOR（`^`）

| 第一个数值的位 | 第二个数值的位 | 结果 |
| :------------: | :------------: |:--: |
|       1        |       1        |  0   |
|       1        |       0        |  1   |
|       0        |       1        |  1   |
|       0        |       0        |  0   |

“异或运算”有一个特殊运用，连续对两个数 `a` 和 `b` 进行三次异或运算，`a^=b; b^=a; a^=b;`，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。这是互换两个变量的值的最快方法。

#### 5.2.5 左移（`<<`）

将数值的所有位向左移动指定的位数。左移操作会以 0 填充空位；且不会影响操作数的符号。

如果左移 0 位，就相当于将该数值转为 32 位整数，等同于取整，对于正数和负数都有效。

#### 5.2.6 右移（`>>`）

表示将一个数的二进制值向右移动指定的位数，头部补 0，但保留符号位。

右移运算可以模拟 2 的整除运算。

```javascript
5 >> 1;
// 2
// 相当于 5 / 2 = 2

21 >> 2;
// 5
// 相当于 21 / 4 = 5
```

> 有符号的右移操作会以符号位的值填充空位，与左移操作相反。

#### 5.2.7 带符号的右移（`>>>`）

将数值的所有 32 位都向右移。对正数来说，有、无符号的右移一样，但对于负数来说却是不一样的：

- 1).无符号右移是以 0 来填充的；

- 2).无符号的右移会把负数的二进制码当成正数的二进制码，而且负数以其绝对值的二进制补码形式表示，因此导致右移的结果非常大。

查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。

`-1 >>> 0 // 4294967295`

位运算符可以用作设置对象属性的开关。

假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。

```javascript
var FLAG_A = 1; // 0001
var FLAG_B = 2; // 0010
var FLAG_C = 4; // 0100
var FLAG_D = 8; // 1000
```

然后，就可以用二进制与运算检验，当前设置是否打开了指定开关。

```javascript
var flags = 5; // 二进制的0101

if (flags & FLAG_C) {
  // ...
}
// 0101 & 0100 => 0100 => true
```

上面代码检验是否打开了开关 C。如果打开，会返回 true，否则返回 false。

现在假设需要打开 A、B、D 三个开关，我们可以构造一个掩码变量。

```javascript
var mask = FLAG_A | FLAG_B | FLAG_D;
// 0001 | 0010 | 1000 => 1011
```

上面代码对 A、B、D 三个变量进行二进制或运算，得到掩码值为二进制的 1011。

有了掩码，二进制或运算可以确保打开指定的开关。

`flags = flags | mask;`

二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。

`flags = flags & mask;`

异或运算可以**切换（toggle）**当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。

`flags = flags ^ mask;`

二进制否运算可以翻转当前设置，即原设置为 0，运算后变为 1；原设置为 1，运算后变为 0。

`flags = ~flags;`

### 5.3 布尔操作符

在一门编程语言中，布尔操作符的重要性堪比相等操作符。

#### 5.3.1 逻辑非 (`!`)

可以应用于任何类型值；无论何种类型，都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再取反。

#### 5.3.2 逻辑与 (`&&`)

**逻辑与操作属于短路操作符**，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与而言，如果第一个操作数为 false，则无论第二个操作数是什么值，都不能是 true。总结为：第一个为 true，返回第二个操作数；第一个为 false，返回第一个操作数，且不再对第二个运算子求值。

#### 5.3.3 逻辑或 (`||`)

同逻辑与，逻辑或也是短路操作符。总结：第一个为 true，返回第一个操作数，且不再对第二个运算子求值；第一个为 false，返回第二个操作数。

> 这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为**短路（short-cut）**。

### 5.4 乘性操作符

ECMAScript 定义了 3 个乘性操作符。这些操作符与 Java、C 或者 Perl 中 相应操作符用途类似，只不过在操作数是非数值的情况下会执行自动的数据转换（`Number()`）。

#### 5.4.1 乘法(`*`)

语法类似 C，处理特殊值时，特殊规则：

---

- 都是数值：常规执行，超过范围返回 `Infinity` 或 `-Infinity`
- `Infinity` 和 0：返回 `NaN`
- `Infinity` 和非 0：返回 `Infinity` 或 `-Infinity`
- `Infinity` 与 `Infinity`/`-Infinity`：返回 `Infinity`/`-Infinity`

---

#### 5.4.2 除法(`/`)

同乘法操作符，处理特殊值时，特殊规则：

---

- 都是数值：常规执行，超过范围返回 `Infinity` 或 `-Infinity`
- `Infinity` 与 `Infinity`/`-Infinity`：返回 `NaN`
- `Infinity` 除非 0 有限数：返回 `Infinity` 或 `-Infinity`
- 0 与 0：返回 `NaN`
- 0 与 非 0：返回 0
- 非 0 除 0：返回 `Infinity`

---

#### 5.4.3 求模(`%`)

处理特殊值时，特殊规则：

---

- 都是数值：常规执行
- `Infinity` 除任何：返回 `NaN`
- 任何除 0：返回 `NaN`
- 非 0 有限数除 `Infinity`：返回被除数
- 0 除非 0：返回 0

---

> 需要注意的是，运算结果的正负号由第一个运算子的正负号决定。

#### 5.4.4 指数(`**`)

指数运算符（`**`）完成指数运算，前一个运算子是底数，后一个运算子是指数。

### 5.5 加性操作符

加法运算符（`+`）是最常见的运算符，用来求两个数值的和。JavaScript 允许非数值的相加。`+` 后面若是字符串则进行字符串拼接。

加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为**重载（overload）**。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。

除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。

> 每个加法操作都是独立的。

### 5.6 关系操作符

小于(`<`)、大于(`>`)、小于等于(`<=`)和大于等于(`>=`)这几个关系操作符用于对两个值比较，返回一个布尔值。

遇到非数值操作数时也会进行数据类型转换，规则：

---

- 都是字符串：比较字符串对应的字符编码值
- 其他，转换数值，再比较
- 对象，调用 `valueOf()` 方法

---

### 5.7 相等操作符

#### 5.7.1 相等和不相等

用 `"=="` 判断两个值是否相等，会默认进行数据转换（通常称为强制转型），变成同一种数据类型再比较；

在转换不同的数据类型时，相等和不相等操作符遵循以下基本规则：

- 1.布尔、字符串：转换为数值再比较(都是字符串则比较 Unicode 马店)；

---

- 2.`NaN` 与任何类型值比较都是 false；`null` 不与其他数据类型相等（除了自身和 `undefined`）；`undefined` 不与其他数据类型相等（除了自身和 `null`）；

---

- 3.两个都是对象，比较是不是同一个对象，看引用地址是否指向同一个对象；

---

- 4.对象 & 非对象，调用对象的 `valueOf()` 方法，用得到的基本类型值再按前面规则进行比较；
  - 注意：对象 & 字符串，先将对象转换为字符串，再进行比较

---

#### 5.7.2 全等和不全等

用 `===` 绝对相等进行两个数据比较；数据类型不同绝对不等（`NaN` 不与任何数据相等）；

> 特殊情况：
> `null` `===` `undefined` //false
> `null` `===` `null` //true
> `undefined` `===` `undefined` //true

### 5.8 条件操作符(`?:`)

遵循与 Java 中的条件操作符相同的语法形式。

`var max = (num1 > num2) ? num1 : num2;`

通常来说，三元条件表达式与 `if...else` 语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，`if...else` 是语句，没有返回值；三元条件表达式是表达式，具有返回值。

### 5.9 赋值操作符(`=`)

简单的**赋值操作符（Assignment Operators）**由等于号表示，起作用就是把右侧的值赋给左侧的变量。

若在等于号前面添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作符。

> 使用这些操作符主要是简化赋值操作，不会带来任何性能提升。

### 5.10 逗号操作符

使用逗号操作符可以在一条语句中执行多个操作，用于声明多个变量，除此之外，逗号操作符还可以赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项。

### 5.11 `void` 运算符

`void` 运算符的作用是执行一个表达式，然后不返回任何值，或者说返回 `undefined`。

```javascript
void 0; // undefined
void 0; // undefined
```

上面是 `void` 运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为 `void` 运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，`void 4 + 7` 实际上等同于 `(void 4) + 7`。

这个运算符的主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。

请看下面的代码。

```javascript
<script>
function f() {
  console.log('Hello World');
}
</script>
<a href="http://example.com" onclick="f(); return false;">点击</a>
```

上面代码中，点击链接后，会先执行 `onclick` 的代码，由于 `onclick` 返回 false，所以浏览器不会跳转到 `example.com`。

`void` 运算符可以取代上面的写法。

`<a href="javascript: void(f())">文字</a>`

下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。

```javascript
<a href0="javascript: void(document.form.submit())">提交</a>
```

### 5.12 运算顺序

#### 5.12.1 优先级

JavaScript 各种**运算符优先级别（Operator Precedence）**是不一样的。优先级高的运算符先执行，优先级低的运算符后执行。

#### 5.12.2 圆括号的作用

圆括号（`()`）可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算。

运算符的优先级别十分繁杂，且都是硬性规定，因此建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要。

顺便说一下，圆括号不是运算符，而是一种**语法结构**。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数。

> 注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级。

函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。

```javascript
function f() {
  return 1;
}

f; // function f(){return 1;}
f(); // 1
```

> 圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错。

#### 5.12.3 左结合与右结合

对于优先级别相同的运算符，大多数情况，计算顺序总是从左到右，这叫做运算符的**左结合（left-to-right associativity）**，即从左边开始计算。

但是少数运算符的计算顺序是从右到左，即从右边开始计算，这叫做运算符的**右结合（right-to-left associativity）**。其中，最主要的是赋值运算符（`=`）和三元条件运算符（`?:`）。

```javascript
w = x = y = z;
q = a ? b : c ? d : e ? f : g;
```

上面代码的运算结果，相当于下面的样子。

```javascript
w = x = y = z;
q = a ? b : c ? d : e ? f : g;
```