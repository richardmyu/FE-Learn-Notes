# 字符集

JavaScript 程序是用 Unicode 字符集编写的。Unicode 是 ASCII 和 Latin-1 的超集，并支持地球上几乎所有在用的语言。ES5 要求 JavaScript 必须支持 Unicode 3 及后续版本。

在有些计算机硬件和软件里，无法显示或输入 Unicode 字符全集。未来支持那些使用老旧技术的程序员，JavaScript 定义了一种特殊序列，使用 6 个 ASCII 字符来代表任意 16 位 Unicode 内码。这些 Unicode 转义序列均以 `\u` 为前缀，其后跟随 4 个十六进制（使用数字一级大小写的字母 A-F 表示）。这种 Unicode 转义写法可以使用 JavaScript 字符串直接量、正则表达式直接量和标识符中（关键字除外）。Unicode 转义写法也可以出现在注释周中，但是 JavaScript 会忽视，只是被当成上下文的 ASCII 字符处理，而不会被解析为对应的 Unicode 字符。

- **标准化**

Unicode 允许使用多种方法对同一个字符进行编码。Unicode 标准为所有字符定义了一个首选的编码格式，并给出了一个标准化的处理方式将文本转换为一种适合比较的标准格式，JavaScript 会认为它正在解析的程序代码已经是这种标准格式，不会再对其标识符、字符串或正则表达式作标准化处理。

## Unicode

Unicode（中文：万国码、国际码、统一码、单一码）是电脑科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。

在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。

在表示一个 Unicode 的字元时，通常会用“U+”然后紧接着一组十六进位的数字来表示这一个字元。在基本多文种平面（英文：Basic Multilingual Plane，简写 BMP。又称为“零号平面”、plane 0）里的所有字元(最前面的 65536 个字符位)，要用四个数字或大小写字母（即两个 byte，共 16 bit，例如 U+4AE0，共支持六万多个字符），即 `U+0000` 到 `U+FFFF`；在零号平面以外的字元则需要使用五个或六个数字或大小写字母，也称为辅助平面（缩写 SMP），码点范围从 `U+010000` 一直到 `U+10FFFF`。

### 编码方式

目前实际应用的统一码版本，使用 16 位的编码空间。也就是每个字符占用 2 个字节。这样理论上一共最多可以表示 2^16（即 65536）个字符。基本满足各种语言的使用。实际上目前版本的统一码并未完全使用这 16 位编码，而是保留了大量空间以作为特殊使用或将来扩展。

上述 16 位统一码字符构成基本多文种平面。最新（但未实际广泛使用）的统一码版本定义了 16 个辅助平面，两者合起来至少需要占据 21 位的编码空间，比 3 字节略少。但事实上辅助平面字符仍然占用 4 字节编码空间。

### 实现方式

Unicode 的实现方式不同于编码方式。一个字符的 Unicode 编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对 Unicode 编码的实现方式有所不同。Unicode 的实现方式称为 Unicode 转换格式（Unicode Transformation Format，简称为 UTF）。

### UTF-8

一种变长的编码方法，字符长度从 1 个字节到 4 个字节不等。越是常用的字符，字节越短，最前面的 128 个字符，只使用 1 个字节表示，与 ASCII 码完全相同。

| 编号范围            | 字节 |
| ------------------- | ---- |
| 0x0000 - 0x007F     | 1    |
| 0x0080 - 0x07FF     | 2    |
| 0x0800 - 0xFFFF     | 3    |
| 0x010000 - 0x10FFFF | 4    |

由于 UTF-8 这种节省空间的特性，导致它成为互联网上最常见的网页编码。

### UTF-16

UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。

它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（`U+0000` 到 `U+FFFF`），要么是 4 个字节（`U+010000` 到 `U+10FFFF`）。

于是就有一个问题，当我们遇到两个字节，怎么看出它本身是一个字符，还是需要跟其他两个字节放在一起解读？

在基本平面内，从 `U+D800` 到 `U+DFFF` 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。

具体来说，辅助平面的字符位共有 220 个，也就是说，对应这些字符至少需要 20 个二进制位。UTF-16 将这 20 位拆成两半，前 10 位映射在 `U+D800` 到 `U+DBFF`（空间大小 210），称为**高位**（H），后 10 位映射在 `U+DC00` 到 `U+DFFF`（空间大小 210），称为**低位**（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。

所以，当我们遇到两个字节，发现它的码点在 `U+D800` 到 `U+DBFF` 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 `U+DC00` 到 `U+DFFF` 之间，这四个字节必须放在一起解读。

### UTF-32

最直观的编码方法是，每个码点使用四个字节表示，字节内容一一对应码点。这种编码方法就叫做 UTF-32。比如，码点 0 就用四个字节的 0 表示，码点 597D 就在前面加两个字节的 0。

```js
U+0000 = 0x0000 0000

U+597D = 0x0000 597D
```

- 优点: 转换规则简单直观，查找效率高。
- 缺点: 浪费空间，同样内容的英语文本，它会比 ASCII 编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5 标准就明文规定，网页不得编码成 UTF-32。

### JavaScript

JavaScript 语言采用 Unicode 字符集，但是只支持一种编码方法。这种编码既不是 UTF-16，也不是 UTF-8，更不是 UTF-32。上面那些编码方法，JavaScript 都不用。

JavaScript 用的是 **UCS-2**！

由于 JavaScript 只能处理 UCS-2 编码，造成所有字符在这门语言中都是 2 个字节，如果是 4 个字节的字符，会当作两个双字节的字符处理。JavaScript 的字符函数都受到这一点的影响，无法返回正确结果。

还是以字符 𝌆 为例，它的 UTF-16 编码是 4 个字节的 0xD834 DF06。问题就来了，4 个字节的编码不属于 UCS-2，JavaScript 不认识，只会把它看作单独的两个字符 U+D834 和 U+DF06。前面说过，这两个码点是空的，所以 JavaScript 会认为是两个空字符组成的字符串！

```js
"𝌆".length; //2

"𝌆" === "\u1D306"; //false

"𝌆".charAt(0); //' '

"𝌆".charCodeAt(0); //55348(0xD834)
```

上面代码表示，JavaScript 认为字符 𝌆 的长度是 2，取到的第一个字符是空字符，取到的第一个字符的码点是 0xDB34。这些结果都不正确！

`'𝌆' === '\uD834\uDF06'; //true`

解决这个问题，必须对码点做一个判断，只要落在 `0xD800` 到 `0xDBFF` 的区间，就要连同后面 2 个字节一起读取。类似的问题存在于所有的 JavaScript 字符操作函数。

```js
while (++index < length) {
  // ...
  if (charCode >= 0xd800 && charCode <= 0xdbff) {
    output.push(character + string.charAt(++index));
  } else {
    output.push(character);
  }
}
```

### ES6

ES6，大幅增强了 Unicode 支持，基本上解决了这个问题。

- **正确识别字符**

ES6 可以自动识别 4 字节的码点。因此，遍历字符串就简单多了。

```JS
for (let s of string ) {
  // ...
}
```

但是，为了保持兼容，length 属性还是原来的行为方式。为了得到字符串的正确长度，可以用下面的方式。

`Array.from(string).length`

- **码点表示法**

JavaScript 允许直接用码点表示 Unicode 字符，写法是"反斜杠+u+码点"。

`'好' === '\u597D' // true`

但是，这种表示法对 4 字节的码点无效。ES6 修正了这个问题，只要将码点放在大括号内，就能正确识别。

```js
"𝌆" === "\u1D306"; //false

"𝌆" === "\u{1D306}"; //true
```

- **字符串处理函数**

ES6 新增了几个专门处理 4 字节码点的函数。

- `String.fromCodePoint()`：从 Unicode 码点返回对应字符
- `String.prototype.codePointAt()`：从字符返回对应的码点
- `String.prototype.at()`：返回字符串给定位置的字符

- **正则表达式**

ES6 提供了 u 修饰符，对正则表达式添加 4 字节码点的支持。

```js
/^.$/.test("𝌆"); //false
/^.$/u.test("𝌆"); //true
```

- **Unicode 正规化**

有些字符除了字母以外，还有附加符号。比如，汉语拼音的 Ǒ，字母上面的声调就是附加符号。对于许多欧洲语言来说，声调符号是非常重要的。

Unicode 提供了两种表示方法。一种是带附加符号的单个字符，即一个码点表示一个字符，比如 Ǒ 的码点是 U+01D1；另一种是将附加符号单独作为一个码点，与主体字符复合显示，即两个码点表示一个字符，比如 Ǒ 可以写成 O（U+004F） + ˇ（U+030C）。

```js
// 方法一
"\u01D1";
// 'Ǒ'

// 方法二
"\u004F\u030C";
// 'Ǒ'
```

这两种表示方法，视觉和语义都完全一样，理应作为等同情况处理。但是，JavaScript 无法辨别。

`'\u01D1'==='\u004F\u030C'; //false`

ES6 提供了 normalize 方法，允许"Unicode 正规化"，即将两种方法转为同样的序列。

`'\u01D1'.normalize() === '\u004F\u030C'.normalize(); // true`

### UCS-2

互联网还没出现的年代，曾经有两个团队，不约而同想搞统一字符集。一个是 1988 年成立的 Unicode 团队，另一个是 1989 年成立的 UCS 团队。等到他们发现了对方的存在，很快就达成一致：世界上不需要两套统一字符集。

1991 年 10 月，两个团队决定合并字符集。也就是说，从今以后只发布一套字符集，就是 Unicode，并且修订此前发布的字符集，UCS 的码点将与 Unicode 完全一致。

UCS 的开发进度快于 Unicode，1990 年就公布了第一套编码方法 UCS-2，使用 2 个字节表示已经有码点的字符。（那个时候只有一个平面，就是基本平面，所以 2 个字节就够用了。）UTF-16 编码迟至 1996 年 7 月才公布，明确宣布是 UCS-2 的超集，即基本平面字符沿用 UCS-2 编码，辅助平面字符定义了 4 个字节的表示方法。

两者的关系简单说，就是 UTF-16 取代了 UCS-2，或者说 UCS-2 整合进了 UTF-16。所以，现在只有 UTF-16，没有 UCS-2。

那么，为什么 JavaScript 不选择更高级的 UTF-16，而用了已经被淘汰的 UCS-2 呢？

答案很简单：非不想也，是不能也。因为在 JavaScript 语言出现的时候，还没有 UTF-16 编码。

1995 年 5 月，Brendan Eich 用了 10 天设计了 JavaScript 语言；10 月，第一个解释引擎问世；次年 11 月，Netscape 正式向 ECMA 提交语言标准（整个过程详见《JavaScript 诞生记》）。对比 UTF-16 的发布时间（1996 年 7 月），就会明白 Netscape 公司那时没有其他选择，只有 UCS-2 一种编码方法可用！

参考：

[Unicode 与 JavaScript 详解](http://www.ruanyifeng.com/blog/2014/12/unicode.html)

[Unicode](https://www.wikiwand.com/zh-hans/Unicode)

[UTF-8](https://www.wikiwand.com/zh-hans/UTF-8)

[UTF-16](https://www.wikiwand.com/zh-hans/UTF-16)

[Javascript 与字符编码](https://github.com/SamHwang1990/blog/issues/2)

[Javascript 有个 Unicode 的天坑](http://www.alloyteam.com/2016/12/javascript-has-a-unicode-sinkhole/)

[js 文件引用编码方式](http://caibaojian.com/js-charset.html)

[通过 javascript 进行 UTF-8 编码](https://segmentfault.com/a/1190000005794963)

[javascript 基础之字符集与编码](https://segmentfault.com/a/1190000013089916)
