# 操作符

ESMAScript 操作符与众不同之处在于，它们能够适用于很多值。在应用于对象时，相应的操作符通常都会调用对象的 `valueOf()` 和（或） `toString()`方法，以便取得可以操作的值。

## 1. 一元操作符

只能操作一个值的操作符就做 **一元操作符**。

### 1.1. 递增和递减操作符

直接借鉴自 C，各有两个版本：前置型和后置型。

```js
// 前置型 语句求值之前，变量已变
let age = 18;
++age; //19
age; //19

// 后置型 语句求值之后，变量才变
let year = 2018;
year--; //2018
year; //2017
```

执行前置递增或递减时，变量的值都是在语句被求值以前改变的（在计算机科学领域，这种情况通常被称作 **副效应**），即会先进行自增/自减操作，再返回变量操作后的值；

而后置型递增或递减，是在包含它们的语句被求值之后才执行的，即先返回变量操作前的值，再进行自增/自减操作。

这四个操作符对任何值都适用。遵循规则：

---

- 1). 包含有效数字字符的字符串：先转换为数值，再执行增减操作；

- 2). 不包含有效数字字符的字符串：`NaN`；

- 3).`true/false`：先转换为数值，再执行增减操作；

- 4). 浮点数值：直接执行增减操作；

- 5). 对象：先调用对象的 `valueOf()` 方法，以获取一个可以操作的数值，然后遵循以上规则；若得到 `NaN`，则再调用 `toString()` 方法后再应用上述规则。

---

> 注意：`++` 是数值运算，不完全同于 `+=` ；后者可以进行字符串的拼接；

### 1.2. 一元加减操作符

`"+"` 放在数值前面，对数值不产生任何影响；但是在非数值变量前面，会像 `Number()` 转型函数一样对这个值执行转换。

`"-"` 主要用于表示负数。应用于非数值变量时，遵循 `"+"` 相同的操作，再将得到的数值转为负数。

```js
let a = 3;
let b = false;
let c = [];
let d = {};
let e = '2s';

console.log(+a, -a); // 3 -3
console.log(+b, -b); // 0 -0
console.log(+c, -c); // 0 -0
console.log(+d, -d); // NaN NaN
console.log(+e, -e); // NaN NaN
```

## 2. 位操作符

位操作符用于最基本的层次上，即按内存中表示数值的位来操作数值。这 4 运算符（`&`、`|`、`^`、`~`）都是对操作数的每个位进行布尔运算（1=true, 0=false）。

ECMAScript 中所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值；而是将 64 位值转换为 32 位的整数，这会忽略原格式中的小数部分和任何超过 32 位的二进制位；然后执行操作，最后转换为 64 位值。

> **所有的位运算都只对整数有效。** 遇到小数时，会将小数部分舍去，只保留整数部分。所以，将一个小数与 0 进行二进制或运算，等同于对该数去除小数部分，即取整数位。

对于有符号的整数，32 位的前 31 位用于表示整数的值，第 32 位表示数值的符号：0 表示正数，1 表示负数，这个表示符号的位叫做 **符号位**。符号位决定其他为数值的格式。

其中正数以纯二进制格式表示，31 位中的每一位都表示 2 的幂。没用到的位以 0 填充。负数同样以二进制码存储，但用的是 **二进制补码**。

二进制补码：

1). 先求这个数的绝对值的二进制码；

2). 再求二进制码的反码（0/1 替换 1/0）；

3). 将得到的二进制反码加 1；

> 在处理有符号整数时，是不能访问 31 位的。???

以上 64 位转换 32 位的过程，会导致一个严重的副效应：在对特殊的 `NaN` 和 `Infinity` 值应用位操作时，这两个值都会被当做 0 来处理。如果对非数值应用位操作，会先使用 `Number()` 函数将该值转换为一个数值（自动），然后再进行位操作，得到一个数值。

### 2.1. 按位非 NOT（`~`）

运算符（`~`）将每个二进制位都变为相反值（0 变为 1，1 变为 0）。根据 JavaScript 中带符号的整数的表示方法，对一个值使用 `~` 运算符相当于改变它的符号并减去 1。

```js
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
NOT = 1111 1111 1111 1111 1111 1111 1111 1100
    = -4
```

按位非遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次按位非，能达到取整效果，是所有【取整方法中最快】的一种。

```js
let a = 3.14159;

console.log(a); // 3.14159
console.log(~a); // -4
console.log(~~a); // 3
```

> 按位非是 ECMAScript 操作符中少数几个与二进制计算有关的操作符之一。
> 按位非是在数值表示的最底层执行操作，因此速度很快。

### 2.2. 按位与 AND（`&`）

位运算符 `&` 对它的整形操作数逐位执行布尔与 (AND) 操作。只有两个操作数中对应的位都是 1，结果中这一位才是 1。

```js
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
    = 1
```

### 2.3. 按位或 OR（`|`）

位运算符 `|` 对它的整形操作数逐位执行布尔或 (OR) 操作。如果其中一个操作数相应的位为 1，或者两个操作数相应位都是 1，结果中这一位次就是 1。

```js
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
OR  = 0000 0000 0000 0000 0000 0000 0001 1011
    = 27
```

### 2.4. 按位异或 XOR（`^`）

位运算符 `^` 对它的整形操作数逐位执行布尔异与 (XOR) 操作。异或指第一个操作数为 true 或第二个操作数为 true，但两者不能同时为 true。如果两个操作数中有且仅有一个相应位为 1，则结果中这一位就为 1。

```js
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0001 1010
    = 26
```

“异或运算”有一个特殊运用，连续对两个数 `a` 和 `b` 进行三次异或运算，`a^=b; b^=a; a^=b;`，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。这是【互换两个变量的值的最快】方法。

```js
let a = 3;
let b = 4;

console.log(a, b); // 3 4
// [a, b] = [b, a];
a ^= b;
b ^= a;
a ^= b;
console.log(a, b); // 4 3
```

### 2.5. 左移（`<<`）

将数值的所有位向左移动指定的位数，移动的位数是 0 - 31 之间的一个整数。左移操作会以 0 填充空位；且不会影响操作数的符号。

如果左移 0 位，就相当于将该数值转为 32 位整数，等同于取整，对于正数和负数都有效。

```js
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
<<1 = 0000 0000 0000 0000 0000 0000 0000 0110
    = 6
```

> a << b <==> a * Math.pow(2, b)

### 2.6.（有符号）右移（`>>`）

表示将一个数的二进制值向右移动指定的位数，移动的位数是 0 - 31 之间的一个整数。有符号的右移操作会以符号位的值填充空位，以便保持结果的符号与原操作数一致。如果第一个操作数是正数，用 0 填补高位；如果是负数，则用 1 填补高位。

```js
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
----------------------------------------------
>>1 = 0000 0000 0000 0000 0000 0000 0000 0001
    = 1
```

右移运算可以模拟 2 的整除运算。

```js
5 >> 1;
// 2
// 相当于 5 / 2 = 2

21 >> 2;
// 5
// 相当于 21 / 4 = 5
```

> a >> b <==> Math.floor(a / Math.pow(2, b))

### 2.7. 无符号的右移（`>>>`）

将数值的所有 32 位都向右移。对正数来说，有、无符号的右移一样，但对于负数来说却是不一样的：

- 1). 无符号右移是以 0 来填充的；

- 2). 无符号的右移会把负数的二进制码当成正数的二进制码，而且负数以其绝对值的二进制补码形式表示，因此导致右移的结果非常大。

查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。

`-1 >>> 0 // 4294967295`

例子：位运算符可以用作设置对象属性的开关。

假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。

```js
let FLAG_A = 1; // 0001
let FLAG_B = 2; // 0010
let FLAG_C = 4; // 0100
let FLAG_D = 8; // 1000
```

然后，就可以用 `&` 运算检验，当前设置是否打开了指定开关。

```js
let flags = 5; // 二进制的 0101

if (flags & FLAG_C) {
  // ...
}
// 0101 & 0100 => 0100 => true
```

上面代码检验是否打开了开关 C。如果打开，会返回 `true`，否则返回 `false`。

现在假设需要打开 A、B、D 三个开关，我们可以构造一个掩码变量。

```js
let mask = FLAG_A | FLAG_B | FLAG_D;
// 0001 | 0010 | 1000 => 1011
```

上面代码对 A、B、D 三个变量进行 `|` 运算，得到掩码值为二进制的 `1011`。

有了掩码，`|` 运算可以确保打开指定的开关。

`flags = flags | mask;`

`&` 运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。

`flags = flags & mask;`

`^` 运算可以切换当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。

`flags = flags ^ mask;`

`~` 运算可以翻转当前设置，即原设置为 0，运算后变为 1；原设置为 1，运算后变为 0。

`flags = ~flags;`

## 3. 布尔操作符

在一门编程语言中，布尔操作符的重要性堪比相等操作符。

### 3.1. 逻辑非 (`!`)

可以应用于任何类型值；无论何种类型，都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再取反。

### 3.2. 逻辑与 (`&&`)

**逻辑与操作属于短路操作符**，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与而言，如果第一个操作数为 false，则无论第二个操作数是什么值，都不能是 true。总结为：第一个为 true，返回第二个操作数；第一个为 false，返回第一个操作数，且不再对第二个运算子求值。

### 3.3. 逻辑或 (`||`)

同逻辑与，逻辑或也是短路操作符。总结：第一个为 true，返回第一个操作数，且不再对第二个运算子求值；第一个为 false，返回第二个操作数。

> 这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为**短路（short-cut）**。

## 4. 乘性操作符

ECMAScript 定义了 3 个乘性操作符。这些操作符与 Java、C 或者 Perl 中 相应操作符用途类似，只不过在操作数是非数值的情况下会执行自动的数据转换（`Number()`）。

### 4.1. 乘法 (`*`)

语法类似 C，处理特殊值时，特殊规则：

---

- 都是数值：常规执行，超过范围返回 `Infinity` 或 `-Infinity`
- `Infinity` 和 0：返回 `NaN`
- `Infinity` 和非 0：返回 `Infinity` 或 `-Infinity`
- `Infinity` 与 `Infinity`/`-Infinity`：返回 `Infinity`/`-Infinity`

---

### 4.2. 除法 (`/`)

同乘法操作符，处理特殊值时，特殊规则：

---

- 都是数值：常规执行，超过范围返回 `Infinity` 或 `-Infinity`
- `Infinity` 与 `Infinity`/`-Infinity`：返回 `NaN`
- `Infinity` 除非 0 有限数：返回 `Infinity` 或 `-Infinity`
- 0 与 0：返回 `NaN`
- 0 与 非 0：返回 0
- 非 0 除 0：返回 `Infinity`

---

### 4.3. 求模/取余 (`%`)

处理特殊值时，特殊规则：

---

- 都是数值：常规执行
- `Infinity` 除任何：返回 `NaN`
- 任何除 0：返回 `NaN`
- 非 0 有限数除 `Infinity`：返回被除数
- 0 除非 0：返回 0

---

> 需要注意的是，运算结果的正负号由第一个运算子的正负号决定。

### 4.4. 指数 (`**`)

指数运算符（`**`）完成指数运算，前一个运算子是底数，后一个运算子是指数。

## 5. 加性操作符

加法运算符（`+`）是最常见的运算符，用来求两个数值的和。JavaScript 允许非数值的相加。`+` 后面若是字符串则进行字符串拼接。

加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为**重载（overload）**。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。

除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。

> 每个加法操作都是独立的。

## 6. 关系操作符

小于 (`<`)、大于 (`>`)、小于等于 (`<=`) 和大于等于 (`>=`) 这几个关系操作符用于对两个值比较，返回一个布尔值。

遇到非数值操作数时也会进行数据类型转换，规则：

---

- 都是字符串：比较字符串对应的字符编码值
- 其他，转换数值，再比较
- 对象，调用 `valueOf()` 方法

---

## 7. 相等操作符

### 7.1. 相等和不相等

用 `"=="` 判断两个值是否相等，会默认进行数据转换（通常称为强制转型），变成同一种数据类型再比较；

在转换不同的数据类型时，相等和不相等操作符遵循以下基本规则：

- 1. 布尔、字符串：转换为数值再比较（都是字符串则比较 Unicode 码）；
>
- 2.`NaN` 与任何类型值比较都是 false；`null` 不与其他数据类型相等（除了自身和 `undefined`）；`undefined` 不与其他数据类型相等（除了自身和 `null`）；
>
- 3. 两个都是对象，比较是不是同一个对象，看引用地址是否指向同一个对象；
>
- 4. 对象 & 非对象，调用对象的 `valueOf()` 方法，用得到的基本类型值再按前面规则进行比较；
  - 注意：对象 & 字符串，先将对象转换为字符串，再进行比较

### 7.2. 全等和不全等

用 `===` 绝对相等进行两个数据比较；数据类型不同绝对不等（`NaN` 不与任何数据相等）；

> 特殊情况：
> `null` `===` `undefined` //false
> `null` `===` `null` //true
> `undefined` `===` `undefined` //true

## 8. 条件操作符 (`?:`)

遵循与 Java 中的条件操作符相同的语法形式。

`let max = (num1 > num2) ? num1 : num2;`

通常来说，三元条件表达式与 `if...else` 语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，`if...else` 是语句，没有返回值；三元条件表达式是表达式，具有返回值。

## 9. 赋值操作符 (`=`)

简单的**赋值操作符（Assignment Operators）**由等于号表示，起作用就是把右侧的值赋给左侧的变量。

若在等于号前面添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作符。

> 使用这些操作符主要是简化赋值操作，不会带来任何性能提升。

## 10. 逗号操作符

使用逗号操作符可以在一条语句中执行多个操作，用于声明多个变量，除此之外，逗号操作符还可以赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项。

## 11.`void` 运算符

`void` 运算符的作用是执行一个表达式，然后不返回任何值，或者说返回 `undefined`。

```js
void 0; // undefined
```

上面是 `void` 运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号。因为 `void` 运算符的优先性很高，如果不使用括号，容易造成错误的结果。比如，`void 4 + 7` 实际上等同于 `(void 4) + 7`。

这个运算符的主要用途是浏览器的书签工具（bookmarklet），以及在超级链接中插入代码防止网页跳转。

请看下面的代码。

```js
<script>
function f() {
  console.log('Hello World');
}
</script>
<a href="http://example.com" onclick="f(); return false;">点击</a>
```

上面代码中，点击链接后，会先执行 `onclick` 的代码，由于 `onclick` 返回 false，所以浏览器不会跳转到 `example.com`。

`void` 运算符可以取代上面的写法。

`<a href="javascript: void(f())">文字</a>`

下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。

```js
<a href0="javascript: void(document.form.submit())">提交</a>
```

## 12. 运算顺序

### 12.1. 优先级

大多数运算符都是由标点符号表示的，如 `+` 和 `-`；而另外一些运算符则是由关键字表示的，如 `delete` 和 `instanceof`。关键字运算符和标点符号所表示的运算符一样都是正规的运算符，它们的语法都非常言简意赅。

JavaScript 各种 **运算符优先级别**（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行。

| 运算符                           | 操作                         | 结合性 | 操作数 | 类型                | 优先级 |
| -------------------------------- | ---------------------------- | :----: | :----: | ------------------- | :----: |
| `++`                             | 前/后增量                    |   R    |   1    | `lval->num`         |   1    |
| `--`                             | 前/后减量                    |   R    |   1    | `lval->num`         |   1    |
| `-`                              | 求反                         |   R    |   1    | `num->num`          |   1    |
| `+`                              | 转换为数字                   |   R    |   1    | `num->num`          |   1    |
| `~`                              | 按位求反                     |   R    |   1    | `int->int`          |   1    |
| `！`                             | 逻辑非                       |   R    |   1    | `bool->bool`        |   1    |
| `delete`                         | 删除属性                     |   R    |   1    | `lval->bool`        |   1    |
| `typeof`                         | 检测操作数类型               |   R    |   1    | `any->str`          |   1    |
| `void`                           | 返回 `undefined` 值          |   R    |   1    | `any->undefined`    |   1    |
|                                  |                              |        |        |                     |        |
| `*`、`/`、`%`                    | 乘、除、取余                 |   L    |   2    | ``num,num->num``    |   2    |
|                                  |                              |        |        |                     |
| `+`、`-`                         | 加、减                       |   L    |   2    | `num,num->num`      |   3    |
| `+`                              | 字符串拼接                   |   L    |   2    | `str,str->str`      |   3    |
|                                  |                              |        |        |                     |        |
| `<<`                             | 左移位                       |   L    |   2    | `int,int->int`      |   4    |
| `>>`                             | 有符号右移位                 |   L    |   2    | `int,int->int`      |   4    |
| `>>>`                            | 无符号右移位                 |   L    |   2    | `int,int->int`      |   4    |
|                                  |                              |        |        |                     |        |
| `<`、`<=` 、`>`、`>=`            | 比较数字大小                 |   L    |   2    | `num,num->num`      |   5    |
| `<`、`<=` 、`>`、`>=`            | 比较字母顺序                 |   L    |   2    | `str,str->str`      |   5    |
| `instanceof`                     | 测试对象类                   |   L    |   2    | `obj,func->bool`    |   5    |
| `in`                             | 测试属性是否存在             |   L    |   2    | `str,obj->bool`     |   5    |
|                                  |                              |        |        |                     |        |
| `==`                             | 相等                         |   L    |   2    | `any,any->bool`     |   6    |
| `!=`                             | 不相等                       |   L    |   2    | `any,any->bool`     |   6    |
| `===`                            | 全等                         |   L    |   2    | `any,any->bool`     |   6    |
| `!==`                            | 不全等                       |   L    |   2    | `any,any->bool`     |   6    |
|                                  |                              |        |        |                     |        |
| `&`                              | 按位与                       |   L    |   2    | `int,int->int`      |   7    |
|                                  |                              |        |        |                     |        |
| '`^`'                            | 按位异或                     |   L    |   2    | `int,int->int`      |   8    |
|                                  |                              |        |        |                     |        |
| `|`                              | 按位或                       |   L    |   2    | `int,int->int`      |   9    |
|                                  |                              |        |        |                     |        |
| `&&`                             | 逻辑与                       |   L    |   2    | `any,any->any`      |   10   |
|                                  |                              |        |        |                     |        |
| `||`                             | 逻辑与                       |   L    |   2    | `any,any->any`      |   11   |
|                                  |                              |        |        |                     |        |
| `?:`                             | 条件运算符                   |   R    |   3    | `bool,any,any->any` |   12   |
|                                  |                              |        |        |                     |        |
| `=`                              | 变量赋值                     |   R    |   2    | `lval,any->any`     |   13   |
| `*=` 、`/=` 、`%=` 、`+=` 、`-=` | 运算且赋值                   |   R    |   2    | `lval,any->any`     |   13   |
| `&=` 、`^=` 、`|=`               | 运算且赋值                   |   R    |   2    | `lval,any->any`     |   13   |
| `<<=` 、`>>=` 、`>>>=`           | 运算且赋值                   |   R    |   2    | `lval,any->any`     |   13   |
|                                  |                              |        |        |                     |        |
| `,`                              | 忽略第一个操作数，返回第二个 |   L    |   2    | `any,any->any`      |   14   |

> 1. 结合性：L（从左往右）或 R（从右往左）；
> 2. 类型：表示期望操作数类型；
> 3.`lval` 是 `left-value` 的简写，意为 “左值”；
> 4. 属性访问表达式和调用表达式，以及函数调用的优先级高于以上任何运算符。

### 12.2. 左值

**左值**（lvalue）只一个古老的术语，指“表达式只能出现在赋值运算符的左侧”。在 JavaScript 中，变量、对象属性和数组元素都是左值。ECMAScript 规范允许内置函数返回一个左值，但自定义的函数则不能返回左值。

### 12.3. 圆括号的作用

圆括号（`()`）可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算。

运算符的优先级别十分繁杂，且都是硬性规定，因此建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要。

顺便说一下，圆括号不是运算符，而是一种**语法结构**。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数。

> 注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级。

函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数。

```js
function f() {
  return 1;
}

f; // function f(){return 1;}
f(); // 1
```

> 圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错。

### 12.4. 左结合与右结合

对于优先级别相同的运算符，大多数情况，计算顺序总是从左到右，这叫做运算符的 **左结合**（left-to-right associativity），即从左边开始计算。

但是少数运算符的计算顺序是从右到左，即从右边开始计算，这叫做运算符的 **右结合**（right-to-left associativity）。其中，最主要的是赋值运算符（`=`）和三元条件运算符（`?:`）。

```js
w = x = y = z;
q = a ? b : c ? d : e ? f : g;
```

上面代码的运算结果，相当于下面的样子。

```js
w = x = y = z;
q = a ? b : c ? d : e ? f : g;
```

### 12.5. 运算顺序

运算符的优先级和结合性规定了它们在复杂的表达式中的运算顺序，但并没有规定子表达式的计算过程中的运算顺序。总的来说，JavaScript 是严格按照从左往右的顺序来计算表达式的。只有在任何一个表达式具有副作用而影响到其他表达式的时候，其求值顺序才会和看上去有所不同。
