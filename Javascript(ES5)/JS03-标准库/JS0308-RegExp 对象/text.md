### 8.RegExp 对象

#### 8.1.概述

**正则表达式（regular expression）**是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本。JavaScript 的正则表达式体系是参照 Perl 5 建立的。

ECMAScript 通过 `RegExp` 类型来支持正则表达式。使用下面类似 Perl 的语法，就可以创建一个正则表达式。

`var expression = /pattern/flags;`

其中的**模式（pattern）**部分可以是任何简单或复杂的正则表达式，可以包括字符类。限定符、分组、先前查找以及反向引用。每个正则表达式都可以带有一个或多个**标志（flags）**，用以标明正则表达式的行为。

`var reg = new RegExp('zxc','g');`

上面两种写法是等价的，它们的主要区别是，第一种方法在引擎编译代码时，就会新建正则表达式，第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观，所以实际应用中，基本上都采用字面量定义正则表达式。

`RegExp` 构造函数还可以接受第二个参数，表示修饰符。

#### 8.2.常见元字符

大部分字符在正则表达式中，就是字面的含义，比如 `/a/` 匹配 a，`/b/` 匹配 b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的 a 和 b），那么它们就叫做**字面量字符（literal characters）**。

还有一部分字符有特殊的含义，不代表字面的意思，称之为**元字符（metacharacters)**。一个元字符只能匹配一个字符。

> 什么都不写是注释，有空格也算正则；

与其它语言的正则表达式类似，模式中使用元字符都必须转义，因为这些元字符在正则表达式中都有一种或多种特殊用途：
`( [ { \ ^ $ | ) ? * + . ] }`

需要特别注意的是，如果使用 `RegExp` 方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。

- 元字符表：

|   字符   | 作用                                                                           |
| :------: | ------------------------------------------------------------------------------ |
|   `.`    | 匹配换行 `\n`、回车 `\r`、行分割符 `\u2028`、段分隔符 `\u2029` 以外任何单字符  |
|   `\\`   | 转义作用，将下一个普通字符标记为特殊值字符或将特殊字符转义成普通字符；后向引用 |
|   `^`    | 匹配字符串的起始字符；若设置了 Multiline 模式，也匹配 `\n` 或 `\r` 之后的字符  |
|   `$`    | 匹配字符串的终止字符；若设置了 Multiline 模式，也匹配 `\n` 或 `\r` 之前的字符  |
|   `\d`   | 匹配一个数字字符，等价于 `[0-9]`                                               |
|   `\D`   | 匹配一个非数字字符，等价于 `[^0-9]`                                            |
|   `\w`   | 匹配包括下划线的单词字符，等价于 `[A-Za-z0-9_]`                                |
|   `\W`   | 匹配任何非单词字符，等价于 `[^A-Za-z0-9_]`                                     |
|   `\b`   | 匹配一个单词边界                                                               |
|   `\B`   | 匹配一个非边界                                                                 |
|   `\s`   | 匹配空白符,包括空格、制表符等等，等价于 `[\f\n\r\t\v]`                         |
|   `\S`   | 匹配任何非空白符，等价于 `[^\f\n\r\t\v]`                                       |
|   `\f`   | 匹配换页符（`U+000C`）                                                         |
|   `\n`   | 匹配换行符                                                                     |
|   `\r`   | 匹配回车符                                                                     |
|   `\t`   | 匹配制表符（`U+0009`）                                                         |
|   `\v`   | 匹配垂直制表符（`U+000B`）                                                     |
|   `\0`   | 匹配 `null` 字符（`U+0000`）                                                   |
|  `\xhh`  | 匹配一个以两位十六进制数（`\x00`-`\xFF`）表示的字符                            |
| `\uhhhh` | 匹配一个以四位十六进制数（`\u0000`-`\uFFFF`）表示的 Unicode 字符               |
|  `\cX`   | 表示 `Ctrl-[X]`，其中的 X 是 A-Z 之中任一个英文字母，用来匹配控制字符          |
|  `[\b]`  | 匹配退格键(`U+0008`)，不要与 `\b` 混淆                                         |

> 注意，对于码点大于 `0xFFFF` 字符，点字符不能正确匹配，会认为这是两个字符。
> 通常，正则表达式遇到换行符（`\n`）就会停止匹配。

#### 8.3.量词元字符

使用时，是加在字符后面，表示前面字符出现的次数；

|  字符   | 作用                                                                        |
| :-----: | --------------------------------------------------------------------------- |
|   `*`   | 匹配零次或者多次                                                            |
|   `+`   | 匹配一次或者多次                                                            |
|   `?`   | 匹配零次或一次                                                              |
|  `{n}`  | n 是非负整数，匹配确定的 n 次                                               |
| `{n,}`  | n 是非负整数，至少匹配 n 次                                                 |
| `{n,m}` | n,m 是非负整数，n<=m,匹配至少 n 次，至多 m 次；（逗号和数字之间不能有空格） |

```javascript
//匹配电话号码
/^1\d{10}$/

//小数
/^-?0\.\d+$/
/^-?\d+\.\d+$/

//匹配汉字
/[\u4e00-\u9fa5]/
```

#### 8.4.字符类

字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。

|   字符   | 名                                       | 作用                               |
| :------: | ---------------------------------------- | ---------------------------------- |
|  `x|y`   | 选择符                                   | 匹配 x 或 y，左右两边作为整体对待  |
| `[xyz]`  | 字符类                                   | 字符集合，匹配包含的任意字符       |
| `[^xyz]` | 脱字符                                   | 负值字符集合，匹配未包含的任意字符 |
| `[a-z]`  | 连字符                                   | 字符范围，匹配指定范围内任意字符   |
| `[^a-z]` | 负值字符范围，匹配任何不在指定范围的字符 |

> 在中括号内，所有字符代表本身的意义，除了 `^`（非）和 `-`（至）以及 `\`（转意）
> 连字号用在方括号之中，才表示连续的字符序列。把 `-` 放在最后面，即可表示其本身意义；
> 注意，脱字符 `^` 只有在字符类的第一个位置才有特殊含义，否则就是字面含义。如果方括号内没有其他字符，即只有 `[^]`，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（`.`）是不包括换行符的。

#### 8.5.标志（修饰符）

| 字符  | 作用                                                                                          |
| :---: | --------------------------------------------------------------------------------------------- |
|  `g`  | 表示**全局（global）**模式，即模式将被应用于所有字符串                                        |
|  `i`  | 表示**不区分大小写（case-insensitive）**模式，即在确定匹配项时忽略模式与字符串的大小写        |
|  `m`  | 表示**多行（multiline）**模式，即在达到一行文本末尾还会继续查找下一行中是否存在于模式匹配的项 |

> 加上 m 修饰符以后，`^` 和 `$` 还会匹配行首和行尾，即 `^` 和 `$` 会识别换行符（`\n`）。

```javascript
var re = null,
  i;
for (i = 0; i < 5; i++) {
  re = /cat/g;
  console.log(re.test("catcat"));
}
for (i = 0; i < 5; i++) {
  re = new RegExp("cat", "g");
  console.log(re.test("catcat"));
}
```

在第一个循环中，即使是循环体指定，但实际上只为 `/cat/` 创建了一个 `RegExp` 实例。由于实例属性不会重置，所以在循环中再次调用函数的时候会失败。这是因为第一次调用找到了匹配项，第二次匹配从上次匹配字符后面的字符开始，没有 `RegExp` 实例所以无法匹配。

在第二个循环中，`RegExp` 构造函数在每次循环中都会创建正则表达式，因为每次迭代都会创建新的 `RegExp` 实例，所以每次调用都会有返回值。

ECMAScript5 明确规定，使用正则表达式字面量必须像直接调用 `RegExp` 构造函数一样，每次都会创建新的 `RegExp` 实例。

#### 8.6.实例属性

正则对象的实例属性分成两类。

一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置,这些属性是只读的。

---

- `RegExp.prototype.ignoreCase`：返回一个布尔值，表示是否设置了 `i` 修饰符。
- `RegExp.prototype.global`：返回一个布尔值，表示是否设置了 `g` 修饰符。
- `RegExp.prototype.multiline`：返回一个布尔值，表示是否设置了 `m` 修饰符。
- `RegExp.prototype.flags`：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。

---

另一类是与修饰符无关的属性，主要是下面两个。

---

- `RegExp.prototype.lastIndex`：返回一个数值，表示下一次开始搜索的位置。该属性可读写，但是只在设置了 `g` 修饰符、进行连续搜索时有意义。
- `RegExp.prototype.source`：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。

---

```javascript
var pattern = /\[bc\]at/gi;
console.log(pattern.global); //true
console.log(pattern.ignoreCase); //true
console.log(pattern.multiline); //false
console.log(pattern.lastIndex); //0
console.log(pattern.source); //\[bc\]at
```

> `RegExp` 实例继承的 `toLocaleString()` 和 `toString()` 方法都会返回正则表达式的字面量，与创建方式无关。`valueOf()` 方法返回正则表达式本身。

#### 8.7.实例方法

##### 8.7.1 `regexp.exec()`

该方法是专门为捕获组而设计的。接收一个参数，即要应用模式的字符串，任何返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回 `null`。

返回的数组虽然是 `Array` 的实例，但是包含两个额外的属性：`index` 和 `input`。其中 `index` 表示匹配项在字符串中的位置，`input` 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是模式中捕获组匹配的字符串（若没有捕获组，则只有一项）。

对于 `exec()` 方法而言，即使在模式中设置了全局标志，但每次也只会返回一个匹配项（当前匹配），`lastIndex` 属性值会增加。在不设置全局标志的情况下，在同一个字符串上多次调用，始终只返回第一个匹配项的信息，`lastIndex` 属性值不会变化。

> IE 在实现 `lastIndex` 属性上有偏差，即使在非全局模式下，也会变化。

```javascript
var str = "name561age21";
var reg1 = /[a-z]+/g,
  reg2 = /[a-z]+/,
  reg3 = /([a-z])+/;
console.log(reg1.exec(str));
//["name", index: 0, input: "name561age21"]

console.log(reg2.exec(str));
//["name", index: 0, input: "name561age21"]

console.log(reg3.exec(str));
//["name", "e", index: 0, input: "name561age21"]
//同一捕获组的匹配项，只返回之后一次的匹配项
```

> 正则实例对象的 `lastIndex` 属性不仅可读，还可写。设置了 `g` 修饰符的时候，只要手动设置了 `lastIndex` 的值，就会从指定位置开始匹配。

##### 8.7.2 `regexp.test()`

用来判断目标字符与模式是否匹配（在不需要知道其内容的情况下，该方法很便利）。接收一个字符串参数。匹配时返回 true，否则返回 false。

如果正则表达式带有 `g` 修饰符，则每一次 `test` 方法都从上一次结束的位置开始向后匹配。

带有 `g` 修饰符时，可以通过正则对象的 `lastIndex` 属性指定开始搜索的位置，`lastIndex` 属性只对同一个正则表达式有效。

```javascript
var count = 0;
while (/a/g.test("babaa")) count++;
```

上面代码会导致无限循环，因为 `while` 循环的每次匹配条件都是一个新的正则表达式，导致 `lastIndex` 属性总是等于 0。

如果正则模式是一个空字符串，则匹配所有字符串。

#### 8.8.RegExp 构造函数属性

`RegExp` 构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性都适用于作用域中的所有正则表达式，并基于所执行的最近一次正则表达式操作而变化。这些属性的另一个独特之处，就是可以通过两种方式访问它们。（Opera 不支持断属性名）

|    长属性名    | 断属性名 | 说明                                                         |
| :------------: | :------: | ------------------------------------------------------------ |
|    `input`     |   `$_`   | 最近一次要匹配的字符串；Opera 未实现                         |
|  `lastMatch`   |   `$&`   | 最近一次的匹配项；Opera 未实现                               |
|  `lastParen`   |   `$+`   | 最近一次匹配的捕获组；Opera 未实现                           |
| `leftContext`  |   `$`    | `input` 字符串中 `lastMatch` 之前的文本                      |
|  `multiline`   |   `$*`   | 布尔值，表示是否所有表达式都使用多行模式；Opera 和 IE 未实现 |
| `rightContext` |   `*'`   | `input` 字符串中 `lastMatch` 之后的文本                      |

```javascript
var str = /^(\d{4})-(\d{1,2})-(\d{1,2})$/;
str.exec("2018-04-26");
s1 = RegExp.$1;
s2 = RegExp.$2;
s3 = RegExp.$3;
s1 + ":" + s2 + ":" + s3; //2018:04:26
```

> 这些断属性名不是有效的 ECMAScript 标识符，必须通过方括号来访问。

还有多达 9 个用于分别存储捕获组的构造函数属性。访问语法：`RegExp.$1、...`。在调用 `exec()` 和 `test()` 方法时，这些属性会被自动填充。

#### 8.9.模式的局限性

尽管 ECMAScript 中的正则表达式功能还是比较完备，但任然缺少某些语言（特别是 perl）所支持的高级正则表达式特性。

不支持的特性：

---

- 1).匹配字符串开始和结尾的 `\A` 和 `\Z`（但支持以插入符号 `^` 和美元 `$` 符号来匹配字符串的开头和结尾）
- 2).**向后查找（lookbehind）**（但完全支持**向前查找（lookhead）**）
- 3).并集和交集类
- 4).**原子组（atomic grouping）**
- 5).`Unicode` 支持（单个字符除外，如 `\uFFFF`）
- 6).命名的捕获组（但支持编号的捕获组）
- 7).`s`(single，单行)和 `x`(free-spacing,无间隔)匹配模式
- 8).条件匹配
- 9).正则表达式注释

---

#### 8.10.正则的特性

##### 8.10.1 懒惰性

始终只会将第一次匹配的内容捕获出来；

解决：加上修饰符 `g`，标识全局捕获；

```javascript
var reg = /\d/g;
var str = "haxi190365";

function getExec(n) {
  var ary = [];
  var a = reg.exec(n);
  while (a) {
    ary.push(a[0]);
    a = reg.exec(n);
  }
  return ary;
}

console.log(getExec(str));
//[ "1", "9", "0", "3", "6", "5" ]
```

##### 8.10.2 贪婪性

量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。

解决：在量词符后面加问号 `？`（取符合字符最少的那一组匹配）；

```javascript
var reg = /\d+/;
var str = "2017px0914";
console.log(reg.exec(str)); //[2017]

var reg = /\d+?/;
var str = "2017px0914";
console.log(reg.exec(str)); //[2]
```

#### 8.11.正则中的小括号的应用

##### 8.11.1 分组

`/(\w)ff\1/.test("dffd");`

正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。

##### 8.11.2 分组捕获

分组的内容会被捕获出来；

```javascript
var reg = /\w(\d)\w(\1)/;
var str = "s8s8";
console.log(reg.exec(str));
//["s8s8", "8", "8", index: 0, input: "s8s8"]
```

`\1` 代表第一个小分组匹配的内容（`\1` 指代的是（`\w`）的内容）。正则表达式内部，还可以用 `\n` 引用括号匹配的内容，n 是从 1 开始的自然数，表示对应顺序的括号，这种用法称之为**后向引用**；

注意，使用组匹配时，不宜同时使用 `g` 修饰符，否则 `match` 方法不会捕获分组的内容。必须加 `g`，这时使用正则表达式的 `exec` 方法，配合循环，才能读到每一轮匹配的组捕获。

##### 8.11.3 分组嵌套

由外而内依次捕获；

```javascript
var reg = /\w(\d(\w)\d)/;
var str = "z9f8";
console.log(reg.exec(str));
//["z9f8", "9f8", "f", index: 0, input: "z9f8"]
```

##### 8.11.4 非捕获

`(?:)` 称为**非捕获组（Non-capturing group）**，表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。

```javascript
var reg = /\w{2}(\d{4})/;
var str = "zf2017px0914";
console.log(reg.exec(str)); //[zf2017]  [2017]

var reg = /\w{2}(?:\d{4})/;
var str = "zf2017px0914";
console.log(reg.exec(str)); //[zf2017]
```

下面是用来分解网址的正则表达式。

```javascript
// 正常匹配
var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

url.exec("http://google.com/");
// ["http://google.com/", "http", "google.com", "/"]

// 非捕获组匹配
var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

url.exec("http://google.com/");
// ["http://google.com/", "google.com", "/"]
```

#### 8.12.字符串方法在正则中的应用

字符串的实例方法之中，有 4 种与正则表达式有关。

---

- `string.match()`：返回一个数组，成员是所有匹配的子字符串。
- `string.search()`：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。
- `string.replace()`：按照给定的正则表达式进行替换，返回替换后的字符串。
- `string.split()`：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。

---

##### 8.12.1 string.match()

正则表达式不加修饰符 `g` 得到的结果类似 `exec()` 方法；
加了 `g` 修饰符以后，会返回所有匹配的结果，返回值也是一个数组，数组中没有 `index` 和 `input`；匹配失败返回 `null`。

```javascript
var reg = /\d/;
var reg1 = /\d/g;
var str = "qwe1709";
console.log(str.match(reg));
//["1", index: 2, input: "qwe1709"]

console.log(str.match(reg1));
//[ "1", "7", "0", "9" ]
```

> 设置正则表达式的 `lastIndex` 属性，对 `match` 方法无效，匹配总是从字符串的第一个字符开始。

##### 8.12.2 exec() 和 match() 的区别

`exec()` 和 `match()` 都是用正则匹配内容，但：

1).`exec()` 处理分组功能更强；`match()` 在没有分组的情况下，能更快捷的把多次匹配的内容保存到数组里；

2).加上全局修饰符以后，`exec()` 依旧只会捕获第一次匹配的内容，而 `match()` 会将所有匹配的内容都输出；

3).`exec()` 属于正则类的方法，`match()` 属于字符串类的方法；

##### 8.12.3 string.split()

按正则匹配的内容将字符串拆分为数组。接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。

```javascript
var str = "2017-9-14 16:38";
console.log(str.split(/[ :-]/));
//["2017", "9", "14", "16", "38"]
```

##### 8.12.4 string.search()

返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回 -1。

```javascript
var str = "sdf123";
console.log(str.search(/\d/)); //2
console.log(str.search(/\w/)); //0
```

##### 8.12.5 string.replace()

在字符串中用一些字符替换另一些字符，或者换一个与正则表达式匹配的子串；返回值是一个字符串，是用第二个参数替换正则表达式第一次匹配或所有匹配之后得到的；正则表达式如果不加 `g` 修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。

```javascript
var str = "1,2,3,4,5,6";
console.log(str.replace(/,/g, "+")); //1+2+3+4+5+6
console.log(eval(str.replace(/,/g, "+"))); //21
```

replacement 中的 `$` 具有特定的含义：

|    字符    | 意义                                         |
| :--------: | -------------------------------------------- |
|  **`$`**   | 匹配第 1~99 个 regexp 中圆括号子表达式的文本 |
| **`\$&`**  | 匹配整个模式的子串                           |
| **`\$``**  | 匹配子串的左边文本                           |
| **`\$'`**  | 匹配子串右边的文本                           |
| **`\$\$`** | 美元符号                                     |

```javascript
var s = "hello world";
console.log(s.replace(/(l)/, "$&")); //hello world
console.log(s.replace(/(l)/, "$`")); //hehelo world
console.log(s.replace(/(l)/, "$'")); //helo worldlo world
console.log(s.replace(/(l)/, "$$")); //he$lo world

var text = "cat,bat,sat,fat";
result = text.replace(/(.at)/g, "word($1)");
console.log(result);
//word(cat),word(bat),word(sat),word(fat)
```

当 `replace()` 方法的第二个参数是函数而不是字符串时，每次匹配都调用该函数（匹配多少次自执行多少次），将这个函数的返回的字符串当做替换文本使用；这个函数是自定义的替换规则；

并且还要给这个函数传最少三个参数：

---

- 1).当正则没有分组的时候，传进去的第一个实参是正则捕获到的内容，第二个参数是捕获到的内容在原字符串中的索引位置，第三个参数是原字符串（输入字符串）；

---

- 2).当正则有分组的时候，第一个参数总是正则查找到的内容，后面依次是各个子正则查找到的内容；

---

- 3).传完查找到的内容之后，再把总正则查找到的内容在原字符串中的索引传进（就是 `arguments[0]` 在 str 中的索引位置）。最后把输入字符串（就是原字符串）传进去；

---

```javascript
var str = "bbs456qwe789";
var reg = /(\w{2})\d+/g;
var s = str.replace(reg, function($1) {
  console.log(arguments);
  //Arguments(4) ["bs456", "bs", 1, "bbs456qwe789"]
  //Arguments(4) ["we789", "we", 7, "bbs456qwe789"]

  //$1 当前匹配的结果
  console.log($1); // bs456   we789

  //RegExp.$1的值是最后一次匹配的结果
  console.log(RegExp.$1); // we  we
  return "[" + arguments[1] + "]";
});
console.log(s); //b[bs]q[we]
```

> 注意： 1.`/[^]/` 表示所有非空字符串，不是非空格；

> 2.`\1` 表示等同于第一个小组内容，这种用法称为反向引用；

> 3.`^` 在正则表达式开始部分表达开头的意思；但是在字符集中，表示非的意思；

> 4.`//` 在正则中最常用的：`reg=/^\s*$/;`

##### 8.12.6 `lastIndex`

多次查找，如何知道下一次从哪个位置开始(⊙o⊙)?这就是正则（这个属性是正则对象的）的一个很重要的属性在发挥作用：`lastIndex`;

每个正则实例都有 `lastIndex` 属性，他的作用是规定当前这次的匹配的开始位置；如果正则表达式没有 `g` 修饰符，那么 `lastIndex` 的值永远都是 0；

#### 8.13.正向预查和负向预查

零宽断言是一种零宽度的匹配，它匹配的内容不会保存到匹配结果中，也不会占用 `index` 宽度，最终匹配的结果只是一个位置。

简单的说，它用于查找在某些内容之前或之后的东西(但返回结果并不包括这些内容)

JavaScript 中只支持零宽先行断言。零宽断言返回的是位置而不是字符，零宽断言匹配成功后，其余表达式会基于这个返回的位置继续判断。

##### 8.13.1 x(?=pattern)

正向预查(正向**先行断言**)，要匹配的字符串，必须要满足 pattern 条件；

##### 8.13.2 x(?!pattern)

负向预查(负向先行断言/先行否定断言)，要匹配的字符串，必须不满足 pattern 条件；

```javascript
var reg1 = /zhufeng(?!js)/;
var reg2 = /zhufeng(?=js)/;
var str = "zhufengjs";
console.log(reg1.exec(str)); //null
console.log(reg2.exec(str));
//["zhufeng", index: 0, input: "zhufengjs"]
```

> 注意：不管是先行断言还是先行否定断言，括号里的内容只是条件，并不参与真正的捕获，只是检查后面的字符是否符合条件；

#### 8.14.正则中的运算符优先级

相同优先级的从左到右进行运算，不同优先级的运算先高后低。

| 运算符                      | 描述                           |
| --------------------------- | ------------------------------ |
| `\`                         | 转义符                         |
| `(),(?:),(?=),[]`           | 圆括号和方括号                 |
| `*,+,?,{n},{n,},{n,m}`      | 限定符                         |
| `^,$,\任何元字符、任何字符` | 定位点和序列（即：位置和顺序） |
| `|`                         | 替换，“或”操作                 |

> 字符具有高于替换运算符的优先级，使得'm|food' 匹配 'm' 或 'food'。若要匹配 'mood' 或 'food'，请使用括号创建子表达式，从而产生 '(m|f)ood'。

#### 补充

**管道符**

> 管道符用 `|` 来表示，正则中管道符的前后没有空格的，有空格会被当成空格一起匹配；管道符只作为部分规则的时候，需要用圆括号包裹起来，比如：`/(m|g)ood/`，`/cat|dog/`。

1. 管道符前可以匹配，管道符后就不会匹配了；管道符前不匹配，自然往后匹配（感觉说的是废话 :rofl::rofl::rofl:）。

```js
"24.24".match(/(^[+-.]?\d+|^[+-]?\d+[.]\d{0,})/);
// ["24", "24", index: 0, input: "24.24", groups: undefined]
"24.24".match(/(^[+-]?\d+[.]\d{0,}|^[+-.]?\d+)/);
// ["24.24", "24.24", index: 0, input: "24.24", groups: undefined]

"24.24".match(/(^[+-.]?\d{3}|^[+-]?\d+[.]\d{0,})/);
// [ '24.24', '24.24', index: 0, input: '24.24', groups: undefined ]
"24.24".match(/(^[+-]?\d+[.]\d{0,}|^[+-.]?\d{3})/);
// [ '24.24', '24.24', index: 0, input: '24.24', groups: undefined ]
```

2. 匹配结果按字符顺序输出，而不是跟据匹配规则的先后输出；

```js
"123".match(/(1|2|3)/g);
// [ '1', '2', '3' ]
"123".match(/(1|3|2)/g);
// [ '1', '2', '3' ]
"123".match(/(3|2|1)/g);
// [ '1', '2', '3' ]
```

至于为啥，暂时没找到答案。。。
