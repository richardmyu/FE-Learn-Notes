# 作用域和闭包

## 1. 作用域是什么

几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个值进行访问或修改。事实上，正是这种储存和访问变量的值的能力将 _状态_ 带给了程序。

但是将变量引入程序会引起几个问题：这些变量在哪里？最重要的是如何找到它们？

这些问题说吗需要一套设计良好的规则来储存变量，并且之后可以方便地找到这些变量，这套规则称之为**作用域**。

### 1.1 编译原理

尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。但与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统中进行移植。尽管如此，JavaScript 引擎编译的步骤和传统的编译语言非常相似，在某些环节可能比预想的复杂。

在传统编译语言的流程中，源码在执行之前会经历三个步骤，统称为：编译。

- 分词/词法分析 （Tokenizing/Lexing）

这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块也被称为**词法单元**（token）。

> 词法单元生成器在判断字符是一个独立的词法单元还是其他词法单元的一部分时，如果调用的是有转态的解析规则，那么这个过程就被称为**词法分析**；若是无状态的解析规则，则称为**分词分析**。

- 解析/语法分析 （Parsing）

这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构树。这个树被称为“抽象语法树”（Abstract Syntax Tree, AST）。

- 代码生成

将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、平台等息息相关。

JavaScript 引擎不会有大量时间用来进行优化，因为与其他语言不同，JavaScript 的编译过程不是发生在构建之前，而是在代码执行之前的几微秒（甚至更短）。

### 1.2 理解作用域

当你看机 `var a = 2;` 这段程序时，很可能认为这是一句声明。事实上，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。

编译器处理：

1. 遇到 `var a`，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，命名为 a。

2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 `a = 2;` 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个 a 变量。如果是，引擎就会使用这个变量；如果不是，引擎会继续查找该变量。如果最终找到了 a 变量，就会将 2 赋值给它；否则引擎就会抛出一个异常。

在第二步中，引擎怎样查找，会影响最终的查找结果。这里引擎查询时会用到两种查找类型：LHS 和 RHS。

- **LHS 和 RHS**

引擎对变量会进行 LHS 或 RHS 查询。当变量在赋值操作的左侧时，进行 LHS 查询，出现在右侧时进行 RHS 查询。讲得更准确一点，RHS 查询与简单地查询某个变量的值别无二致，而 LHS 查询是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。

个人理解，RHS 查询主要针对要获取变量/函数的值的情况，而 LHS 不仅针对对变量赋值的情况，还存在于对变量声明查询中。即 `var a;` 这种情况下，也是进行一次 LHS 查询。

```js
//RHS
function foo(a) {
  console.log(a); //RHS
}
foo(2); //RHS
```

这里有一个容易忽略却非常重要的细节：代码中隐式的 `a = 2` 操作。这个操作发生在 2 被当做参数传递给函数时，2 会被分配给参数 a。为了给参数 a（隐式地）分配值，需要进行一次 LHS 查询。

你可能会倾向于将函数声明 `function foo(a) {}` 概念化为普通的变量声明和赋值，比如 `var foo`、`foo ＝ function(a) {}`。如果这样理解的话，这个函数声明将需要进行 LHS 查询。然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值的定义，比如在引擎执行代码时，并不会有线程专门用来将一个函数值“分配给”foo。因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并不合适。

区分 LHS 和 RHS 是一件重要的事情。因为在变量没有声明的情况下，这两种查询的行为是不一样的。

如果 RHS 查询在所有嵌套的作用域中遍寻不到所需要的变量，引擎会抛出 ReferenceError 异常。

相较之下，当引擎执行 LHS 查询时，如果在顶层中也无法找到目标变量，全局作用域中会创建一个具有该名称的变量，并将其返回给引擎，前提是程序运行在非“严格模式”下。

ES5 引入“严格模式”，同正常模式或者说懒惰模式相比，严格模式下禁止自动或隐式的创建全局变量。因此在 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。

接下来，如果 RHS 查询找到一个变量，但你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或者引用 `null` 或 `undefined` 类型的值中的属性时，那么引擎会抛出 TypeError 异常。

> ReferenceError 同作用域判别识别有关，而 TypeError 则代表作用域判别超过了，但是对结果的操作是非法或不合理的。

### 1.3 嵌套作用域

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。

## 2. 词法作用域

作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，我们会对这种作用域进行深入讨论。另外一种叫作动态作用域，仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）。

JavaScript 中的作用域就是词法作用域。

### 2.1 词法阶段

词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

> 全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。

无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

### 2.2 欺骗词法

如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以说欺骗）词法作用域呢？

JavaScript 中有两种机制来实现这个目的。社区普遍认为在代码中使用这两种机制并不是什么好主意。但是关于它们的争论通常会忽略掉最重要的点：欺骗词法作用域会导致性能下降。

#### 2.2.1 eval

默认情况下，如果 `eval()` 中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对 `eval()` 所处的词法作用域进行修改。在严格模式的程序中，`eval()` 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。

```js
function foo(str, a) {
  eval(str); // 欺骗！
  console.log(a, b);
}

var b = 2;

foo("var b = 3;", 1); // 1, 3

// strict modelF
function foo(str) {
  "use strict";
  eval(str);
  console.log(a); // ReferenceError: a is not defined
}

foo("var a = 2");
```

`new Function()` 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比 `eval()` 略微安全一些，但也要尽量避免使用。

在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。

#### 2.2.2 with

`with` 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。

```js
function foo(obj) {
  with (obj) {
    // LHS ！！！
    a = 2;
  }
}

var o1 = {
  a: 3
};

var o2 = {
  b: 3
};

foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2——不好，a 被泄漏到全局作用域上了！
```

注意到一个奇怪的副作用，实际上 `a = 2` 赋值操作创建了一个全局的变量 a。这是怎么回事？

`with` 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。尽管 `with` 块可以将一个对象处理为词法作用域，但是这个块内部正常的 `var` 声明并不会被限制在这个块的作用域中，而是被添加到 `with` 所处的函数作用域中。

`eval(..)` 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 `with` 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。

可以这样理解，当我们传递 o1 给 `with` 时，`with` 所声明的作用域是 o1，而这个作用域中含有一个同 o1.a 属性相符的标识符。但当我们将 o2 作为作用域时，其中并没有 a 标识符，因此进行了正常的 LHS 标识符查找。o2 的作用域、`foo()` 的作用域和全局作用域中都没有找到标识符 a，因此当 `a = 2` 执行时，自动创建了一个全局变量（因为是非严格模式）。

`with` 这种将对象及其属性放进一个作用域并同时分配标识符的行为很让人费解。

参考：

你所不知道的 JavaScript （上卷）

#### 2.2.3 性能

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

但如果引擎在代码中发现了 `eval()` 或 `with`，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 `eval()` 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 `with` 用来创建新词法作用域的对象的内容到底是什么。

最悲观的情况是如果出现了 `eval()` 或 `with`，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。

如果代码中大量使用 `eval()` 或 `with`，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。

### 2.3 动态作用域

实际上动态作用域是 JavaScript 另一个重要机制 `this` 的表亲。

词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段。

动态作用域似乎暗示有很好的理由让作用域作为一个在运行时就被动态确定的形式，而不是在写代码时进行静态确定的形式，事实上也是这样的。

```js
function foo() {
  console.log(a); // 2
}

function bar() {
  var a = 3;
  foo();
}

var a = 2;

bar();
```

词法作用域让 `foo()` 中的 a 通过 RHS 引用到了全局作用域中的 a，因此会输出 2。而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。

因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 `foo()` 在执行时将会输出 3。因为当 `foo()` 无法找到 a 的变量引用时，会顺着调用栈在调用 `foo()` 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 `foo()` 是在 `bar()` 中调用的，引擎会检查 `bar()` 的作用域，并在其中找到值为 3 的变量 a。

很奇怪吧？现在你可能会这么想。

但这其实是因为你可能只写过基于词法作用域的代码（或者至少以词法作用域为基础进行了深入的思考），因此对动态作用域感到陌生。如果你只用基于动态作用域的语言写过代码，就会觉得这是很自然的，而词法作用域看上去才怪怪的。

需要明确的是，事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 `this` 机制某种程度上很像动态作用域。

主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（`this` 也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。

最后，`this` 关注函数如何调用，这就表明了 `this` 机制和动态作用域之间的关系多么紧密。

## 3. 函数作用域和块作用域

### 3.1 函数中的作用域

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。

### 3.2 隐藏内部实现

对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。

实际的结果就是在这个代码片段的周围创建了一个作用域，也就是说这段代码中的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。

为什么“隐藏”变量和函数是一个有用的技术？

有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。

这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。

- 规避冲突

“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

1. 全局命名空间

变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。

这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。

2. 模块管理

另外一种避免冲突的办法和现代的**模块**机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。

显而易见，这些工具并没有能够违反词法作用域规则的“神奇”功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。

### 3.3 函数作用域

#### 3.3.1 匿名和具名

对于函数表达式，最常见的场景可能就是回调参数了，比如：

```js
setTimeout(function() {
  console.log("I waited 1 second!");
}, 1000);
```

这叫作**匿名函数表达式**，因为 function 没有名称标识符。

匿名函数表达式书写起来简单快捷，但是它也有几个缺点需要考虑。

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。

2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。

3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

**行内函数表达式**非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：

```js
setTimeout(function timeoutHandler() {
  // <-- 快看，我有名字了！
  console.log("I waited 1 second!");
}, 1000);
```

#### 3.3.2 立即执行函数表达式

```js
var a = 2;

(function foo() {
  var a = 3;
  console.log(a); // 3
})();

console.log(a); // 2
```

第一个 `( )` 将函数变成表达式，第二个 `( )` 执行了这个函数。这种模式很常见，几年前社区给它规定了一个术语：IIFE，代表**立即执行函数表达式**（Immediately Invoked Function Expression）；

函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。

相较于传统的 IIFE 形式，很多人都更喜欢另一个改进的形式：`(function(){ .. }())`。仔细观察其中的区别。第一种形式中函数表达式被包含在 `()` 中，然后在后面用另一个 `()` 括号来调用。第二种形式中用来调用的 `()` 括号被移进了用来包装的 `()` 括号中。

IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。

```js
var a = 2;

(function IIFE(global) {
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
})(window);

console.log(a); // 2
```

我们将 window 对象的引用传递进去，但将参数命名为 global，因此在代码风格上对全局对象的引用变得比引用一个没有“全局”字样的变量更加清晰。当然可以从外部作用域传递任何你需要的东西，并将变量命名为任何你觉得合适的名字。这对于改进代码风格是非常有帮助的。

这个模式的另外一个应用场景是解决 `undefined` 标识符的默认值被错误覆盖导致的异常（虽然不常见）。将一个参数命名为 `undefined`，但是在对应的位置不传入任何值，这样就可以保证在代码块中 `undefined` 标识符的值真的是 `undefined`：

```js
undefined = true; // 给其他代码挖了一个大坑！绝对不要这样做！

(function IIFE(undefined) {
  var a;
  if (a === undefined) {
    console.log("Undefined is safe here!");
  }
})();
```

IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去。这种模式在 UMD（Universal Module Definition）项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。

```js
var a = 2;

(function IIFE(def) {
  def(window);
})(function def(global) {
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
});
```

### 3.4 块作用域

尽管函数作用域是最常见的作用域单元，当然也是现行大多数 JavaScript 中最普遍的设计方法，但其他类型的作用域单元也是存在的，并且通过使用其他类型的作用域单元甚至可以实现维护起来更加优秀、简洁的代码。

```js
for (var i = 0; i < 10; i++) {
  console.log(i);
}
```

我们在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 i 会被绑定在外部作用域（函数或全局）中的事实。

这就是块作用域的用处。变量的声明应该距离使用的地方越近越好，并最大限度地本地化。块作用域是一个用来对之前的**最小授权原则**进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。

#### 3.4.1 with

它不仅是一个难于理解的结构，同时也是块作用域的一个例子（块作用域的一种形式），用 `with` 从对象中创建出的作用域仅在 `with` 声明中而非外部作用域中有效。

#### 3.4.2 try/catch

非常少有人会注意到 JavaScript 的 ES3 规范中规定 `try/catch` 的 `catch` 分句会创建一个块作用域，其中声明的变量仅在 `catch` 内部有效。

```js
try {
  undefined(); // 执行一个非法操作来强制制造一个异常
} catch (err) {
  console.log(err); // 能够正常执行！
}

console.log(err); // ReferenceError: err not found
```

> 当同一个作用域中的两个或多个 `catch` 分句用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部，但是静态检查工具还是会很烦人地发出警告。
> 为了避免这个不必要的警告，很多开发者会将 `catch` 的参数命名为 err1、err2 等。也有开发者干脆关闭了静态检查工具对重复变量名的检查。

### 3.4.3 let

到目前为止，我们知道 JavaScript 在暴露块作用域的功能中有一些奇怪的行为。如果仅仅是这样，那么 JavaScript 开发者多年来也就不会将块作用域当作非常有用的机制来使用了。

幸好，ES6 改变了现状，引入了新的 `let` 关键字，提供了除 `var` 以外的另一种变量声明方式。

`let` 关键字可以将变量绑定到所在的任意作用域中（通常是 `{ .. }` 内部）。换句话说，`let` 为其声明的变量隐式地劫持了所在的块作用域。

```js
var foo = true;

if (foo) {
  let bar = foo * 2;
  bar = something(bar);
  console.log(bar);
}

console.log(bar); // ReferenceError
```

用 `let` 将变量附加在一个已经存在的块作用域上的行为是隐式的。在开发和修改代码的过程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将其包含在其他的块中，就会导致代码变得混乱。

为块作用域显式地创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。通常来讲，显式的代码优于隐式或一些精巧但不清晰的代码。显式的块作用域风格非常容易书写，并且和其他语言中块作用域的工作原理一致：

```js
var foo = true;

if (foo) {
  {
    // <-- 显式的块
    let bar = foo * 2;
    bar = something(bar);
    console.log(bar);
  }
}

console.log(bar); // ReferenceError
```

只要声明是有效的，在声明中的任意位置都可以使用 `{ .. }` 括号来为 `let` 创建一个用于绑定的块。在这个例子中，我们在 `if` 声明内部显式地创建了一个块，如果需要对其进行重构，整个块都可以被方便地移动而不会对外部 `if` 声明的位置和语义产生任何影响。

但是使用 `let` 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。

```js
{
  console.log(bar); // ReferenceError!
  let bar = 2;
}
```

1. 垃圾收集

另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。

考虑以下代码：

```js
function process(data) {
    // 在这里做点有趣的事情
}

var someReallyBigData = { .. };

process( someReallyBigData );

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt) {
    console.log("button clicked");
}, /*<i>apcturingPhase</i>=*/false );
```

`click` 函数的点击回调并不需要 `someReallyBigData` 变量。理论上这意味着当 `process(..)` 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 `click` 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构（取决于具体实现）。

块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存 `someReallyBigData` 了：

```js
function process(data) {
    // 在这里做点有趣的事情
}

// 在这个块中定义的内容完事可以销毁！
{
    let someReallyBigData = { .. };

    process( someReallyBigData );
}

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt) {
    console.log("button clicked");
}, /*<i>capturingPhase</i>=*/false );

```

为变量显式声明块作用域，并对变量进行本地绑定是非常有用的工具，可以把它添加到你的代码工具箱中了。

2.let 循环

一个 `let` 可以发挥优势的典型例子就是之前讨论的 `for` 循环。

```js
for (let i = 0; i < 10; i++) {
  console.log(i);
}

console.log(i); // ReferenceError
```

`for` 循环头部的 `let` 不仅将 i 绑定到了 `for` 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。

#### 3.4.4 const

除了 `let` 以外，ES6 还引入了 `const`，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。

```js
var foo = true;

if (foo) {
  var a = 2;
  const b = 3; // 包含在 if 中的块作用域常量

  a = 3; // 正常！
  b = 4; // 错误！
}

console.log(a); // 3
console.log(b); // ReferenceError!
```

### 3.5 块作用域的替代方案

至少从 ES3 发布以来，JavaScript 中就有了块作用域，而 `with` 和 `catch` 分句就是块作用域的两个小例子。但随着 ES6 中引入了 `let`，我们的代码终于有了创建完整、不受约束的块作用域的能力。块作用域在功能上和代码风格上都拥有很多激动人心的新特性。

考虑下面的代码：

```js
{
  let a = 2;
  console.log(a); // 2
}

console.log(a); // ReferenceError
```

这段代码在 ES6 环境中可以正常工作。但是在 ES6 之前的环境中如何才能实现这个效果？答案是使用 `catch`。

```js
try {
  throw 2;
} catch (a) {
  console.log(a); // 2
}

console.log(a); // ReferenceError
```

事实上，这是向 ES6 中的所有（好吧，不是所有而是大部分）功能迁移的首选方式：在从 ES6 之前的环境向 ES6 过渡时，使用代码转换工具来对 ES6 代码进行处理，生成兼容 ES5 的代码。

#### 3.5.1 隐式和显式作用域

介绍块作用域时，我们的代码有一些可维护性和可扩展性方面的缺陷。有没有其他可以使用块作用域，并且还能避免这种缺陷的途径？

考虑下面这种 `let` 的使用方法，它被称作 `let` 作用域或 `let` 声明（对比前面的 `let` 定义）。

```js
let (a = 2) {
console.log( a ); // 2
}

console.log( a ); //<i> ReferenceError</i>
```

同隐式地劫持一个已经存在的作用域不同，`let` 声明会创建一个显示的作用域并与其进行绑定。显式作用域不仅更加突出，在代码重构时也表现得更加健壮。在语法上，通过强制性地将所有变量声明提升到块的顶部来产生更简洁的代码。这样更容易判断变量是否属于某个作用域。

这种模式同很多人在函数作用域中手动将 `var` 声明提升到函数顶部的方式很接近。`let` 声明有意将变量声明放在块的顶部，如果你并没有到处使用 `let` 定义，那么你的块作用域就很容易辨识和维护。但是这里有一个小问题，`let` 声明并不包含在 ES6 中。

#### 3.5.2 性能

最后简单地看一下 `try/catch` 带来的性能问题，并尝试回答“为什么不直接使用 IIFE 来创建作用域”这个问题。

首先，`try/catch` 的性能的确很糟糕，但技术层面上没有合理的理由来说明 `try/catch` 必须这么慢，或者会一直慢下去。自从 TC39 支持在 ES6 的转换器中使用 `try/catch` 后，Traceur 团队已经要求 Chrome 对 `try/catch` 的性能进行改进，他们显然有很充分的动机来做这件事情。

其次，IIFE 和 `try/catch` 并不是完全等价的，因为如果将一段代码中的任意一部分拿出来用函数进行包裹，会改变这段代码的含义，其中的 `this`、`return`、`break` 和 `continue` 都会发生变化。IIFE 并不是一个普适的解决方案，它只适合在某些情况下进行手动操作。

最后问题就变成了：你是否想要块作用域？如果你想要，这些工具就可以帮助你。如果不想要，继续使用 `var` 来写代码就好了！

## 4. 提升

直觉上会认为 JavaScript 代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确，有一种特殊情况会导致这个假设是错误的。

```js
a = 2;
var a;
console.log(a); //2
```

变量和函数在内的所有声明都会在任何代码被执行前首先被处理。这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”到了最上面。这个过程就叫作**提升**。

> 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。

函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。

## 5. 作用域闭包

**闭包是基于词法作用域书写代码时所产生的自然结果**，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。

下面是直接了当的定义：

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

```js
function foo() {
  var a = 2;

  function bar() {
    console.log(a); // 2
  }

  bar();
}

foo();
```

这是闭包吗？技术上来讲，也许是。但根据前面的定义，确切地说并不是。我认为最准确地用来解释 `bar()` 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。（但却是非常重要的一部分！）

从纯学术的角度说，在上面的代码片段中，函数 `bar()` 具有一个涵盖 `foo()` 作用域的闭包（事实上，涵盖了它能访问的所有作用域，比如全局作用域）。也可以认为 `bar()` 封闭了 `foo()` 的作用域。为什么呢？原因简单明了，因为 `bar()` 嵌套在 `foo()` 内部。

但是通过这种方式定义的闭包并不能直接进行观察，也无法明白在这个代码片段中闭包是如何工作的。我们可以很容易地理解词法作用域，而闭包则隐藏在代码之后的神秘阴影里，并不那么容易理解。

```js
function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }

  return bar;
}

var baz = foo();

baz(); // 2 ———— 朋友，这就是闭包的效果。
```

在 `foo()` 执行后，通常会期待 `foo()` 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 `foo()` 的内容不会再被使用，所以很自然地会考虑对其进行回收。

而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 `bar()` 本身在使用。

拜 `bar()` 所声明的位置所赐，它拥有涵盖 `foo()` 内部作用域的闭包，使得该作用域能够一直存活，以供 `bar()` 在之后任何时间进行引用。`bar()` 依然持有对该作用域的引用，而这个引用就叫作闭包。

闭包使得函数可以继续访问定义时的词法作用域。当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。

```js
function foo() {
  var a = 2;

  function baz() {
    console.log(a); // 2
  }

  bar(baz);
}

function bar(fn) {
  fn(); // 妈妈快看呀，这就是闭包！
}
```

无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。

```js
function wait(message) {
  setTimeout(function timer() {
    console.log(message);
  }, 1000);
}

wait("Hello, closure!");
```

本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！

```js
var a = 2;

(function IIFE() {
  console.log(a);
})();
```

虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么？因为函数（示例代码中的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行（而外部作用域，也就是全局作用域也持有 a）。a 是通过普通的词法作用域查找而非闭包被发现的。

尽管技术上来讲，闭包是发生在定义时的，但并不非常明显。

尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此 IIFE 的确同作用域息息相关，即使本身并不会真的创建作用域。

### 5.1 循环和闭包

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。

要解决这个问题，我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。

```js
// IIFE 会通过声明并立即执行一个函数来创建作用域
for (var i = 1; i <= 5; i++) {
  (function() {
    setTimeout(function timer() {
      console.log(i);
    }, i * 1000);
  })();
}
```

的确每个延迟函数都会将 IIFE 在每次迭代中创建的作用域封闭起来。但如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。它需要有自己的变量，用来在每个迭代中储存 i 的值：

```js
for (var i = 1; i <= 5; i++) {
  (function() {
    // 必须要有一个私有变量
    var j = i;
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })();
}

// 改进
for (var i = 1; i <= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。

- 块作用域

仔细思考我们对前面的解决方案的分析。我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。`let` 声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。本质上这是将一个块转换成一个可以被关闭的作用域：

```js
for (var i = 1; i <= 5; i++) {
  let j = i; // 是的，闭包的块作用域！
  setTimeout(function timer() {
    console.log(j);
  }, j * 1000);
}
```

for 循环头部的 `let` 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。

```js
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

### 5.2 模块

还有其他的代码模式利用闭包的强大威力，但从表面上看，它们似乎与回调无关。下面一起来研究其中最强大的一个：模块。

```js
function CoolModule() {
  var something = "cool";
  var another = [1, 2, 3];

  function doSomething() {
    console.log(something);
  }

  function doAnother() {
    console.log(another.join(" ! "));
  }

  return {
    doSomething: doSomething,
    doAnother: doAnother
  };
}

var foo = CoolModule();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

这个模式在 JavaScript 中被称为**模块**。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。

首先，`CoolModule()` 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。

其次，`CoolModule()` 返回一个用对象字面量语法来表示的对象。这个返回的对象中含有对内部函数而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看作本质上是*模块的公共 API*。

这个对象类型的返回值最终被赋值给外部的变量 `foo`，然后就可以通过它来访问 API 中的属性方法，比如 `foo.doSomething()`。

`doSomething()` 和 `doAnother()` 函数具有涵盖模块实例内部作用域的闭包（通过调用 `CoolModule()` 实现）。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，我们已经创造了可以观察和实践闭包的条件。

如果要更简单的描述，模块模式需要具备两个必要条件。

1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。

2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。

一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。

上一个示例代码中有一个叫作 `CoolModule()` 的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来实现**单例模式**：

```js
var foo = (function CoolModule() {
  var something = "cool";
  var another = [1, 2, 3];

  function doSomething() {
    console.log(something);
  }

  function doAnother() {
    console.log(another.join(" ! "));
  }

  return {
    doSomething: doSomething,
    doAnother: doAnother
  };
})();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

模块模式另一个简单但强大的用法是命名将要作为公共 API 返回的对象：

```js
var foo = (function CoolModule(id) {
  function change() {
    // 修改公共 API
    publicAPI.identify = identify2;
  }

  function identify1() {
    console.log(id);
  }

  function identify2() {
    console.log(id.toUpperCase());
  }

  var publicAPI = {
    change: change,
    identify: identify1
  };

  return publicAPI;
})("foo module");

foo.identify(); // foo module
foo.change();
foo.identify(); // FOO MODULE
```

通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。

#### 5.2.1 现代的模块机制

大多数模块依赖加载器/管理器本质上都是将这种模块定义封装进一个友好的 API。

```js
var MyModules = (function Manager() {
  var modules = {};

  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply(impl, deps);
  }

  function get(name) {
    return modules[name];
  }

  return {
    define: define,
    get: get
  };
})();
```

这段代码的核心是 `modules[name] = impl.apply(impl, deps)`。为了模块的定义引入了包装函数（可以传入任何依赖），并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。

下面展示了如何使用它来定义模块：

```js
MyModules.define("bar", [], function() {
  function hello(who) {
    return "Let me introduce: " + who;
  }

  return {
    hello: hello
  };
});

MyModules.define("foo", ["bar"], function(bar) {
  var hungry = "hippo";

  function awesome() {
    console.log(bar.hello(hungry).toUpperCase());
  }

  return {
    awesome: awesome
  };
});

var bar = MyModules.get("bar");
var foo = MyModules.get("foo");

console.log(bar.hello("hippo")); // Let me introduce: hippo

foo.awesome(); // LET ME INTRODUCE: HIPPO
```

为我们自己着想，应该多花一点时间来研究这些示例代码并完全理解闭包的作用吧。最重要的是要理解模块管理器没有任何特殊的“魔力”。它们符合前面列出的模块模式的两个特点：调用包装了函数定义的包装函数，并且将返回值作为该模块的 API。换句话说，模块就是模块，即使在它们外层加上一个友好的包装工具也不会发生任何变化。

#### 5.5.2 未来的模块机制

ES6 中为模块增加了一级语法支持。在通过模块系统进行加载时，ES6 会将文件当作独立的模块来处理。每个模块都可以导入其他模块或特定的 API 成员，同样也可以导出自己的 API 成员。

基于函数的模块并不是一个能被静态识别的模式（编译器无法识别），它们的 API 语义只有在运行时才会被考虑进来。因此可以在运行时修改一个模块的 API（参考前面关于 public API 的讨论）。

相比之下，ES6 模块 API 是静态的（API 不会在运行时改变）。由于编辑器知道这一点，因此可以在（的确也这样做了）编译期检查对导入模块的 API 成员的引用是否真实存在。如果 API 引用并不存在，编译器会在编译时就抛出“早期”错误，而不会等到运行期再动态解析（并且报错）。

ES6 的模块没有“行内”格式，必须被定义在独立的文件中（一个文件一个模块）。浏览器或引擎有一个默认的“模块加载器”（可以被重载）可以在导入模块时同步地加载模块文件。

考虑以下代码：

- bar.js

```js
function hello(who) {
  return "Let me introduce: " + who;
}

export hello;
```

- foo.js

```js
// 仅从"bar"模块导入 hello()
import hello from "bar";

var hungry = "hippo";

function awesome() {
  console.log(
    hello( hungry ).toUpperCase()
  );
}

export awesome;
```

- baz.js

```js
// 导入完整的"foo"和"bar"模块
module foo from "foo";
module bar from "bar";

console.log(bar.hello( "rhino" )); // Let me introduce: rhino

foo.awesome(); // LET ME INTRODUCE: HIPPO
```

`import` 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上（在我们的例子里是 hello）。

`module` 会将整个模块的 API 导入并绑定到一个变量上（在我们的例子里是 foo 和 bar）。

`export` 会将当前模块的一个标识符（变量、函数）导出为公共 API。这些操作可以在模块定义中根据需要使用任意多次。

模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。

参考：

《你不知道的 JavaScript》（上）

[js 闭包测试](https://www.cnblogs.com/rubylouvre/p/3345294.html)
