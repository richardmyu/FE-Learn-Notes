# 词法作用域

作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的 **词法作用域**；另外一种叫作 **动态作用域**，仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）。

- 词法作用域是在写代码或者说定义时确定的
>
- 动态作用域是在运行时确定的

动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，*作用域链是基于调用栈的*，而不是代码中的作用域嵌套。

事实上 JavaScript 并不具有动态作用域，只有词法作用域。但是 `this` 机制某种程度上 *很像* 动态作用域。

**词法作用域** 就是定义在【词法阶段】的作用域，即 *由编写代码时的位置决定*，因而词法分析器处理代码时会保持作用域不变。

```js
function foo() {
  console.log(a);
}

function bar() {
  var a = 3;
  foo();
}

var a = 2;
bar(); // 2
```

- 词法作用域查找到第一个匹配的标识符后会停止查找；
>
- 词法作用域只会查找一级标识符；（例如对于类似 `foo.bar.baz`只是查找 `foo`，找到这个变量以后，对象属性访问规则接管对 `bar` 和 `baz` 属性的访问。）

## 1.欺骗词法

所谓欺骗词法是指在运行时“修改”词法作用域。但是注意，欺骗词法作用域可能会导致性能下降。

### 1.1.`eval`

`eval` 函数接受一个字符串作为参数，并将其中的内容视为好像就在书写程序时就存在那个位置的代码一样。

```js
function foo(str, a){
  eval(str);
  console.log(a, b);
}

var b = 2;

foo('var b = 3;', 1);
// 1 3

// 'use strict'
// 1 2
```

> 非严格模式下，如果 `eval` 所执行的代码包含一个或多个声明，就会对 `eval` 所在的此法作用域进行修改。
> 严格模式下， `eval` 在运行时会有自己的词法作用域，而不会影响到其所处的词法作用域。

JavaScript 中还有其他一些功能效果和 `eval` 类似。

`setTimeout` 和 `setInterval` 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已过时且不被提倡。

`new Function` 函数的行为也很类似，最后一个参数可以接受字符串，也是转换为动态生成的函数，这种构建函数的语法比 `eval` 略微安全，但也尽量避免使用。

### 1.2.`with`

`with` 通常被当作重复引用一个对象中的多个属性的快捷方式方式，可以不需要重复引用对象本身。

```js
function foo(obj) {
  with (obj) {
    var c = 1;
    a = 2;
  }
  console.log(c); // 1 1
}

var o1 = {
  a: 3
};

var o2 = {
  b: 3
};

foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2 -- a 被泄露到全局了
```

`with` 可以将一个没有或者由多个属性的对象处理为一个 *完全隔离* 的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。

> `with` 内部正常的 `var` 声明并不会被局限在 `with` 的作用域中，而是被添加到 `with` 所处的作用域中 。
> 与 `eval` 修改词法作用域不同，`with` 是创建了一个全新的词法作用域。

严格模式下，`with` 被完全禁止止，而在保留核心功能的前提下，间接或非安全地使用 `eval` 也被禁止了。

### 1.3.性能

JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行【静态分析】，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

> 静态分析（static analysis ）：一种通过在程序运行之前自动检查源代码进行调试的调试方法。

但如果引擎在代码中发现了 `eval` 或 `with`，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 `eval` 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 `with` 用来创建新词法作用域的对象的内容到底是什么。

最悲观的情况是如果出现了 `eval` 或 `with`，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。
