# 回调

在所有这些示例中，函数都是作为 **回调**（callback）使用的，因为它是事件循环“回头调用”到程序中的目标，队列处理到这个项目的时候会运行它。

到目前为止，回调是编写和处理 JavaScript 程序异步逻辑的最常用方式。确实，回调是这门语言中最基础的异步模式。

无数 JavaScript 程序，甚至包括一些最为高深和复杂的，所依赖的异步基础也仅限于回调。回调函数是 JavaScript 的异步主力军，并且它们不辱使命地完成了自己的任务。

但是……回调函数也不是没有缺点。很多开发者因为更好的异步模式 `promise` 而激动不已。但是，只有理解了某种抽象的目标和原理，才能有效地应用这种抽象机制。

## 1.`continuation`

让我们回到的异步回调的例子，为了突出重点，以下稍作了修改：

```js
// A
ajax( "..", function(){
 // C
} );
// B
```

`// A` 和 `// B` 表示程序的前半部分（也就是现在的部分），而 `// C` 标识了程序的后半部分（也就是将来的部分）。前半部分立刻执行，然后是一段时间不确定的停顿。在未来的某个时刻，如果 Ajax 调用完成，程序就会从停下的位置继续执行后半部分。换句话说，回调函数包裹或者说封装了程序的 **延续**（continuation）。让我们进一步简化这段代码：

```js
// A
setTimeout( function(){
 // C
}, 1000 );
// B
```

请在这里稍作停留，思考一下你自己会如何（向对 JavaScript 运作机制不甚了解的某位人士）描述这段程序的运行方式。然后试着把你的描述大声说出来。这有助于你理解我接下来要展示的要点。

大多数人刚才可能想到或说出的内容会类似于“执行 A，然后设定一个延时等待 1000 毫秒，到时后马上执行 C”。你的描述准确度如何呢？

也可能进一步修改为“执行 A，设定延时 1000 毫秒，然后执行 B，然后定时到时后执行 C”。这比第一个版本要更精确一些。你能指出其中的区别吗？

尽管第二个版本更精确一些，但是在匹配大脑对这段代码的理解和代码对于 JavaScript 引擎的意义方面，两个版本对这段代码的解释都有不足。这种不匹配既微妙又显著，也正是理解回调作为异步表达和管理方式的缺陷的关键所在。

一旦我们以回调函数的形式引入了单个 `continuation`（或者几十个，就像很多程序所做的那样！），我们就容许了大脑工作方式和代码执行方式的分歧。一旦这两者出现分歧（这远不是这种分歧出现的唯一情况，我想你明白这一点！），我们就得面对这样一个无法逆转的事实：代码变得更加难以理解、追踪、调试和维护。

## 2.顺序的大脑

我们在假装并行执行多个任务时，实际上极有可能是在进行快速的上下文切换，比如与朋友或家人电话聊天的同时还试图打字。换句话说，我们是在两个或更多任务之间快速连续地来回切换，同时处理每个任务的微小片段。我们切换得如此之快，以至于对外界来说，我们就像是在并行地执行所有任务。

这听起来是不是和异步事件并发机制（比如 JavaScript 中的形式）很相似呢？

### 2.1.执行与计划

对我们程序员来说，编写异步事件代码，特别是当回调是唯一的实现手段时，困难之处就在于这种思考 / 计划的意识流对我们中的绝大多数来说是不自然的。

我们的思考方式是一步一步的，但是从同步转换到异步之后，可用的工具（回调）却不是按照一步一步的方式来表达的。

这就是为什么精确编写和追踪使用回调的异步 JavaScript 代码如此之难：因为这并不是我们大脑进行计划的运作方式。

### 2.2.嵌套回调与链式回调

考虑：

```js
listen("click", function handler(evt) {
  setTimeout(function request() {
    ajax("http://some.url.1", function response(text) {
      if (text == "hello") {
        handler();
      } else if (text == "world") {
        request();
      }
    });
  }, 500);
});
```

你很可能非常熟悉这样的代码。这里我们得到了三个函数嵌套在一起构成的链，其中每个函数代表异步序列（任务，“进程”）中的一个步骤。

这种代码常常被称为 **回调地狱**（callback hell），有时也被称为 **毁灭金字塔**（pyramid of doom，得名于嵌套缩进产生的横向三角形状）。

一开始我们在等待 `click` 事件，然后等待定时器启动，然后等待 Ajax 响应返回，之后可能再重头开始。

一眼看去，这段代码似乎很自然地将其异步性映射到了顺序大脑计划。

首先（现在）我们有：

```js
listen( "..", function handler(){
 // ..
} );
```

然后是将来，我们有：

```js
setTimeout( function request(){
 // ..
}, 500) ;
```

接着还是将来，我们有：

```js
ajax( "..", function response(){
 // ..
} );
```

最后（最晚的将来），我们有：

```js
if ( .. ) {
 // ..
} else ..
```

但以这种方式线性地追踪这段代码还有几个问题。

首先，例子中的步骤是按照 1、2、3、4……的顺序，这只是一个偶然。实际的异步 JavaScript 程序中总是有很多噪声，使得代码更加杂乱。

另外，其中还有一个隐藏更深的错误，但在代码例子中，这个错误并不明显。我们另外设计一个场景（伪代码）来展示这一点：

```js
doA(function () {
  doB();
  doC(function () {
    doD();
  })
  doE();
});
doF();
```

尽管有经验的你能够正确确定实际的运行顺序，但我敢打赌，这比第一眼看上去要复杂一些，需要费一番脑筋才能想清楚。实际运行顺序是这样的：

```mk
• doA()
• doF()
• doB()
• doC()
• doE()
• doD()
```

但即使你能够很轻松地得出结论，还是有一个可能导致严重问题的风险。如果 `doA(..)` 或 `doD(..)` 实际并不像我们假定的那样是异步的，情况会如何呢？啊，那顺序就更麻烦了。

问题是出在嵌套上吗？是它导致跟踪异步流如此之难吗？确实，部分原因是这样。但是，让我们不用嵌套再把前面的嵌套事件 / 超时 /Ajax 的例子重写一遍吧：

```js
listen("click", handler);

function handler() {
  setTimeout(request, 500);
}

function request() {
  ajax("http://some.url.1", response);
}

function response(text) {
  if (text == "hello") {
    handler();
  } else if (text == "world") {
    request();
  }
}
```

这种组织形式的代码不像前面以嵌套 / 缩进的形式组织的代码那么容易识别了，但是它和回调地狱一样脆弱，易受影响。为什么？

在线性（顺序）地追踪这段代码的过程中，我们不得不从一个函数跳到下一个，再跳到下一个，在整个代码中跳来跳去以“查看”流程。而且别忘了，这还是简化的形式，只考虑了最优情况。我们都知道，真实的异步 JavaScript 程序代码要混乱得多，这使得这种追踪的难度会成倍增加。

还有一点需要注意：要把步骤 2、步骤 3 和步骤 4 连接在一起让它们顺序执行，只用回调的话，代价可以接受的唯一方式是把步骤 2 硬编码到步骤 1 中，步骤 3 硬编码到步骤 2 中，步骤 4 硬编码到步骤 3 中，以此类推。如果实际上步骤 2 总会引出步骤 3 是一个固定条件的话，硬编码本身倒不一定是坏事。

但是，硬编码肯定会使代码更脆弱一些，因为它并没有考虑可能导致步骤执行顺序偏离的异常情况。比如，如果步骤 2 失败，就永远不会到达步骤 3，不管是重试步骤 2，还是跳转到其他错误处理流程，等等。

这些问题都可以通过在每个步骤中手工硬编码来解决，但这样的代码通常是重复的，并且在程序中的其他异步流中或其他步骤中无法复用。

尽管我们的大脑能够以顺序的方式（这个，然后这个，然后这个）计划一系列任务，但大脑运作的事件化的本质使得控制流的恢复 / 重试 / 复制几乎不费什么力气。如果你出外办事的时候发现把购清单落在了家里，那么这一天并不会因为你没有预知到这一点就成为世界末日了。你的大脑很容易就能针对这个小意外做出计划：回家拿清单，然后立刻返回商店就是了。

但是，手工硬编码（即使包含了硬编码的出错处理）【回调的脆弱本性】可就远没有这么优雅了。一旦你指定（也就是预先计划）了所有的可能事件和路径，代码就会变得非常复杂，以至于无法维护和更新。

这才是回调地狱的真正问题所在！嵌套和缩进基本上只是转移注意力的枝节而已。如果这还不够的话，我们还没有提及两个或更多回调 `continuation` 同时发生的情况，或者如果步骤 3 进入了带有 `gate` 或 `latch` 的并行回调的分支，还有……不行，我脑子转不动了，你怎么样？！

现在你抓住重点了吗？我们的顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码。这就是回调方式最主要的缺陷：对于它们在代码中表达异步的方式，我们的大脑需要努力才能同步得上。

## 3.信任问题

顺序的人脑计划和回调驱动的异步 JavaScript 代码之间的不匹配只是回调问题的一部分。还有一些更深入的问题需要考虑。

让我们再次思考一下程序中把回调当作 `continuation`（也就是后半部分）的概念：

```js
// A
ajax( "..", function(..){
 // C
} );
// B
```

`// A` 和 `// B` 发生于现在，在 JavaScript 主程序的直接控制之下。而 `// C` 会延迟到将来发生，并且是在第三方的控制下——在本例中就是函数 `ajax(..)`。从根本上来说，这种控制的转移通常不会给程序带来很多问题。

但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候 `ajax(..)`（也就是你交付回调 continuation 的第三方）不是你编写的代码，也不在你的直接控制下。多数情况下，它是某个第三方提供的工具。

我们把这称为 **控制反转**（inversion of control），也就是把自己程序一部分的执行控制交给某个第三方。在你的代码和第三方工具（一组你希望有人维护的东西）之间有一份并没有明确表达的契约。
