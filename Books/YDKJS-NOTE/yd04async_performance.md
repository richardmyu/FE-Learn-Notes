# 异步和性能

## 1. 异步：将来和现在

使用像 JavaScript 这样的语言编程时，很重要但常常被误解的一点是，如何表达和控制持续一段时间的程序行为。

这不仅仅是指从 `for` 循环开始到结束的过程，当然这也需要持续一段时间（几微秒或几毫秒）才能完成。它是指程序的一部分现在运行，而另一部分则在将来运行——现在和将来之间有段间隙，在这段间隙中，程序没有活跃执行。

事实上，程序中现在运行的部分和将来运行的部分之间的关系就是异步编程的核心。

### 1.1. 分块的程序

最常见的块单位是函数。

大多数 JavaScript 新手程序员都会遇到的问题是：程序中将来执行的部分并不一定在现在运行的部分执行完之后就立即执行。换句话说，现在无法完成的任务将会异步完成，因此并不会出现人们本能地认为会出现的或希望出现的阻塞行为。

考虑：

```js
// ajax() 是某个库中提供的某个 Ajax 函数
var data = ajax( "http://some.url.1" );
console.log( data );
// 啊哦！data 通常不会包含 Ajax 结果
```

你可能已经了解，标准 Ajax 请求不是同步完成的，这意味着 `ajax()` 函数还没有返回任何值可以赋给变量 `data`。如果 `ajax()` 能够阻塞到响应返回，那么 `data = ..` 赋值就会正确工作。

但我们并不是这么使用 Ajax 的。现在我们发出一个异步 Ajax 请求，然后在将来才能得到返回的结果。

从现在到将来的“等待”，最简单的方法（但绝对不是唯一的，甚至也不是最好的！）是使用一个通常称为回调函数的函数：

```js
// ajax() 是某个库中提供的某个 Ajax 函数
ajax( "http://some.url.1", function myCallbackFunction(data){
 console.log( data ); // 耶！这里得到了一些数据！
} );
```

> 可能你已经听说过，可以发送同步 Ajax 请求。尽管技术上说是这样，但是，在任何情况下都不应该使用这种方式，因为它会锁定浏览器 UI（按钮、菜单、滚动条等），并阻塞所有的用户交互。这是一个可怕的想法，一定要避免。

任何时候，只要把一段代码包装成一个函数，并指定它在响应某个事件（定时器、鼠标点击、Ajax 响应等）时执行，你就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制。

### 1.2. 事件循环

尽管你显然能够编写异步 JavaScript 代码（就像前面我们看到的定时代码），但直到最近（ES6），JavaScript 才真正内建有直接的异步概念。

JavaScript 引擎并不是独立运行的，它运行在宿主环境中，对多数开发者来说通常就是 Web 浏览器。经过最近几年（不仅于此）的发展，JavaScript 已经超出了浏览器的范围，
进入了其他环境，比如通过像 Node.js 这样的工具进入服务器领域。实际上，JavaScript 现如今已经嵌入到了从机器人到电灯泡等各种各样的设备中。

但是，所有这些环境都有一个共同“点”（thread，也指线程），即它们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎，这种机制被称为 **事件循环**。

> 一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 `tick`。用户交互、IO 和定时器会向事件队列中加入事件。
> 任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一个或多个后续事件。

换句话说，JavaScript 引擎本身并没有时间的概念，只是一个按需执行 JavaScript 任意代码片段的环境。“事件”（JavaScript 代码执行）调度总是由包含它的环境进行。

所以，举例来说，如果你的 JavaScript 程序发出一个 Ajax 请求，从服务器获取一些数据，那你就在一个函数（通常称为回调函数）中设置好响应代码，然后 JavaScript 引擎会通知宿主环境：“嘿，现在我要暂停执行，你一旦完成网络请求，拿到了数据，就请调用这个函数。”

然后浏览器就会设置侦听来自网络的响应，拿到要给你的数据之后，就会把回调函数插入到事件循环，以此实现对这个回调的调度执行。

那么，什么是事件循环？

先通过一段伪代码了解一下这个概念 :

```js
// eventLoop 是一个用作队列的数组
// （先进，先出）
var eventLoop = [];
var event;
// “永远”执行
while (true) {
  // 一次 tick
  if (eventLoop.length > 0) {
    // 拿到队列中的下一个事件
    event = eventLoop.shift();
    // 现在，执行下一个事件
    try {
      event();
    }
    catch (err) {
      reportError(err);
    }
  }
}
```

这当然是一段极度简化的伪代码，只用来说明概念。不过它应该足以用来帮助大家有更好的理解。

你可以看到，有一个用 `while` 循环实现的持续运行的循环。对每个 `tick` 而言，如果在队列中有等待事件，那么就会从队列中摘下一个事件并执行。这些事件就是你的回调函数。

一定要清楚，`setTimeout()` 并没有把你的回调函数挂在事件循环队列中。它所做的是设定一个定时器。当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的 `tick` 会摘下并执行这个回调。

如果这时候事件循环中已经有 20 个项目了会怎样呢？你的回调就会等待。它得排在其他项目后面——通常没有抢占式的方式支持直接将其排到队首。这也解释了为什么 `setTimeout()` 定时器的精度可能不高。大体说来，只能确保你的回调函数不会在指定的时间间隔之前运行，但可能会在那个时刻运行，也可能在那之后运行，要根据事件队列的状态而定。

所以换句话说就是，程序通常分成了很多小块，在事件循环队列中一个接一个地执行。严格地说，和你的程序不直接相关的其他事件也可能会插入到队列中。

> 前面提到的“直到最近”是指 ES6 从本质上改变了在哪里管理事件循环。本来它几乎已经是一种正式的技术模型了，但现在 ES6 精确指定了事件循环的工作细节，这意味着在技术上将其纳入了 JavaScript 引擎的势力范围，而不是只由宿主环境来管理。这个改变的一个主要原因是 ES6 中 `Promise` 的引入，因为这项技术要求对事件循环队列的调度运行能够直接进行精细控制。

### 1.3. 并行线程

术语“异步”和“并行”常常被混为一谈，但实际上它们的意义完全不同。记住，**异步**是关于【现在和将来的时间间隙】，而**并行**是关于能够【同时发生】的事情。

并行计算最常见的工具就是进程和线程。进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。

与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。

并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的。

举例来说：

```js
function later() {
  answer = answer * 2;
  console.log( "Meaning of life:", answer );
}
```

尽管 `later()` 的所有内容被看作单独的一个事件循环队列表项，但如果考虑到这段代码是运行在一个线程中，实际上可能有很多个不同的底层运算。比如，`answer = answer * 2` 需要先加载 `answer` 的当前值，然后把 2 放到某处并执行乘法，取得结果之后保存回 `answer` 中。

在单线程环境中，线程队列中的这些项目是底层运算确实是无所谓的，因为线程本身不会被中断。但如果是在并行系统中，同一个程序中可能有两个不同的线程在运转，这时很可能就会得到不确定的结果。

```js
var a = 20;
function foo() {
  a = a + 1;
}
function bar() {
  a = a * 2;
}
// ajax() 是某个库中提供的某个 Ajax 函数
ajax("http://some.url.1", foo);
ajax("http://some.url.2", bar);
```

根据 JavaScript 的单线程运行特性，如果 `foo()` 运行在 `bar()` 之前，`a` 的结果是 `42`，而如果 `bar()` 运行在 `foo()` 之前的话，`a` 的结果就是 `41`。

如果共享同一数据的 JavaScript 事件并行执行的话，那么问题就变得更加微妙了。考虑 `foo()` 和 `bar()` 中代码运行的线程分别执行的是以下两段伪代码任务，然后思考一下如果它们恰好同时运行的话会出现什么情况。

线程 1（X 和 Y 是临时内存地址）：

```mk
foo():
  a. 把 a 的值加载到 X
  b. 把 1 保存在 Y
  c. 执行 X 加 Y，结果保存在 X
  d. 把 X 的值保存在 a
```

线程 2（X 和 Y 是临时内存地址）：

```mk
bar():
  a. 把 a 的值加载到 X
  b. 把 2 保存在 Y
  c. 执行 X 乘 Y，结果保存在 X
  d. 把 X 的值保存在 a
```

现在，假设两个线程并行执行。你可能已经发现了这个程序的问题，是吧？它们在临时步骤中使用了共享的内存地址 X 和 Y。

如果按照以下步骤执行，最终结果将会是什么样呢？

```mk
1a （把 a 的值加载到 X ==> 20)
2a （把 a 的值加载到 X ==> 20)
1b （把 1 保存在 Y ==> 1)
2b （把 2 保存在 Y ==> 2)
1c （执行 X 加 Y，结果保存在 X ==> 22)
1d （把 X 的值保存在 a ==> 22)
2c （执行 X 乘 Y，结果保存在 X ==> 44)
2d （把 X 的值保存在 a ==> 44)
```

a 的结果将是 44。但如果按照以下顺序执行呢？

```mk
1a （把 a 的值加载到 X ==> 20)
2a （把 a 的值加载到 X ==> 20)
2b （把 2 保存在 Y ==> 2)
1b （把 1 保存在 Y ==> 1)
2c （执行 X 乘 Y，结果保存在 X ==> 20)
1c （执行 X 加 Y，结果保存在 X ==> 21)
1d （把 X 的值保存在 a ==> 21)
2d （把 X 的值保存在 a ==> 21)
```

a 的结果将是 21。

所以，多线程编程是非常复杂的。因为如果不通过特殊的步骤来防止这种中断和交错运行的话，可能会得到出乎意料的、不确定的行为，通常这很让人头疼。

JavaScript 从不跨线程共享数据，这意味着不需要考虑这一层次的不确定性。但是这并不意味着 JavaScript 总是确定性的。回忆一下前面提到的，`foo()` 和 `bar()` 的相对顺序改变可能会导致不同结果（41 或 42）。

- **完整运行**

由于 JavaScript 的单线程特性，`foo()`（以及 `bar()`）中的代码具有【原子性】。也就是说，一旦 `foo()` 开始运行，它的所有代码都会在 `bar()` 中的任意代码运行之前完成，或者相反。这称为 **完整运行（run-to-completion）** 特性。

同一段代码有两个可能输出意味着还是存在不确定性！但是，这种不确定性是在函数（事件）顺序级别上，而不是多线程情况下的语句顺序级别（或者说，表达式运算顺序级别）。换句话说，这一确定性要高于多线程情况。

在 JavaScript 的特性中，这种【函数顺序的不确定性】就是通常所说的 **竞态条件（racecondition）**，`foo()` 和 `bar()` 相互竞争，看谁先运行。具体来说，因为无法可靠预测 `a` 和 `b` 的最终结果，所以才是竞态条件。

> 如果 JavaScript 中的某个函数由于某种原因不具有完整运行特性，那么可能的结果就会多得多，对吧？实际上，ES6 就引入了这么一个东西！

### 1.4. 并发

现在让我们来设想一个展示状态更新列表的网站，其随着用户向下滚动列表而逐渐加载更多内容。要正确地实现这一特性，需要（至少）两个独立的“进程”同时运行（也就是说，是在同一段时间内，并不需要在同一时刻）。

> 这里的“进程”之所以打上引号，是因为这并不是计算机科学意义上的真正操作系统级进程。这是虚拟进程，或者任务，表示一个逻辑上相关的运算序列。之所以使用“进程”而不是“任务”，是因为从概念上来讲，“进程”的定义更符合这里我们使用的意义。

第一个“进程”在用户向下滚动页面触发 `onscroll` 事件时响应这些事件（发起 Ajax 请求要求新的内容）。第二个“进程”接收 Ajax 响应（把内容展示到页面）。

显然，如果用户滚动页面足够快的话，在等待第一个响应返回并处理的时候可能会看到两个或更多 `onscroll` 事件被触发，因此将得到快速触发彼此交替的 `onscroll` 事件和 Ajax 响应事件。

两个或多个“进程”同时执行就出现了并发，不管组成它们的单个运算是否并行执行（在独立的处理器或处理器核心上同时运行）。可以把并发看作“进程”级（或者任务级）的并行，与运算级的并行（不同处理器上的线程）相对。

> **并发** 是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时在运行（尽管在任意时刻只处理一个事件）。

很可能某个 `onscroll` 事件和某个 Ajax 响应事件恰好同时可以处理。举例来说，假设这些事件的时间线是这样的：

```mk
onscroll, 请求 1
onscroll, 请求 2 响应 1
onscroll, 请求 3 响应 2
响应 3
onscroll, 请求 4
onscroll, 请求 5
onscroll, 请求 6 响应 4
onscroll, 请求 7
响应 6
响应 5
响应 7
```

但是，本章前面介绍过事件循环的概念，JavaScript 一次只能处理一个事件，所以要么是 `onscroll，请求 2` 先发生，要么是 `响应 1` 先发生，但是不会严格地同时发生。这就像学校食堂的孩子们，不管在门外多么拥挤，最终他们都得站成一队才能拿到自己的午饭！

下面列出了事件循环队列中所有这些交替的事件：

```mk
onscroll, 请求 1 <--- 进程 1 启动
onscroll, 请求 2
响应 1           <--- 进程 2 启动
onscroll, 请求 3
响应 2
响应 3
onscroll, 请求 4
onscroll, 请求 5
onscroll, 请求 6
响应 4
onscroll, 请求 7 <--- 进程 1 结束
响应 6
响应 5
响应 7           <--- 进程 2 结束
```

“进程”1 和“进程”2 并发运行（任务级并行），但是它们的各个事件是在事件循环队列中依次运行的。

另外，注意到响应 6 和响应 5 的返回是乱序的了吗？

单线程事件循环是并发的一种形式。

#### 1.4.1. 非交互

两个或多个“进程”在同一个程序内并发地交替运行它们的 步骤 / 事件 时，如果这些任务彼此不相关，就不一定需要交互。如果进程间没有相互影响的话，不确定性是完全可以接受的。

举例来说：

```js
var res = {};
function foo(results) {
 res.foo = results;
}
function bar(results) {
 res.bar = results;
}

ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

`foo()` 和 `bar()` 是两个并发执行的“进程”，按照什么顺序执行是不确定的。但是，我们构建程序的方式使得无论按哪种顺序执行都无所谓，因为它们是独立运行的，不会相互影响。

这并不是竞态条件 bug，因为不管顺序如何，代码总会正常工作。

#### 1.4.2. 交互

更常见的情况是，并发的“进程”需要相互交流，通过作用域或 DOM 间接交互。正如前面介绍的，如果出现这样的交互，就需要对它们的交互进行协调以避免竞态的出现。

下面是一个简单的例子，两个并发的“进程”通过隐含的顺序相互影响，这个顺序有时会被破坏：

```js
var res = [];
function response(data) {
 res.push( data );
}

ajax( "http://some.url.1", response );
ajax( "http://some.url.2", response );
```

这里的并发“进程”是这两个用来处理 Ajax 响应的 `response()` 调用。它们可能以任意顺序运行。

我们假定期望的行为是 `res[0]` 中放调用 `"http://some.url.1"` 的结果，`res[1]` 中放调用 `"http://some.url.2"` 的结果。有时候可能是这样，但有时候却恰好相反，这要视哪个调用先完成而定。

这种不确定性很有可能就是一个竞态条件 bug。

> 在这些情况下，你对可能做出的假定要持十分谨慎的态度。比如，开发者可能会观察到对 `"http://some.url.2"` 的响应速度总是显著慢于对 `"http://some.url.1"` 的响应，这可能是由它们所执行任务的性质决定的（比如，一个执行数据库任务，而另一个只是获取静态文件），所以观察到的顺序总是符合预期。即使两个请求都发送到同一个服务器，也总会按照固定的顺序响应，但对于响应返回浏览器的顺序，却没有人可以真正保证。

所以，可以协调交互顺序来处理这样的竞态条件：

```js
var res = [];
function response(data) {
  if (data.url == "http://some.url.1") {
    res[0] = data;
  } else if (data.url == "http://some.url.2") {
    res[1] = data;
  }
}

ajax( "http://some.url.1", response );
ajax( "http://some.url.2", response );
```

不管哪一个 Ajax 响应先返回，我们都要通过查看 `data.url`（当然，假定从服务器总会返回一个！）判断应该把响应数据放在 `res` 数组中的什么位置上。`res[0]` 总是包含 `"http://some.url.1"` 的结果，`res[1]` 总是包含 `"http://some.url.2"` 的结果。通过简单的协调，就避免了竞态条件引起的不确定性。

从这个场景推出的方法也可以应用于多个并发函数调用通过共享 DOM 彼此之间交互的情况，比如一个函数调用更新某个 `<div>` 的内容，另外一个更新这个 `<div>` 的风格或属性（比如使这个 DOM 元素一有内容就显示出来）。可能你并不想在这个 DOM 元素在拿到内容之前显示出来，所以这种协调必须要保证正确的交互顺序。

有些并发场景如果不做协调，就总是（并非偶尔）会出错。考虑：

```js
var a, b;
function foo(x) {
  a = x * 2;
  baz();
}
function bar(y) {
  b = y * 2;
  baz();
}
function baz() {
  console.log(a + b);
}

ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

在这个例子中，无论 `foo()` 和 `bar()` 哪一个先被触发，总会使 `baz()` 过早运行（`a` 或者 `b` 仍处于未定义状态）；但对 `baz()` 的第二次调用就没有问题，因为这时候 `a` 和 `b` 都已经可用了。

要解决这个问题有多种方法。这里给出了一种简单方法：

```js
var a, b;
function foo(x) {
  a = x * 2;
  if (a && b) {
    baz();
  }
}
function bar(y) {
  b = y * 2;
  if (a && b) {
    baz();
  }
}
function baz() {
  console.log( a + b );
}

ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

包裹 `baz()` 调用的条件判断 `if (a && b)` 传统上称为 **门（gate）**，我们虽然不能确定 `a` 和 `b` 到达的顺序，但是会等到它们两个都准备好再进一步打开门（调用 `baz()`）。

另一种可能遇到的并发交互条件有时称为 **竞态（race）**，但是更精确的叫法是 **门闩（latch）**。它的特性可以描述为“只有第一名取胜”。在这里，不确定性是可以接受的，因为它明确指出了这一点是可以接受的：需要“竞争”到终点，且只有唯一的胜利者。

请思考下面这段有问题的代码：

```js
var a;
function foo(x) {
  a = x * 2;
  baz();
}
function bar(x) {
  a = x / 2;
  baz();
}
function baz() {
  console.log( a );
}

ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

不管哪一个（`foo()` 或 `bar()`）后被触发，都不仅会覆盖另外一个给 `a` 赋的值，也会重复调用 `baz()`（很可能并不是想要的结果）。

所以，可以通过一个简单的门闩协调这个交互过程，只让第一个通过：

```js
var a;
function foo(x) {
  if (!a) {
    a = x * 2;
    baz();
  }
}
function bar(x) {
  if (!a) {
    a = x / 2;
    baz();
  }
}
function baz() {
  console.log( a );
}

ajax( "http://some.url.1", foo );
ajax( "http://some.url.2", bar );
```

条件判断 `if (!a)` 使得只有 `foo()` 和 `bar()` 中的第一个可以通过，第二个（实际上是任何后续的）调用会被忽略。也就是说，第二名没有任何意义！

#### 1.4.3. 协作

还有一种并发合作方式，称为 **并发协作（cooperative concurrency）**。这里的重点不再是通过共享作用域中的值进行交互（尽管显然这也是允许的！）。这里的目标是取到一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行。

举例来说，考虑一个需要遍历很长的结果列表进行值转换的 Ajax 响应处理函数。我们会
使用 `Array#map()` 让代码更简洁：

```js
var res = [];
// response() 从 Ajax 调用中取得结果数组
function response(data) {
  // 添加到已有的 res 数组
  res = res.concat(
    // 创建一个新的变换数组把所有 data 值加倍
    data.map( function(val){
      return val * 2;
    } )
  );
}

ajax( "http://some.url.1", response );
ajax( "http://some.url.2", response );
```

如果 `"http://some.url.1"` 首先取得结果，那么整个列表会立刻映射到 `res` 中。如果记录有几千条或更少，这不算什么。但是如果有像 1000 万条记录的话，就可能需要运行相当一段时间了（在高性能笔记本上需要几秒钟，在移动设备上需要更长时间，等等）。

这样的“进程”运行时，页面上的其他代码都不能运行，包括不能有其他的 `response()` 调用或 UI 刷新，甚至是像滚动、输入、按钮点击这样的用户事件。这是相当痛苦的。

所以，要创建一个协作性更强更友好且不会霸占事件循环队列的并发系统，你可以异步地批处理这些结果。每次处理之后返回事件循环，让其他等待事件有机会运行。

这里给出一种非常简单的方法：

```js
var res = [];
// response() 从 Ajax 调用中取得结果数组
function response(data) {
  // 一次处理 1000 个
  var chunk = data.splice( 0, 1000 );
  // 添加到已有的 res 组
  res = res.concat(
    // 创建一个新的数组把 chunk 中所有值加倍
    chunk.map( function(val){
      return val * 2;
    } )
  );
  // 还有剩下的需要处理吗？
  if (data.length > 0) {
    // 异步调度下一次批处理
    setTimeout( function(){
      response( data );
    }, 0 );
  }
}

ajax( "http://some.url.1", response );
ajax( "http://some.url.2", response );
```

我们把数据集合放在最多包含 1000 条项目的块中。这样，我们就确保了“进程”运行时间会很短，即使这意味着需要更多的后续“进程”，因为事件循环队列的交替运行会提高站点 /App 的响应（性能）。

当然，我们并没有协调这些“进程”的顺序，所以结果的顺序是不可预测的。如果需要排序的话，就要使用和前面提到类似的交互技术，或者后面章节将要介绍的技术。这里使用 `setTimeout(..0)（hack）` 进行异步调度，基本上它的意思就是“把这个函数插入到当前事件循环队列的结尾处”。

> 严格说来，`setTimeout(..0)` 并不直接把项目插入到事件循环队列。定时器会在有机会的时候插入事件。举例来说，两个连续的 `setTimeout(..0)` 调用不能保证会严格按照调用顺序处理，所以各种情况都有可能出现，比如定时器漂移，在这种情况下，这些事件的顺序就不可预测。在 Node.js 中，类似的方法是 `process.nextTick()`。尽管它们使用方便（通常性能也更高），但并没有（至少到目前为止）直接的方法可以适应所有环境来确保异步事件的顺序。

### 1.5. 任务

在 ES6 中，有一个新的概念建立在事件循环队列之上，叫作 **任务队列（job queue）**。这个概念给大家带来的最大影响可能是 `Promise` 的异步特性。

遗憾的是，目前为止，这是一个没有公开 API 的机制，因此要展示清楚有些困难。所以我们目前只从概念上进行描述，等到讨论 `Promise` 的异步特性时，你就会理解这些动作是如何协调和处理的。

因此，我认为对于任务队列最好的理解方式就是，它是挂在事件循环队列的每个 `tick` 之后的一个队列。在事件循环的每个 `tick` 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前 `tick` 的任务队列末尾添加一个项目（一个任务）。这就像是在说：“哦，这里还有一件事将来要做，但要确保在其他任何事情发生之前就完成它。”

事件循环队列类似于一个游乐园游戏：玩过了一个游戏之后，你需要重新到队尾排队才能再玩一次。而任务队列类似于玩过了游戏之后，插队接着继续玩。

一个任务可能引起更多任务被添加到同一个队列末尾。所以，理论上说，**任务循环（job loop）** 可能无限循环（一个任务总是添加另一个任务，以此类推），进而导致程序的饿死，无法转移到下一个事件循环 `tick`。从概念上看，这和代码中的无限循环（就像 `while(true)..）` 的体验几乎是一样的。

任务和 `setTimeout(..0) hack` 的思路类似，但是其实现方式的定义更加良好，对顺序的保证性更强：尽可能早的将来。

设想一个调度任务（直接地，不要 hack）的 API，称其为 `schedule()`。考虑：

```js
console.log( "A" );
setTimeout( function(){
  console.log( "B" );
}, 0 );

// 理论上的"任务 API"
schedule( function(){
  console.log( "C" );
  schedule( function(){
    console.log( "D" );
  } );
} );
```

可能你认为这里会打印出 A B C D，但实际打印的结果是 A C D B。因为任务处理是在当前事件循环 `tick` 结尾处，且定时器触发是为了调度下一个事件循环 `tick`（如果可用的话！）。

> 我们将会看到，`Promise` 的异步特性是基于任务的，所以一定要清楚它和事件循环特性的关系。

### 1.6. 语句顺序

代码中语句的顺序和 JavaScript 引擎执行语句的顺序并不一定要一致。这个陈述可能看起来似乎会很奇怪，所以我们要简单解释一下。

但在此之前，以下这一点我们应该完全清楚：这门语言的规则和语法已经从程序的角度在语序方面规定了可预测和非常可靠的特性。所以，接下来我们要讨论的内容你应该无法在自己的 JavaScript 程序中观察到。

> 如果你观察到了类似于我们将要展示的编译器对语句的重排序，那么这很明显违反了规范，而这一定是由所使用的 JavaScript 引擎中的 bug 引起的——该 bug 应该被报告和修正！但是更可能的情况是，当你怀疑 JavaScript 引擎做了什么疯狂的事情时，实际上却是你自己代码中的 bug（可能是竞态条件）引起的。所以首先要检查自己的代码，并且要反复检查。通过使用断点和单步执行一行一行地遍历代码，JavaScript 调试器就是用来发现这样 bug 的最强大工具。

```js
var a, b;
a = 10;
b = 30;
a = a + 1;
b = b + 1;
console.log( a + b ); // 42
```

这段代码中没有显式的异步（除了前面介绍过的很少见的异步 I/O ！），所以很可能它的执行过程是从上到下一行行进行的。

但是，JavaScript 引擎在编译这段代码之后可能会发现通过（安全地）重新安排这些语句的顺序有可能提高执行速度。重点是，只要这个重新排序是不可见的，一切都没问题。

比如，引擎可能会发现，其实这样执行会更快：

```js
var a, b;
a = 10;
a++;
b = 30;
b++;
console.log( a + b ); // 42

// or
var a, b;
a = 11;
b = 31;
console.log( a + b ); // 42

// or
// 因为 a 和 b 不会被再次使用
// 我们可以 inline，从而完全不需要它们！
console.log( 42 ); // 42
```

前面的所有情况中，JavaScript 引擎在编译期间执行的都是安全的优化，最后可见的结果都是一样的。

但是这里有一种场景，其中特定的优化是不安全的，因此也是不允许的（当然，不用说这其实也根本不能称为优化）：

```js
var a, b;
a = 10;
b = 30;

// 我们需要 a 和 b 处于递增之前的状态！
console.log( a * b ); // 300

a = a + 1;
b = b + 1;

console.log( a + b ); // 42
```

还有其他一些例子，其中编译器重新排序会产生可见的副作用（因此必须禁止），比如会产生副作用的函数调用（特别是 `getter` 函数），或 ES6 代理对象。

考虑：

```js
function foo() {
  console.log( b );
  return 1;
}

var a, b, c;

// ES5.1 getter 字面量语法
c = {
  get bar() {
    console.log( a );
    return 1;
  }
};

a = 10;
b = 30;

a += foo(); // 30
b += c.bar; // 11

console.log( a + b ); // 42
```

如果不是因为代码片段中的语句 `console.log()`（只是作为一种方便的形式说明可见的副作用），JavaScript 引擎如果愿意的话，本来可以自由地把代码重新排序如下：

```js
// ...
a = 10 + foo();
b = 30 + c.bar;
// ...
```

尽管 JavaScript 语义让我们不会见到编译器语句重排序可能导致的噩梦，这是一种幸运，但是代码编写的方式（从上到下的模式）和编译后执行的方式之间的联系非常脆弱，理解这一点也非常重要。

编译器语句重排序几乎就是并发和交互的微型隐喻。作为一个一般性的概念，清楚这一点能够使你更好地理解异步 JavaScript 代码流问题。

## 2. 回调

在所有这些示例中，函数都是作为回调（callback）使用的，因为它是事件循环“回头调用”到程序中的目标，队列处理到这个项目的时候会运行它。

到目前为止，回调是编写和处理 JavaScript 程序异步逻辑的最常用方式。确实，回调是这门语言中最基础的异步模式。

无数 JavaScript 程序，甚至包括一些最为高深和复杂的，所依赖的异步基础也仅限于回调。回调函数是 JavaScript 的异步主力军，并且它们不辱使命地完成了自己的任务。

但是……回调函数也不是没有缺点。很多开发者因为更好的异步模式 `promise` 而激动不已。但是，只有理解了某种抽象的目标和原理，才能有效地应用这种抽象机制。

### 2.1.continuation

让我们回到的异步回调的例子，为了突出重点，以下稍作了修改：

```js
// A
ajax( "..", function(){
 // C
} );
// B
```

`// A` 和 `// B` 表示程序的前半部分（也就是现在的部分），而 `// C` 标识了程序的后半部分（也就是将来的部分）。前半部分立刻执行，然后是一段时间不确定的停顿。在未来的某个时刻，如果 Ajax 调用完成，程序就会从停下的位置继续执行后半部分。换句话说，回调函数包裹或者说封装了程序的 **延续（continuation）**。让我们进一步简化这段代码：

```js
// A
setTimeout( function(){
 // C
}, 1000 );
// B
```

请在这里稍作停留，思考一下你自己会如何（向对 JavaScript 运作机制不甚了解的某位人士）描述这段程序的运行方式。然后试着把你的描述大声说出来。这有助于你理解我接下来要展示的要点。

大多数人刚才可能想到或说出的内容会类似于“执行 A，然后设定一个延时等待 1000 毫秒，到时后马上执行 C”。你的描述准确度如何呢？

也可能进一步修改为“执行 A，设定延时 1000 毫秒，然后执行 B，然后定时到时后执行 C”。这比第一个版本要更精确一些。你能指出其中的区别吗？

尽管第二个版本更精确一些，但是在匹配大脑对这段代码的理解和代码对于 JavaScript 引擎的意义方面，两个版本对这段代码的解释都有不足。这种不匹配既微妙又显著，也正是理解回调作为异步表达和管理方式的缺陷的关键所在。

一旦我们以回调函数的形式引入了单个 `continuation`（或者几十个，就像很多程序所做的那样！），我们就容许了大脑工作方式和代码执行方式的分歧。一旦这两者出现分歧（这远不是这种分歧出现的唯一情况，我想你明白这一点！），我们就得面对这样一个无法逆转的事实：代码变得更加难以理解、追踪、调试和维护。

### 2.2. 顺序的大脑

我们在假装并行执行多个任务时，实际上极有可能是在进行快速的上下文切换，比如与朋友或家人电话聊天的同时还试图打字。换句话说，我们是在两个或更多任务之间快速连续地来回切换，同时处理每个任务的微小片段。我们切换得如此之快，以至于对外界来说，我们就像是在并行地执行所有任务。

这听起来是不是和异步事件并发机制（比如 JavaScript 中的形式）很相似呢？

#### 2.2.1. 执行与计划

对我们程序员来说，编写异步事件代码，特别是当回调是唯一的实现手段时，困难之处就在于这种思考 / 计划的意识流对我们中的绝大多数来说是不自然的。

我们的思考方式是一步一步的，但是从同步转换到异步之后，可用的工具（回调）却不是按照一步一步的方式来表达的。

这就是为什么精确编写和追踪使用回调的异步 JavaScript 代码如此之难：因为这并不是我们大脑进行计划的运作方式。

#### 2.2.2. 嵌套回调与链式回调

考虑：

```js
listen("click", function handler(evt) {
  setTimeout(function request() {
    ajax("http://some.url.1", function response(text) {
      if (text == "hello") {
        handler();
      } else if (text == "world") {
        request();
      }
    });
  }, 500);
});
```

你很可能非常熟悉这样的代码。这里我们得到了三个函数嵌套在一起构成的链，其中每个函数代表异步序列（任务，“进程”）中的一个步骤。

这种代码常常被称为 **回调地狱（callback hell）**，有时也被称为 **毁灭金字塔**（pyramid of doom，得名于嵌套缩进产生的横向三角形状）。

一开始我们在等待 click 事件，然后等待定时器启动，然后等待 Ajax 响应返回，之后可能再重头开始。

一眼看去，这段代码似乎很自然地将其异步性映射到了顺序大脑计划。

首先（现在）我们有：

```js
listen( "..", function handler(){
 // ..
} );
```

然后是将来，我们有：

```js
setTimeout( function request(){
 // ..
}, 500) ;
```

接着还是将来，我们有：

```js
ajax( "..", function response(){
 // ..
} );
```

最后（最晚的将来），我们有：

```js
if ( .. ) {
 // ..
} else ..
```

但以这种方式线性地追踪这段代码还有几个问题。

首先，例子中的步骤是按照 1、2、3、4……的顺序，这只是一个偶然。实际的异步 JavaScript 程序中总是有很多噪声，使得代码更加杂乱。

另外，其中还有一个隐藏更深的错误，但在代码例子中，这个错误并不明显。我们另外设计一个场景（伪代码）来展示这一点：

```js
doA(function () {
  doB();
  doC(function () {
    doD();
  })
  doE();
});
doF();
```

尽管有经验的你能够正确确定实际的运行顺序，但我敢打赌，这比第一眼看上去要复杂一些，需要费一番脑筋才能想清楚。实际运行顺序是这样的：

```mk
• doA()
• doF()
• doB()
• doC()
• doE()
• doD()
```

但即使你能够很轻松地得出结论，还是有一个可能导致严重问题的风险。如果 `doA(..)` 或 `doD(..)` 实际并不像我们假定的那样是异步的，情况会如何呢？啊，那顺序就更麻烦了。

问题是出在嵌套上吗？是它导致跟踪异步流如此之难吗？确实，部分原因是这样。但是，让我们不用嵌套再把前面的嵌套事件 / 超时 /Ajax 的例子重写一遍吧：

```js
listen("click", handler);

function handler() {
  setTimeout(request, 500);
}

function request() {
  ajax("http://some.url.1", response);
}

function response(text) {
  if (text == "hello") {
    handler();
  } else if (text == "world") {
    request();
  }
}
```

这种组织形式的代码不像前面以嵌套 / 缩进的形式组织的代码那么容易识别了，但是它和回调地狱一样脆弱，易受影响。为什么？

在线性（顺序）地追踪这段代码的过程中，我们不得不从一个函数跳到下一个，再跳到下一个，在整个代码中跳来跳去以“查看”流程。而且别忘了，这还是简化的形式，只考虑了最优情况。我们都知道，真实的异步 JavaScript 程序代码要混乱得多，这使得这种追踪的难度会成倍增加。

还有一点需要注意：要把步骤 2、步骤 3 和步骤 4 连接在一起让它们顺序执行，只用回调的话，代价可以接受的唯一方式是把步骤 2 硬编码到步骤 1 中，步骤 3 硬编码到步骤 2 中，步骤 4 硬编码到步骤 3 中，以此类推。如果实际上步骤 2 总会引出步骤 3 是一个固定条件的话，硬编码本身倒不一定是坏事。

但是，硬编码肯定会使代码更脆弱一些，因为它并没有考虑可能导致步骤执行顺序偏离的异常情况。比如，如果步骤 2 失败，就永远不会到达步骤 3，不管是重试步骤 2，还是跳转到其他错误处理流程，等等。

这些问题都可以通过在每个步骤中手工硬编码来解决，但这样的代码通常是重复的，并且在程序中的其他异步流中或其他步骤中无法复用。

尽管我们的大脑能够以顺序的方式（这个，然后这个，然后这个）计划一系列任务，但大脑运作的事件化的本质使得控制流的恢复 / 重试 / 复制几乎不费什么力气。如果你出外办事的时候发现把购清单落在了家里，那么这一天并不会因为你没有预知到这一点就成为世界末日了。你的大脑很容易就能针对这个小意外做出计划：回家拿清单，然后立刻返回商店就是了。

但是，手工硬编码（即使包含了硬编码的出错处理）【回调的脆弱本性】可就远没有这么优雅了。一旦你指定（也就是预先计划）了所有的可能事件和路径，代码就会变得非常复杂，以至于无法维护和更新。

这才是回调地狱的真正问题所在！嵌套和缩进基本上只是转移注意力的枝节而已。如果这还不够的话，我们还没有提及两个或更多回调 `continuation` 同时发生的情况，或者如果步骤 3 进入了带有 `gate` 或 `latch` 的并行回调的分支，还有……不行，我脑子转不动了，你怎么样？！

现在你抓住重点了吗？我们的顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码。这就是回调方式最主要的缺陷：对于它们在代码中表达异步的方式，我们的大脑需要努力才能同步得上。

### 2.3. 信任问题

顺序的人脑计划和回调驱动的异步 JavaScript 代码之间的不匹配只是回调问题的一部分。还有一些更深入的问题需要考虑。

让我们再次思考一下程序中把回调当作 continuation（也就是后半部分）的概念：

```js
// A
ajax( "..", function(..){
 // C
} );
// B
```

`// A` 和 `// B` 发生于现在，在 JavaScript 主程序的直接控制之下。而 `// C` 会延迟到将来发生，并且是在第三方的控制下——在本例中就是函数 `ajax(..)`。从根本上来说，这种控制的转移通常不会给程序带来很多问题。

但是，请不要被这个小概率迷惑而认为这种控制切换不是什么大问题。实际上，这是回调驱动设计最严重（也是最微妙）的问题。它以这样一个思路为中心：有时候 `ajax(..)`（也就是你交付回调 continuation 的第三方）不是你编写的代码，也不在你的直接控制下。多数情况下，它是某个第三方提供的工具。

我们把这称为 **控制反转（inversion of control）**，也就是把自己程序一部分的执行控制交给某个第三方。在你的代码和第三方工具（一组你希望有人维护的东西）之间有一份并没有明确表达的契约。

## 3.promise

## 4. 生成器

## 5. 程序性能

## 6. 性能测试与调优
