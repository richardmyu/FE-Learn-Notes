<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>优化DOM操作-2</title>
</head>

<body>
  <div class="wrapper"></div>
  <script>
    /* 
    手动管理数据和 DOM 之间的关系会导致代码可维护性变差、容易出错。如何尽量减少这种手动 DOM 操作？

    这里要提出的一种解决方案：一旦状态发生改变，就重新调用 render 方法，构建一个新的 DOM 元素。这样做的好处是什么呢？好处就是你可以在 render 方法里面使用最新的 this.state 来构造不同 HTML 结构的字符串，并且通过这个字符串构造不同的 DOM 元素。页面就更新了！
     */
    const createDOMFromString = (domString) => {
      const div = document.createElement('div');
      div.innerHTML = domString;
      return div;
    };
    class LikeButton {
      constructor() {
        this.state = {
          isLiked: false
        }
        this.changeLikeText = this.changeLikeText.bind(this);
      }
      setState(state) {
        // this.state = state;
        // this.el = this.render();
        const oldEl = this.el;
        this.state = state;
        this.el = this.render();
        // 实例化以后时候被设置的，所以你可以自定义 onStateChange 的行为
        /* 
        每当 setState 中构造完新的 DOM 元素以后，就会通过 onStateChange 告知外部插入新的 DOM 元素，然后删除旧的元素，页面就更新了。这里已经做到了进一步的优化了：现在不需要再手动更新页面了。
        非一般的暴力，因为每次 setState 都重新构造、新增、删除 DOM 元素，会导致浏览器进行大量的重排，严重影响性能。不过没有关系，这种暴力行为可以被一种叫 Virtual-DOM 的策略规避掉
         */
        if (this.onStateChange) {
          // console.log(this.onStateChange);
          this.onStateChange(oldEl, this.el);
        }
      }
      changeLikeText() {
        // const likeText = this.el.querySelector('.like_text');
        // this.state.isLiked = !this.state.isLiked;
        // likeText.innerHTML = this.state.isLiked ? "取消" : "点赞"
        this.setState({
          isLiked: !this.state.isLiked
        })
      }
      render() {
        this.el = createDOMFromString(`
          <button id="like-btn">
            <span class="like_text">${this.state.isLiked ? "取消" : "点赞"}</span>
            <span>👍</span>
          </button>
        `)
        this.el.addEventListener("click", this.changeLikeText, false);
        return this.el;
      }
    }
    const wrapper = document.querySelector(".wrapper");
    const likeButton = new LikeButton();
    wrapper.appendChild(likeButton.render());//第一次插入DOM
    likeButton.onStateChange = (oldEl, newEl) => {
      wrapper.insertBefore(newEl, oldEl);//插入新DOM
      wrapper.removeChild(oldEl);//删除原DOM
    }
  </script>
</body>

</html>