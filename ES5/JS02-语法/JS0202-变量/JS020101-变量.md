# 变量

照 ECMA-262 的定义，JavaScript 的变量与其他语言的变量有很大区别。JavaScript 变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某种角度看，这可能是一个既有趣又强大，同时又容易出问题的特性，但 JavaScript 变量实际的复杂程度还远不止如此。

> ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。

在 JavaScript 程序中，使用一个变量之前应当先声明。定义变量时要使用 `var` 操作符（注意 `var` 是一个关键字），后跟变量名（即一个标识符）。

- 命名规范

1. 严格区分大小写；
2. 可以使用数字（但不能作为首位）、字母、下划线、`$`；
3. 不能使用关键字和保留字；

## 1.`var`

1).用来声明一个变量（对于未经初始化的变量，会保存一个特殊的值：`undefined` ），可以重复声明；

2).使用 `var` 声明的变量会自动添加到最接近的环境中，若初始化变量没有使用 `var` 声明，则会默认添加到全局环境；

> 在全局上下文中，使用 `var` 声明的变量将作为全局对象的不可配置属性被添加。这意味着它的属性描述符无法被修改，也无法使用 `delete` 删除。其对应的名字也将被添加到 **全局环境记录**（global environment record）（它构成了 **全局词法环境**（global lexical environment）的一部分）的 `[[VarNames]]` 插槽内的列表中。`[[VarNames]]` 中的命名列表使运行时能够区分“全局变量”和“全局对象的直接属性”。
> 全局变量（以全局对象的属性的形式被创建）不可配置的原因是：该标识符被视为一个变量，而不是全局对象的直接属性。JavaScript 具有自动化的内存管理机制，因此“能够使用 `delete` 删除全局变量”是没有意义的。

3).用 `var` 操作符定义的变量将成为定义该变量的作用域中的局部变量，在该作用域之外无法访问该变量。也就是说，如果在函数中使用 `var` 定义一个变量，那么这个变量在函数退出后就会被销毁；

4).可以用一条语句定义多个变量，用逗号隔开（因为 ECMAScript 的变量是松散类型的，所以不同类型初始化变量的操作可以放在一条语句中来完成）；

5).严格地说，`var a = 1` 与 `a = 1`，这两条语句的效果不完全一样，主要体现在 `delete` 命令无法删除前者（因为使用 `var` 声明变量，创建的属性是不可配置的）。不过，绝大多数情况下，这种差异是可以忽略的。

```js
// 未初始化变量
var a;
console.log(a); // undefined

// 全局（非严格模式），
// 显示使用 var 和 不使用 var
// 给一个未声明的变量赋值，
// 会自动创建一个全局变量，
// 且是正常的可配置属性
var b = 6;
c = 7;

// 都挂载 window 中
console.log(window.b); // 6
console.log(window.c); // 7

// delete 无法删除 var 声明的变量
console.log(delete b); // false
console.log(delete c); // true

console.log(b); // 6
console.log(c); // undefined


// 变量的作用域
function fn() {
  var d = 12;
}
console.log(d);
//Uncaught ReferenceError: d is not defined

// 逗号分隔（声明多个变量）
var str = "h",
  ary = ["e", "ll"],
  obj = {
    name: "o"
  };
console.log(str, ary, obj);
// h ["e", "ll"] {name: "o"}
```

> 严格模式下，不能定义 `eval` 或 `arguments` 的变量，否则导致语法错误（`Uncaught SyntaxError: Unexpected eval or arguments in strict mode`）。

虽然省略 `var` 操作符可以定义全局变量，但我们不推荐这种做法。因为在局部作用域中定义的全局变量很难维护，而且如果有意的忽略 `var` 操作符，也会由于相应的变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下会导致抛出 `ReferenceRrror` 错误。

全局变量是全局对象的属性，是 ECMAScript 规范强制规定的，而对于局部变量则没有如此规定。可以想象，局部变量当做跟函数调用相关的某个对象的属性。ECMAScript 3 规范称该对象为 “调用对象”（call object），ECMAScript 5 规范称为 “**声明上下文对象**”（declarative enviroment record）。

JavaScript 允许使用 `this` 关键字来引用全局对象，去没有方法可以引用局部变量存放的对象。这种存放局部变量的对象的特有性质，是一种对我们不可见的内部实现。

```js
var a = 12;
console.log(a); // 12
console.log(window.a); // 12
console.log(this.a); // 12
console.log(this);
// Window {window: Window, self: Window, document: document, name: '', location: Location, …}
```

## 2.声明提前

> 也有人称之为 “变量提升”。鉴于《JavaScript 权威指南》使用“声明提前”，本文就统称为“声明提前”。
>
> 在参考书中，没有看到具体对于“声明”和“定义”的区分，我感觉二者还是有一定的区分的。声明，只是使用关键字 `var` 标记一个变量，有没有赋值不重要，而定义，则意味着使用关键字标记变量的同时，还要给该变量一个初始值。但鉴于使用 `var` 关键字标记变量而没有赋值时，默认值为 `undefined` 的这一行为，确实无法明确的区分“声明”和“定义”，但这里要做一个区分，主要在于重点说明 “声明” 这一行为仅仅只是标记变量，这样有助于理解 JavaScript 中 `var` 的奇特行为。

在一些类似 C 语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称之为 **块级作用域**（block scope），而 JavaScript 中没有块级作用域。JavaScript 取而代之地使用了 **函数作用域**（function scope）：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

JavaScript 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的，这意味着变量在声明之前甚至已经可用。JavaScript 的这个特性被非正式地称为 **声明提前**（hooisting），即 JavaScript 函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部。

```js
var scope = "global";
function f() {
  console.log(scope); // undefined
  var scope = "local";
  console.log(scope); // local
}
```

> 声明提前是在 JavaScript 引擎的“预编译”时进行，是在代码开始运行之前。

在具有块级作用域的编程语言中，在狭小的作用域里让变量声明和使用变量的代码尽可能靠近彼此，通常来讲，这是一个非常不错的编程习惯。

<!-- TODO: 预编译 -->

- `var`：只会提升变量的声明，无视变量的赋值；
- `function`：将函数（使用 `function` 声明的）提升至作用域顶部，且包含函数体，等价于在作用域顶部定义了该函数；

> 对引用数据类型声明提前，会把内容放在堆内存，任意类型数据都会记录（变量也会存放），若是表达式（函数也是表达式）则将结果存放；待代码执行时，才将对应的变量赋值；

声明提前注意事项：

1).`if` 或 `while` 判断语句中：不管条件判断是否成立，判断体中的内容都要进行声明提前，注意函数只有“声明”没有赋值；

```js
// 条件不成立
console.log(b); // undefined
console.log(bb); // undefined
while (false) {
  var b = 6;
  function bb() {
    return "bb";
  }
}

//条件成立
console.log(a); //undefined
console.log(aa); //undefined
if (true) {
  console.log(a); // undefined
  console.log(aa); // Fn aa(){}
  var a = 6;

  function aa() {
    return "aa";
  }
}
```

2). 声明提前的时候只对 "`=`" 等号左边的变量进行声明提前，右边代表的都是值，是不进行声明提前的；

```js
console.log(a); //undefined
console.log(b); //b is not defined

var a = b + 1;
```

3). 对于函数定义式，会将函数定义提前。而函数表达式，不会进行提升；

```js
console.log(FF); // f FF(){}
console.log(de); // de is not defined
function FF() {
  console.log(de); // de is not defined
  (function de() {})();
}
FF();

console.log(fn); //f fn(){...}
console.log(f); //undefined

function fn() {
  return "小黄人";
}

var f = function() {
  console.log(fn); //f fn(){...}
  console.log(f); //f(){...}
  return "大黄蜂";
};
f();
```

4). 函数声明当做参数的时候不进行声明提前；

```js
console.log(def); //def is not defined
(function(def) {
  def("123");
})(function def(str) {
  console.log(str); //123
});
```

5). 虽然函数体中 `return` 后面的代码是不执行的，但是需要进行私有作用域下的声明提前；而 `return` 同行的代码会执行，但是不进行声明提前的；

```js
function a() {
  console.log(b); //b is not defined
  console.log(c); //f c() {}

  return function b() {};
  function c() {}
}
a();
```

6). 在声明提前的时候，如果发现名字冲突了，重新声明会被忽略，但不会忽略赋值；

```js
console.log(v1); //undefined
var v1 = 6;
var v1 = 7;
console.log(v1); //7
```

## 3.变量连续赋值

变量进行连续赋值时，只有最左边才会被声明，中间变量不会被声明（但有赋值）；

```js
console.log(m); //undefined
console.log(n); //n is not defined

var m = n = 2;
console.log(m); //2
console.log(n); //2
```

## 4.执行环境

**执行环境**（execution context，也称 **执行上下文**）定义变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的 **变量对象**（variable object），环境中定义的所有变量和函数都保持在这个对象中。

根据 ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。在 web 浏览器中，全局执行环境被认为是 `window` 对象，因此所有的全局变量和函数都是作为 `window` 对象的属性和方法创建的。某个执行环境中所有的代码执行完毕后，该环境被销毁，保存其中的所有变量和函数定义也随之销毁。处于活动状态的执行上下文环境只有一个。

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行以后，栈将其环境弹出，把控制权返回给之前的执行环境。函数每被调用一次，都会产生一个新的执行环境。因为不同的调用可能就会有不同的参数。

## 5.作用域

一个变量的 **作用域**（scope）是程序源代码中定义这个变量的区域。在函数内部定义的变量，则是局部变量，作用域是局部的。函数参数也是局部变量，只在函数体内有定义。

作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。

在函数体内，局部变量的优先级高于同名的全局变量。如果在函数体内声明的一个局部变量或者函数参数与全局变量重名，那么全局变量就会被局部变量所遮盖。

> ES6 正式引入块级作用域（block scope）。

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么几乎使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作会导致 LHS 查询。`=` 操作符或函数调用时传入参数的操作都会导致关联作用域的赋值操作。

## 6.作用域链

JavaScript 是基于 *词法作用域* 的语言：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。全局变量在程序中始终有定义，而局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的。

当代码在一个环境中执行的时候，会创建变量对象的一个 **作用域链**（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其 **活动对象**（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 `arguments` 对象（在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含环境，而再下一个变量对象则来自于下一个包含环境。这样，一直延伸到全局执行环境。全局执行环境的变量对象始终是作用域链中的最后一个对象。

标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止；如果找不到标识符，通常会导致错误发生。

此外，在局部作用域中定义的变量可以在局部环境中与全局环境变量互换使用。

```js
var color = "blue";
function changeColor(){
 var anotherColor = "red";
 function swapColors(){
 var tempColor = anotherColor;
 anotherColor = color;
 color = tempColor;

 // 这里可以访问 color、anotherColor 和 tempColor
 }
 // 这里可以访问 color 和 anotherColor，但不能访问 tempColor
 swapColors();
}
// 这里只能访问 color
changeColor();
```

内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性的、有次序的。

> 函数参数也被当成变量来对待，因此其访问规则与执行环境中的其他变量相同。

在 JavaScript 的最顶层代码中（不包含任何函数定义的代码），作用域链是由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链至少有三个对象。当定义一个函数时，实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来讲，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别--在每次外部函数调用时，内部函数的代码是相同的，但是关联这段代码的作用域链却不同。

## 7.延长作用域链

虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：

- `try-catch` 语句的 `catch` 块；
- `with` 语句。

这两个语句都会在作用域链的前端添加一个变量对象。对 `with` 语句来说，会将指定的对象添加到作用域链中。对 `catch` 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

```js
function buildUrl() {
 var qs = "?debug=true";
 with(location){
 var url = href + qs;
 }
 return url;
}
```

在此，`with` 语句接收的是 `location` 对象，因此其变量对象中就包含了 `location` 对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端。`buildUrl()` 函数中定义了一个变量 `qs`。当在 `with` 语句中引用变量 `href` 时（实际引用的是 `location.href`），可以在当前执行环境的变量对象中找到。当引用变量 `qs` 时，引用的则是在 `buildUrl()` 中定义的那个变量，而该变量位于函数环境的变量对象中。至于 `with` 语句内部，则定义了一个名为 `url` 的变量，因而 `url` 就成了函数执行环境的一部分，所以可以作为函数的值被返回。

## 8.没有块级作用域

JavaScript 没有块级作用域经常会导致理解上的困惑。在其他类 C 的语言中，由花括号封闭的代码块都有自己的作用域，而且变量在声明它们的代码段之外是不可见的，称为 **块级作用域**（block scope），而 JavaScript 中没有块级作用域。JavaScript 取而代之地使用了 **函数作用域**（function scope）：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

例如，下面的代码在 JavaScript 中并不会得到想象中的结果：

```js
if (true) {
 var color = "blue";
}
alert(color); //"blue"
```

这里是在一个 `if` 语句中定义了变量 `color`。如果是在 C、C++ 或 Java 中，`color` 会在 `if` 语句执行完毕后被销毁。但在 JavaScript 中，`if` 语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。在使用 `for` 语句时尤其要牢记这一差异，例如：

```js
for (var i=0; i < 10; i++){
 doSomething(i);
}
alert(i); //10
```

对于有块级作用域的语言来说，`for` 语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于 JavaScript 来说，由 `for` 语句创建的变量 `i` 即使在 `for` 循环执行结束后，也依旧会存在于循环外部的执行环境中。

### 8.1.声明变量

使用 `var` 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在 `with` 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 `var` 声明，该变量会自动被添加到全局环境。如下所示：

```js
// case1
function add(num1, num2) {
 var sum = num1 + num2;
 return sum;
}
var result = add(10, 20); //30
alert(sum); //由于 sum 不是有效的变量，因此会导致错误

// case2
function add(num1, num2) {
 sum = num1 + num2;
 return sum;
}
var result = add(10, 20); //30
alert(sum); //30
```

> 在编写 JavaScript 代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。

### 8.2.查询标识符

当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。

通过下面这个示例，可以理解查询标识符的过程：

```js
var color = "blue";
function getColor(){
 return color;
}
alert(getColor()); //"blue"
```

在这个搜索过程中，如果存在一个局部的变量的定义，则搜索会自动停止，不再进入另一个变量对象。换句话说，如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符，如下面的例子所示：

```js
var color = "blue";
function getColor(){
 var color = "red";
 return color;
}
alert(getColor()); //"red"
```

在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数带有的变量和全局变量同名，那么全局变量就会被局部变量所遮盖。

> 变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。JavaScript 引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。
