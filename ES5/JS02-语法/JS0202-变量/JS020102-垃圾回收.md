# 垃圾回收

像 C 语言这样的底层语言一般都有底层的内存管理接口，比如 `malloc()` 和 `free()`。相反，JavaScript是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为 **垃圾回收**。这个“自动”是混乱的根源，并让 JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。

程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做 **内存泄漏**（memory leak）。大多数语言提供自动内存管理，减轻程序员的负担，这被称为 **垃圾回收机制**（garbage collector）。

JavaScript 具有自动垃圾收集机制，即执行环境会负责管理代码执行过程中使用的内存。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这样操作。

局部变量值在函数执行的过程中存在，而这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便储存它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。

## 1.内存生命周期

不管什么程序语言，内存生命周期基本是一致的：

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放\归还

所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像 JavaScript 这些高级语言中，大部分都是隐含的。

## 2.JavaScript 的内存分配

- **值的初始化**

为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。

```js
var n = 123; // 给数值变量分配内存
var s = "azerty"; // 给字符串分配内存

var o = {
  a: 1,
  b: null
}; // 给对象及其包含的值分配内存

// 给数组及其包含的值分配内存（就像对象一样）
var a = [1, null, "abra"];

function f(a){
  return a + 2;
} // 给函数（可调用的对象）分配内存

// 函数表达式也能分配一个对象
someElement.addEventListener('click', function(){
  someElement.style.backgroundColor = 'blue';
}, false);
```

- **通过函数调用分配内存**

有些函数调用结果是分配对象内存：

```js
var d = new Date(); // 分配一个 Date 对象

var e = document.createElement('div'); // 分配一个 DOM 元素
```

有些方法分配新变量或者新对象：

```js
var s = "azerty";
var s2 = s.substr(0, 3); // s2 是一个新的字符串
// 因为字符串是不变量，
// JavaScript 可能决定不分配内存，
// 只是存储了 [0-3] 的范围。

var a = ["ouais ouais", "nan nan"];
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2);
// 新数组有四个元素，是 a 连接 a2 的结果
```

- **使用值**

使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。

- **当内存不再需要使用时释放**

大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“哪些被分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。

高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。

## 3.垃圾回收

自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。

### 3.1.引用

垃圾回收算法主要依赖于 **引用** 的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个 Javascript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。

在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。

### 3.2.引用计数

一种不太常见的垃圾收集策略叫做 **引用计数**（reference counting），这也是最初级的垃圾收集算法。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。

> Netscape Navigator 3.0 是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。

循环引用指的是对象 `A` 中包含一个指向对象 `B` 的指针，而对象 `B` 中也包含一个指向对象 `A` 的引用。请看下面这个例子：

```js
function problem(){
 var objectA = new Object();
 var objectB = new Object();
 objectA.someOtherObject = objectB;
 objectB.anotherObject = objectA;
}
```

在这个例子中，`objectA` 和 `objectB` 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，`objectA` 和 `objectB` 还
将继续存在，因为它们的引用次数永远不会是 0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。为此，Netscape 在 Navigator 4.0 中放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。可是，引用计数导致的麻烦并未就此终结。

我们知道，IE 中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++ 以 COM（Component Object Model，组件对象模型）对象的形式实现的，而 COM 对象的垃圾收集机制采用的就是引用计数策略。因此，即使 IE 的 JavaScript 引擎是使用标记清除策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的问题。下面这个简单的例子，展示了使用 COM 对象导致的循环引用问题：

```js
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.element = element;
element.someObject = myObject;
```

这个例子在一个 DOM 元素（element）与一个原生 JavaScript 对象（myObject）之间创建了循环引用。其中，变量 `myObject` 有一个名为 `element` 的属性指向 `element` 对象；而变量 `element` 也有一个属性名叫 `someObject` 回指 `myObject`。由于存在这个循环引用，即使将例子中的 DOM 从页面中移除，它也永远不会被回收。

为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与 DOM 元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用：

```js
myObject.element = null;
element.someObject = null;
```

将变量设置为 `null` 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。

为了解决上述问题，IE9 把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。

### 3.3.标记清除

JavaScript 中最常用的垃圾收集方式是 **标记清除**（mark-and-sweep）。当变量进入环境时，将将这个变量标记为“进入环境”。

这个算法假定设置一个叫做 **根**（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象...从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

> 从逻辑上讲，永远不能释放进入环境的变量所占用的内存。因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

可以使用任何方式来标记变量。如何标记变量其实并不重要，关键在于采取什么策略。

垃圾收集器在运行的时候会给储存在内存中的所有变量加上标记，然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些那些带标记的值并回收它们所占用的内存空间。

> 从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

循环引用不再是问题了，但是又有另一个问题：那些无法从根对象查询到的对象都将被清除。尽管这是一个限制，但实践中我们很少会碰到类似的情况。

## 3.性能问题

垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也会是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。

IE 的垃圾收集器是根据内存分配量运行的，具体一点，就是 256 个变量、4096 个对象（或数组）字面量和数组元素（slot）或者 64 KB 的字符串。达到上述任一一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本包含那么多变量，那么该脚本很可能就会在其生命周期中一直保存有那么多变量，而这样一来，垃圾收集器就不得不频繁地运行，结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。

随着 IE7 的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。IE7 中的各项临界值在初始时与 IE6 相等。如果垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和（或）数组元素的临界值就会加倍。如果例程回收了 85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了 IE 在运行包含大量 JavaScript 的页面时的性能。

## 4.管理内存

使用具备垃圾收集机制的语言编写程序，开发人员一般不用操心内存管理的问题。但是，JavaScript 在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web 浏览器的可用内存数量通常比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，还会影响调用栈以及在一个线程中能够同时执行的语句数量。

因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 `null` 来释放其引用————这个做法叫做 **解除引用**（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。

不过解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

## 5.内存泄漏

**内存泄漏**（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

内存泄漏缺陷具有隐蔽性、积累性的特征，比其他内存非法访问错误更难检测。因为内存泄漏的产生原因是内存块未被释放，属于遗漏型缺陷而不是过错型缺陷。此外，内存泄漏通常不会直接产生可观察的错误症状，而是逐渐积累，降低系统整体性能，极端的情况下可能使系统崩溃。

- **1：意外的全局变量**

JavaScript 用一个有趣的方式管理未被声明的变量：对未声明的变量的引用在全局对象里创建一个新的变量。在浏览器的情况下，这个全局对象是 `window`。换句话说：

```js
function foo(arg) {
  bar = "some text";
}
// 等同于
function foo(arg) {
  window.bar = "some text";
}
```

另一种意外的全局变量可能由 `this` 创建：

```js
function foo() {
  this.a = "哈哈哈哈哈";
}
// 非严格模式下，this 采用默认赋值
// 即增加 window.a 属性
foo();
```

为了防止这些问题发生，可以在你的 JaveScript 文件开头使用 `'use strict'`；。这个可以使用一种严格的模式解析 JavaScript 来阻止意外的全局变量。

如果有时全局变量被用于暂时储存大量的数据或者涉及到的信息，那么在使用完之后应该指定为 `null` 或者重新分配。

与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。

- **2：被遗忘的定时器或者回调**

还是来个栗子吧，定时器可能会产生对不再需要的 DOM 节点或者数据的引用。

```js
var serverData = loadData();
setInterval(function() {
  var div = document.getElementById("box");
  if (div) {
    div.innerHTML = JSON.stringify(serverData);
  }
}, 5000); //每五秒会执行一次
```

只要 `interval` 仍然起作用时，`div` 并不能被回收，这就意味着 `serverData` 也不能回收。

对于观察者的例子，大部分的浏览器都能而且会在对象变得不可到达（即不再需要）的时候回收观察处理器，甚至监听器没有被明确的移除掉。在对象被处理之前，最好也要显式地删除这些观察者。

```js
// 观察者代码
var element = document.getElementById("launch-button");
var counter = 0;

function onClick(event) {
  counter++;
  element.innerHtml = "text " + counter;
}

element.addEventListener("click", onClick);
// 做一些其他的事情

element.removeEventListener("click", onClick);
element.parentNode.removeChild(element);
```

如今，现在的浏览器（包括 IE 和 Edge）使用现代的垃圾回收算法，可以立即发现并处理这些循环引用。换句话说，在一个节点删除之前也不是必须要手动调用 `removeEventListener`。

框架和插件例如 jQuqery 在处理节点（当使用具体的 api 的时候）之前会移除监听器。这个是插件内部的处理可以确保不会产生内存泄漏，甚至运行在有问题的浏览器上（哈哈哈 说的就是 IE6）。

- **3: 闭包**

闭包是 JavaScript 开发的一个关键方面，一个内部函数使用了外部（封闭）函数的变量。由于 JavaScript 运行的细节，它可能以下面的方式造成内存泄漏：

```js
var count = 1;
var fn = function() {
  var a = "天使降临我身边。..";
  return function() {
    console.log(a.repeat(count++));
  };
};
var f = fn();
setInterval(f, 1000);
```

合理的使用闭包，并不会带来内存泄漏。

- **4：来自 DOM 的引用**

在你要重复的操作 DOM 节点的时候，存储 DOM 节点是十分有用的。但是在你需要移除 DOM 节点的时候，需要确保移除 DOM tree 和代码中储存的引用。

```js
var elements = {
  image: document.getElementById("image"),
  button: document.getElementById("button")
};

function doStuff() {
  image.src = "http://some.url/image";
  // 更多逻辑
}

document.body.removeChild(document.getElementById("image"));
// 虽然从 dom tree 中移除了 id 为 image 的节点
// 若还保留了一个对该节点的引用，则不能回收
```

当涉及到 DOM 树内部或子节点时，需要考虑额外的考虑因素。例如，JS 代码中对单元格的引用造成了整个表格被留在内存中了，所以在移除有被引用的节点时候要移除其子节点。

---

参考：

1.[内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)
2.[内存泄漏](https://github.com/qufei1993/Nodejs-Roadmap/blob/master/docs/nodejs/memory.md#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)
