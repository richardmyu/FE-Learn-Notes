# 垃圾回收

程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做**内存泄漏**（memory leak）。大多数语言提供自动内存管理，减轻程序员的负担，这被称为"**垃圾回收机制**"（garbage collector）。

JavaScript 具有自动垃圾收集机制，即执行环境会负责管理代码执行过程中使用的内存。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这样操作。

局部变量值在函数执行的过程中存在，而这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便储存它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。

## 1.标记清除

JavaScript 中最常用的垃圾手机方式是**标记清除**（mark-and-sweep）。当变量进入环境时，将将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放金 UR 环境的变量所占用的内存。因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

可以使用任何方式来标记变量。如何标记变量其实并不重要，关键在于采取什么策略。

垃圾收集器在运行的时候会给储存在内存中的所有变量加上标记，然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些那些带标记的值并回收它们所占用的内存空间。

## 2.引用计数

另一个不太常见的垃圾收集策略叫做**引用计数**（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给了另一个变量，则该值的引用次数加 1. 相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1. 当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占用的空间。

计数引用有一个很严重的问题：循环引用。循环引用指定是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。它们的引用次数永远不会是 0 ，而且多次调用，还会导致大量内存得不到回收。未来避免这样的问题，最好是在不使用时切断它们的联系。将变量设置为 `null` 就可以切断变量与它此前引用的值之间的链接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。

## 3.性能问题

垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也会是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。

> IE 的垃圾收集器是根据内存分配量运行的，具体一点，就是 256 个变量、4096 个对象（或数组）字面量和数组元素（slot）或者 64 KB 的字符串。达到上述任一一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本包含那么多变量，那么该脚本很可能就会在其生命周期中一直保存有那么多变量，而这样一来，垃圾收集器就不得不频繁地运行，结果，由此引发的严重性能问题促使 IE7 重写了其垃圾收集例程。

## 4.管理内存

使用具备垃圾收集机制的语言编写程序，开发人员一般不用操心内存管理的问题。但是，JavaScript 在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给 Web 浏览器的可用内存数量通常比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，还会影响调用栈以及在一个线程中能够同时执行的语句数量。

因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 `null` 来释放其引用————这个做法叫做**解除引用**（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。

不过解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

## 5.内存泄漏

内存泄漏缺陷具有隐蔽性、积累性的特征，比其他内存非法访问错误更难检测。因为内存泄漏的产生原因是内存块未被释放，属于遗漏型缺陷而不是过错型缺陷。此外，内存泄漏通常不会直接产生可观察的错误症状，而是逐渐积累，降低系统整体性能，极端的情况下可能使系统崩溃。

- **1：意外的全局变量**

JavaScript 用一个有趣的方式管理未被声明的变量：对未声明的变量的引用在全局对象里创建一个新的变量。在浏览器的情况下，这个全局对象是 window。换句话说：

```js
function foo(arg) {
  bar = "some text";
}
//等同于
function foo(arg) {
  window.bar = "some text";
}
```

另一种意外的全局变量可能由 `this` 创建：

```js
function foo() {
  this.a = "哈哈哈哈哈";
}
// 非严格模式下，this 采用默认赋值
// 即增加 window.a 属性
foo();
```

为了防止这些问题发生，可以在你的 JaveScript 文件开头使用 `'use strict'`；。这个可以使用一种严格的模式解析 JavaScript 来阻止意外的全局变量。

如果有时全局变量被用于暂时储存大量的数据或者涉及到的信息，那么在使用完之后应该指定为 `null` 或者重新分配。

与全局变量相关的增加内存消耗的一个主因是缓存。缓存数据是为了重用，缓存必须有一个大小上限才有用。高内存消耗导致缓存突破上限，因为缓存内容无法被回收。

- **2：被遗忘的定时器或者回调**

还是来个栗子吧，定时器可能会产生对不再需要的 DOM 节点或者数据的引用。

```js
var serverData = loadData();
setInterval(function() {
  var div = document.getElementById("box");
  if (div) {
    div.innerHTML = JSON.stringify(serverData);
  }
}, 5000); //每五秒会执行一次
```

只要 `interval` 仍然起作用时，`div` 并不能被回收，这就意味着 `serverData` 也不能回收。

对于观察者的例子，大部分的浏览器都能而且会在对象变得不可到达（即不再需要）的时候回收观察处理器，甚至监听器没有被明确的移除掉。在对象被处理之前，最好也要显式地删除这些观察者。

```js
// 观察者代码
var element = document.getElementById("launch-button");
var counter = 0;

function onClick(event) {
  counter++;
  element.innerHtml = "text " + counter;
}

element.addEventListener("click", onClick);
// 做一些其他的事情

element.removeEventListener("click", onClick);
element.parentNode.removeChild(element);
```

如今，现在的浏览器（包括 IE 和 Edge）使用现代的垃圾回收算法，可以立即发现并处理这些循环引用。换句话说，在一个节点删除之前也不是必须要手动调用 `removeEventListener`。

框架和插件例如 jQuqery 在处理节点（当使用具体的 api 的时候）之前会移除监听器。这个是插件内部的处理可以确保不会产生内存泄漏，甚至运行在有问题的浏览器上（哈哈哈 说的就是 IE6）。

- **3: 闭包**

闭包是 javascript 开发的一个关键方面，一个内部函数使用了外部（封闭）函数的变量。由于 JavaScript 运行的细节，它可能以下面的方式造成内存泄漏：

```js
var count = 1;
var fn = function() {
  var a = "天使降临我身边。..";
  return function() {
    console.log(a.repeat(count++));
  };
};
var f = fn();
setInterval(f, 1000);
```

合理的使用闭包，并不会带来内存泄漏。

- **4：来自 DOM 的引用**

在你要重复的操作 DOM 节点的时候，存储 DOM 节点是十分有用的。但是在你需要移除 DOM 节点的时候，需要确保移除 DOM tree 和代码中储存的引用。

```js
var elements = {
  image: document.getElementById("image"),
  button: document.getElementById("button")
};

function doStuff() {
  image.src = "http://some.url/image";
  // 更多逻辑
}

document.body.removeChild(document.getElementById("image"));
// 虽然从 dom tree 中移除了 id 为 image 的节点
// 若还保留了一个对该节点的引用，则不能回收
```

当涉及到 DOM 树内部或子节点时，需要考虑额外的考虑因素。例如，JS 代码中对单元格的引用造成了整个表格被留在内存中了，所以在移除有被引用的节点时候要移除其子节点。

---

参考：

[4 类 JavaScript 内存泄漏及如何避免](https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/)
