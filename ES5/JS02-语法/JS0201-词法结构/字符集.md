# 字符集

JavaScript 程序是用 Unicode 字符集编写的。Unicode 是 ASCII 和 Latin-1 的超集，并支持地球上几乎所有在用的语言。ES5 要求 JavaScript 必须支持 Unicode 3 及后续版本。

在有些计算机硬件和软件里，无法显示或输入 Unicode 字符全集。未来支持那些使用老旧技术的程序员，JavaScript 定义了一种特殊序列，使用 6 个 ASCII 字符来代表任意 16 位 Unicode 内码。这些 Unicode 转义序列均以 `\u` 为前缀，其后跟随 4 个十六进制（使用数字一级大小写的字母 A-F 表示）。这种 Unicode 转义写法可以使用 JavaScript 字符串直接量、正则表达式直接量和标识符中（关键字除外）。Unicode 转义写法也可以出现在注释周中，但是 JavaScript 会忽视，只是被当成上下文的 ASCII 字符处理，而不会被解析为对应的 Unicode 字符。

## 1.Unicode

**Unicode**（中文：万国码、国际码、统一码、单一码）是电脑科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。

Unicode 是为了解决传统的字元编码方案的局限而产生的，例如 ISO 8859-1 所定义的字元虽然在不同的国家中广泛地使用，可是在不同国家间却经常出现不相容的情况。很多传统的编码方式都有一个共同的问题，即容许电脑处理双语环境（通常使用拉丁字母以及其本地语言），但却无法同时支援多语言环境（指可同时处理多种语言混合的情况）。

在文字处理方面，统一码为每一个字符而非字形定义唯一的代码（即一个整数）。换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器。

目前，几乎所有电脑系统都支持基本拉丁字母，并各自支持不同的其他编码方式。Unicode 为了和它们相互兼容，其首 256 字元保留给 ISO 8859-1 所定义的字元，使既有的西欧语系文字的转换不需特别考量；并且把大量相同的字元重复编到不同的字元码中去，使得旧有纷杂的编码方式得以和 Unicode 编码间互相直接转换，而不会遗失任何资讯。举例来说，全形格式区段包含了主要的拉丁字母的全形格式，在中文、日文、以及韩文字形当中，这些字元以全形的方式来呈现，而不以常见的半形形式显示，这对竖排文字和等宽排列文字有重要作用。

在表示一个 Unicode 的字元时，通常会用“U+”然后紧接着一组十六进位的数字来表示这一个字元。在基本多文种平面（英文：Basic Multilingual Plane，简写 BMP。又称为“零号平面”、plane 0）里的所有字元（最前面的 65536 个字符位），要用四个数字或大小写字母（即两个 byte，共 16 bit，例如 U+4AE0，共支持六万多个字符），即 `U+0000` 到 `U+FFFF`；在零号平面以外的字元则需要使用五个或六个数字或大小写字母，也称为辅助平面（缩写 SMP），码点范围从 `U+010000` 一直到 `U+10FFFF`。

## 2.编码方式

统一码的编码方式与 ISO 10646 的通用字符集概念相对应。目前实际应用的统一码版本对应于 UCS-2，使用 16 位的编码空间。也就是每个字符占用 2 个字节。这样理论上一共最多可以表示 2^16（即 65536）个字符。基本满足各种语言的使用。实际上目前版本的统一码并未完全使用这 16 位编码，而是保留了大量空间以作为特殊使用或将来扩展。

上述 16 位统一码字符构成基本多文种平面。最新（但未实际广泛使用）的统一码版本定义了 16 个辅助平面，两者合起来至少需要占据 21 位的编码空间，比 3 字节略少。但事实上辅助平面字符仍然占用 4 字节编码空间，与 UCS-4 保持一致。未来版本会扩充到 ISO 10646-1 实现级别 3，即涵盖 UCS-4 的所有字符。UCS-4 是一个更大的尚未填充完全的 31 位字符集，加上恒为 0 的首位，共需占据 32 位，即 4 字节。理论上最多能表示 2^31 个字符，完全可以涵盖一切语言所用的符号。

基本多文种平面的字符的编码为 `U+hhhh`，其中每个 h 代表一个十六进制数字，与 UCS-2 编码完全相同。而其对应的 4 字节 UCS-4 编码后两个字节一致，前两个字节则所有位均为 0。

## 3.实现方式

Unicode 的实现方式不同于编码方式。一个字符的 Unicode 编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对 Unicode 编码的实现方式有所不同。Unicode 的实现方式称为 **Unicode 转换格式**（Unicode Transformation Format，简称为 **UTF**）。

### 3.1.UTF-8

**UTF-8**（8-bit Unicode Transformation Format）是一种针对 Unicode 的可变长度字元编码，也是一种前缀码。字符长度从 1 个字节到 4 个字节不等，越是常用的字符，字节越短，最前面的 128 个字符，只使用 1 个字节表示，与 ASCII 码完全相同。

UTF-8 使用一至六个位元组为每个字符编码（尽管如此，2003 年 11 月 UTF-8 被 RFC 3629 重新规范，只能使用原来 Unicode 定义的区域，U+0000 到 U+10FFFF，也就是说最多四个字节）：

| 编号范围            | 字节 |
| ------------------- | ---- |
| 0x0000 - 0x007F     | 1    |
| 0x0080 - 0x07FF     | 2    |
| 0x0800 - 0xFFFF     | 3    |
| 0x010000 - 0x10FFFF | 4    |

- 128 个 US-ASCII 字符只需一个位元组编码（Unicode 范围由 U+0000 至 U+007F）。
- 带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个位元组编码（Unicode 范围由 U+0080 至 U+07FF）。
- 其他基本多文种平面（BMP）中的字元（这包含了大部分常用字，如大部分的汉字）使用三个位元组编码（Unicode 范围由 U+0800 至 U+FFFF）。
- 其他极少使用的 Unicode 辅助平面的字元使用四至六位元组编码（Unicode 范围由 `U+10000` 至 `U+1FFFFF` 使用四字节，Unicode 范围由 `U+200000` 至 `U+3FFFFFF` 使用五字节，Unicode 范围由 `U+4000000` 至 `U+7FFFFFFF` 使用六字节）。

对上述提及的第四种字元而言，UTF-8 使用四至六个位元组来编码似乎太耗费资源了。但 UTF-8 对所有常用的字元都可以用三个位元组表示，而且它的另一种选择，UTF-16 编码，对前述的第四种字符同样需要四个位元组来编码，所以要决定 UTF-8 或 UTF-16 哪种编码比较有效率，还要视所使用的字元的分布范围而定。不过，如果使用一些传统的压缩系统，比如 DEFLATE，则这些不同编码系统间的的差异就变得微不足道了。若顾及传统压缩算法在压缩较短文字上的效果不大，可以考虑使用 Unicode 标准压缩格式（SCSU）。

由于 UTF-8 这种节省空间的特性，导致它成为互联网上最常见的网页编码。网际网路工程工作小组（IETF）要求所有网际网路协议都必须支持 UTF-8 编码。互联网邮件联盟（IMC）建议所有电子邮件软件都支持 UTF-8 编码。

### 3.2.UTF-16

UTF-16 是 Unicode 字符编码五层次模型的第三层：字符编码表（Character Encoding Form，也称为 "storage format"）的一种实现方式。即把 Unicode 字符集的抽象码位映射为 16 位长的整数（即码元）的序列，用于数据存储或传递。Unicode 字符的码位，需要 1 个或者 2 个 16 位长的码元来表示，因此这是一个变长表示。

UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。

Unicode 的编码空间从 `U+0000` 到 `U+10FFFF`，共有 1,112,064 个码位（code point）可用来映射字符。Unicode 的编码空间可以划分为 17 个平面（plane），每个平面包含 2^16（65,536）个码位。17 个平面的码位可表示为从 `U+xx0000` 到 `U+xxFFFF`，其中 `xx` 表示十六进制值从 00<sub>16</sub> 到 10<sub>16</sub>，共计 17 个平面。第一个平面称为 **基本多语言平面**（Basic Multilingual Plane, BMP），或称 **第零平面**（Plane 0）。其他平面称为 **辅助平面**（Supplementary Planes）。基本多语言平面内，从 `U+D800` 到 `U+DFFF` 之间的码位区段是永久保留不映射到 Unicode 字符。UTF-16 就利用保留下来的 `0xD800`-`0xDFFF` 区段的码位来对辅助平面的字符的码位进行编码。

它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（`U+0000` 到 `U+FFFF`），要么是 4 个字节（`U+010000` 到 `U+10FFFF`）。

于是就有一个问题，当我们遇到两个字节，怎么看出它本身是一个字符，还是需要跟其他两个字节放在一起解读？

在基本平面内，从 `U+D800` 到 `U+DFFF` 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。

具体来说，辅助平面的字符位共有 220 个，也就是说，对应这些字符至少需要 20 个二进制位。UTF-16 将这 20 位拆成两半，前 10 位映射在 `U+D800` 到 `U+DBFF`（空间大小 210），称为 **高位**（H），后 10 位映射在 `U+DC00` 到 `U+DFFF`（空间大小 210），称为 **低位**（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。

所以，当我们遇到两个字节，发现它的码点在 `U+D800` 到 `U+DBFF` 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 `U+DC00` 到 `U+DFFF` 之间，这四个字节必须放在一起解读。

### 3.3.UTF-32

最直观的编码方法是，每个码点使用四个字节表示，字节内容一一对应码点。这种编码方法就叫做 UTF-32。比如，码点 0 就用四个字节的 0 表示，码点 `597D` 就在前面加两个字节的 0。

```js
U+0000 = 0x0000 0000

U+597D = 0x0000 597D
```

- 优点：转换规则简单直观，查找效率高。
- 缺点：浪费空间，同样内容的英语文本，它会比 ASCII 编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5 标准就明文规定，网页不得编码成 UTF-32。

## 4.JavaScript 的字符集

JavaScript 语言采用 Unicode 字符集，但是只支持一种编码方法。这种编码既不是 UTF-16，也不是 UTF-8，更不是 UTF-32。上面那些编码方法，JavaScript 都不用。

JavaScript 用的是 **UCS-2**！

由于 JavaScript 只能处理 UCS-2 编码，造成所有字符在这门语言中都是 2 个字节，如果是 4 个字节的字符，会当作两个双字节的字符处理。JavaScript 的字符函数都受到这一点的影响，无法返回正确结果。

还是以字符 `𝌆` 为例，它的 UTF-16 编码是 4 个字节的 `0xD834 DF06`。问题就来了，4 个字节的编码不属于 UCS-2，JavaScript 不认识，只会把它看作单独的两个字符 `U+D834` 和 `U+DF06`。前面说过，这两个码点是空的，所以 JavaScript 会认为是两个空字符组成的字符串！

```js
"𝌆".length; //2

"𝌆" === "\u1D306"; //false

"𝌆".charAt(0); //' '

"𝌆".charCodeAt(0); //55348(0xD834)
```

上面代码表示，JavaScript 认为字符 `𝌆` 的长度是 2，取到的第一个字符是空字符，取到的第一个字符的码点是 `0xDB34`。这些结果都不正确！

`'𝌆' === '\uD834\uDF06'; //true`

解决这个问题，必须对码点做一个判断，只要落在 `0xD800` 到 `0xDBFF` 的区间，就要连同后面 2 个字节一起读取。类似的问题存在于所有的 JavaScript 字符操作函数。

```js
while (++index < length) {
  // ...
  if (charCode >= 0xd800 && charCode <= 0xdbff) {
    output.push(character + string.charAt(++index));
  } else {
    output.push(character);
  }
}
```

## 5.ES6 的字符集

ES6 大幅增强了 Unicode 支持，基本上解决了这个问题。

- **正确识别字符**

ES6 可以自动识别 4 字节的码点。因此，遍历字符串就简单多了。

```JS
for (let s of string ) {
  // ...
}
```

但是，为了保持兼容，`length` 属性还是原来的行为方式。为了得到字符串的正确长度，可以用下面的方式。

`Array.from(string).length`

- **码点表示法**

JavaScript 允许直接用码点表示 Unicode 字符，写法是"反斜杠+u+码点"。

`'好' === '\u597D' // true`

但是，这种表示法对 4 字节的码点无效。ES6 修正了这个问题，只要将码点放在大括号内，就能正确识别。

```js
"𝌆" === "\u1D306"; //false

"𝌆" === "\u{1D306}"; //true
```

- **字符串处理函数**

ES6 新增了几个专门处理 4 字节码点的函数。

- `String.fromCodePoint()`：从 Unicode 码点返回对应字符
- `String.prototype.codePointAt()`：从字符返回对应的码点
- `String.prototype.at()`：返回字符串给定位置的字符

- **正则表达式**

ES6 提供了 u 修饰符，对正则表达式添加 4 字节码点的支持。

```js
/^.$/.test("𝌆"); //false
/^.$/u.test("𝌆"); //true
```

- **Unicode 正规化**

有些字符除了字母以外，还有附加符号。比如，汉语拼音的 Ǒ，字母上面的声调就是附加符号。对于许多欧洲语言来说，声调符号是非常重要的。

Unicode 提供了两种表示方法。一种是带附加符号的单个字符，即一个码点表示一个字符，比如 `Ǒ` 的码点是 `U+01D1`；另一种是将附加符号单独作为一个码点，与主体字符复合显示，即两个码点表示一个字符，比如 `Ǒ` 可以写成 `O(U+004F)` + `ˇ(U+030C)`。

```js
// 方法一
"\u01D1";
// 'Ǒ'

// 方法二
"\u004F\u030C";
// 'Ǒ'
```

这两种表示方法，视觉和语义都完全一样，理应作为等同情况处理。但是，JavaScript 无法辨别。

`'\u01D1'==='\u004F\u030C'; //false`

ES6 提供了 `normalize` 方法，允许"Unicode 正规化"，即将两种方法转为同样的序列。

`'\u01D1'.normalize() === '\u004F\u030C'.normalize(); // true`

## 6.UCS-2

互联网还没出现的年代，曾经有两个团队，不约而同想搞统一字符集。一个是 1988 年成立的 Unicode 团队，另一个是 1989 年成立的 UCS 团队。等到他们发现了对方的存在，很快就达成一致：世界上不需要两套统一字符集。

1991 年 10 月，两个团队决定合并字符集。也就是说，从今以后只发布一套字符集，就是 Unicode，并且修订此前发布的字符集，UCS 的码点将与 Unicode 完全一致。

UCS 的开发进度快于 Unicode，1990 年就公布了第一套编码方法 UCS-2，使用 2 个字节表示已经有码点的字符。（那个时候只有一个平面，就是基本平面，所以 2 个字节就够用了。）UTF-16 编码迟至 1996 年 7 月才公布，明确宣布是 UCS-2 的超集，即基本平面字符沿用 UCS-2 编码，辅助平面字符定义了 4 个字节的表示方法。

两者的关系简单说，就是 UTF-16 取代了 UCS-2，或者说 UCS-2 整合进了 UTF-16。所以，现在只有 UTF-16，没有 UCS-2。

那么，为什么 JavaScript 不选择更高级的 UTF-16，而用了已经被淘汰的 UCS-2 呢？

答案很简单：非不想也，是不能也。因为在 JavaScript 语言出现的时候，还没有 UTF-16 编码。

1995 年 5 月，Brendan Eich 用了 10 天设计了 JavaScript 语言；10 月，第一个解释引擎问世；次年 11 月，Netscape 正式向 ECMA 提交语言标准（整个过程详见《JavaScript 诞生记》）。对比 UTF-16 的发布时间（1996 年 7 月），就会明白 Netscape 公司那时没有其他选择，只有 UCS-2 一种编码方法可用！

---

参考：

[Unicode 与 JavaScript 详解](http://www.ruanyifeng.com/blog/2014/12/unicode.html)

[Unicode](https://www.wikiwand.com/zh-hans/Unicode)

[UTF-8](https://www.wikiwand.com/zh-hans/UTF-8)

[UTF-16](https://www.wikiwand.com/zh-hans/UTF-16)

[Javascript 与字符编码](https://github.com/SamHwang1990/blog/issues/2)

[Javascript 有个 Unicode 的天坑](http://www.alloyteam.com/2016/12/javascript-has-a-unicode-sinkhole/)

[js 文件引用编码方式](http://caibaojian.com/js-charset.html)

[通过 javascript 进行 UTF-8 编码](https://segmentfault.com/a/1190000005794963)

[javascript 基础之字符集与编码](https://segmentfault.com/a/1190000013089916)
