# 设计模式

## 1.单例模式

在 JavaScript 中，单例模式是最基本也是最重要的模式之一，这种模式提供了一种将代码组织为一个逻辑单元的手段。（单例模式可以用来划分命名空间，从而减少全局变量的数量）

在开发的时候，为了对人合作开发而使用变量的冲突问题，我们可以将变量以属性的方式写在对象中，只要对象名不冲突即可，这时我们给每个对象添加一个新的名字叫做 **命名空间**；

> 将每个模块写在对象中的形式就是 **单例模式**。

新单例模式，对象内用自执行函数来返回方法；

```js
var public = (function() {
  function toArray(likeArray) {
    return [...likeArray];
  }

  function children(ele, tag) {
    var kid = ele.children;
    var ary = [];
    for (var i = 0; i < kid.length; i++) {
      if (kid[i].tagName === tag.toUpperCase()) {
        ary.push(kid[i]);
      }
    }
    return ary;
  }

  function prevAll(ele) {
    var ary = [];
    var prev = ele.previousElementSibling;
    while (prev) {
      ary.unshift(prev);
      prev = prev.previousElementSibling;
    }
    return ary;
  }

  return {
    toArray: toArray,
    children: children,
    prevAll: prevAll
  };
})();
```

> 在自己的模块中使用自己的方法属性，可以直接用 `this` 代替对象名；

## 2.工厂模式

我们把一些功能封装成一个函数，以后再想实现这个功能只需要取执行这个函数即可；

工厂模式用于批量生产；提供不同的原材料（传入参数），得到不一样的产品（返回值）；

## 3.构造函数

为了解决工厂模式的实例识别，使用构造函数；构造函数与其他函数唯一的区别，就在于调用他们的方式不同；

把一个函数变成类，或者说添加一个自定义的类，通过构造函数来实现；

按照惯例，构造函数始终都应该以一个大写字母开头，非构造函数以小写字母开头，主要是为了区别于其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。

> 使用 `new` 关键字来创建构造函数，该函数就是一个类，此时的 `this` 指代被定义产生的实例，可以通过 `this.` 的形式可以给实例添加私有的属性和方法；不需要 `return`，默认会将 `this` 返回；
> 如果要在类中设置 `return` 返回：若 `return` 返回值是引用类型会改变返回值（返回 `return` 的值）；若 `return` 返回值是基本数据类型，不会造成影响；

` 实例 instanceof 类 ` 判断某个对象是不是某个类的实例；对基本数据类型，需是构造函数产生的才是实例；对引用类型皆可；

创建自定义的构造函数意味着将来可以将他的实例标识为一种特定类型；而这正是构造函数模式胜过工厂模式的地方。

## 4.原型模式

实例的共享属性和方法存在于原型对象中；

构造函数无法解决复用问题，因为私有，所以实例之间无法共用一个系统的方法；而用 Js 的原型机制可以实现，这就是 js 面向对象的核心点；

*所有类都是函数；每个函数都有一个 `prototype`（原型）属性*，是一个对象（当前类本身），这个属性类似于一个指针，指向一个特定类型的所有实例所共享的属性和方法。构造函数和实例的 `prototype` 属性都指向同一个原型对象，原型对象的方法都可以由实例取继承；

`Constructor` 属性是原型对象的属性，是一个对象（当前类本身），也是一个指针，指向构造函数；大部分情况下指向构造函数，但也不少一成不变的。当构造函数的 `prototype` 设置为等于一个以对象字面量形式创建的新对象时，此时 `Constructor` 属性不再指向构造函数，而是指向对象；

*任意一个对象都会有一个属性 `__proto__`*，这个属性指向所属类的原型（`prototype`）；Objectd 的原型上没有 `__proto__`，因为已指向自身；

## 5.混合模式

利用构造函数模式优秀的识别功能来为对象添加属性，利用原型模式的高效共享功能来为对象添加方法。
